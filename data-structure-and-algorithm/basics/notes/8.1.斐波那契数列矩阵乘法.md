# 斐波那契数列矩阵乘法

斐波那契数列递归求解代码如下所示：

```java
static int f1(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    return f1(n - 1) + f1(n - 2);
}
```

因此我们可以得到第 n 项的递推公式为 f(n)=f(n-1)+f(n-2)。

斐波那契数列的线性求解的方式非常好理解，已知数列的前两项，根据前两项使用上述递推公式就可以推导出第 n 项的值。时间复杂度为 O(N)，代码如下所示：

```java
static int f2(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    int res = 1;
    int pre = 1;
    int tmp;
    for (int i = 3; i <= n; i++) {
        tmp = res;
        res = res + pre;
        pre = tmp;
    }
    return res;
}
```

同时利用线性代数，斐波那契数列可以使用下面公式计算所得：

```
斐波那契数列计算公式为 f(n)=f(n-1)+f(n-2)，n>2，f(1)=1,f(2)=1，是一个二阶递推公式，那么其一定存在下述关系：

                
|Fn,Fn-1|=|Fn-1,Fn-2|*|a,b|     --> Fn=a*Fn-1+c*Fn-2     --> a=1 c=1
                      |c,d|         Fn-1=b*Fn-1+d*Fn-2   --> b=1 d=0

|Fn-1,Fn-2|=|Fn-2,Fn-3|*|a,b|    
                        |c,d|  
...

|F3,F2|=|F2,F1|*|a,b|     
                |c,d|     
             
                
|Fn,Fn-1|=|F1,F2|*|a,b|^n-2=|1,1|*|1,1|^n-2
                  |c,d|           |1,0|
```

使用上述递推公式计算斐波那契数列某一项的代码如下：

```java
static int f(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    // 项数矩阵
    // [ 1 ,1 ]
    // [ 1, 0 ]
    int[][] base = {
        {1, 1},
        {1, 0}
    };
    // 求项数矩阵的 n - 2 次幂
    int[][] res = matrixPower(base, n - 2);
    return res[0][0] + res[1][0];
}
```

如果根据上述线性代数推出的公式计算斐波那契某一项的值，计算的效率取决于计算上述矩阵 n-2 次幂的效率。

实际上，求一个数的幂，可以将时间复杂度化为 `O(logN)` 的时间复杂度 。

举个例子，比如我们要求 10^75，正常情况下，我们计算时用 75 个 10 相乘，需要迭代 75 次，代码如下所示：

```java
int mul=1;
for(int i=1;i<=75;i++){
    mul*=10;
}
```

我们知道 `10^75=10^64*10^8*10^2*10^1`，如果我们在计算 10^75 此次方时，第一次用 10^1 去累乘，第二次乘用 10^2 去累乘，第三次用 10^4 去累乘......

这样我们在计算 10^75 时迭代次数就减少为 log(75)。同时我们注意到按照这种逻辑，不是每次迭代时都需要去做累乘操作，比如对于 10^75 来讲，10^4、10^16、10^32 就不需要参与累乘。那么怎么判断什么时候需要乘，什么时候不需要乘呢？

如果我们将 75 转为二进制形式为：1001011（75=64+8+2+1），可以发现二进制对应位数为 1，表示迭代到和位数相等的次数时需要累乘，二进制对应位数为 0，此时则不需要累乘。按照这种方法，计算 10^75 的代码如下：

```java
int ans = 1;
int mod = 10;
int n = 75
while(n!=0) {
    // 对应位数是否为 1
    if (n & 1 !=0) {
        ans *= mod;
    }
    n>>=1;
    // 增长因子
    mod *= mod;
}
```

因此上述求项数矩阵的幂，优化代码如下：

```java
/**
  * 求矩阵的幂
  *
  * @param m 矩阵
  * @param p 指数
  * @return 矩阵的 p 次幂
  */
private static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    // 构建单位矩阵
    for (int i = 0; i < res.length; i++) {
        res[i][i] = 1;
    }
    int[][] t = m;// 矩阵 1 次方
    // 优化为 O(logN)
    for (; p != 0; p >>= 1) {
        if ((p & 1) != 0) {
            res = muliMatrix(res, t);
        }
        // t 的变化趋势为 t t^2 t^4 t^8 ...
        t = muliMatrix(t, t);
    }
    return res;
}
```

## 相关题目

### 迈台阶问题

问题描述如下：

一个人可以一次往上迈 1 个台阶，也可以迈 2 个台阶，返回这个人迈上 n 级台阶的方法数。

如果用递归方法，代码如下所示：

```java
static int steps(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    return steps(n - 1) + steps(n - 2);
}
```

因此可以得到递推公式为 f(n)=f(n-1)+f(n-2)，n>=2，f(1)=1，f(2)=2。

和斐波那契数列问题类似，也可以使用代数的方式进行优化，得台阶问题额可以使用下面公式计算得到：

```
因此最终我们能得到斐波那契数列最终的递推公式为：
|Fn,Fn-1|=|F1,F2|*|1,1|^n-2=|1,2|*|1,1|^n-2
                  |1,0|           |1,0|
```

优化代码如下：

```java
static int steps(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = {{1, 1}, {1, 0}};
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}
```

### 奶牛问题

问题描述如下：

第一年农场有 1 只成熟的母牛 A，往后的每年：

- 每一只成熟的母牛都会生一只母牛；
- 每一只新出生的母牛都在出生的第三年成熟；
- 每一只母牛永远不会死。

返回 N 年后牛的数量。

使用递归代码如下所示：

```java
static int num(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1 || n == 2 || n == 3) {
        return n;
    }
    // 今年牛的数量 = 去年牛的数量 + 今年新生牛的数量
    // 今年新生牛的数量 = 今年成熟牛的数量 = 3 年前牛的数量
    return num(n - 1) + num(n - 3);
}
```

因此我们得到了牛每年数量的计算公式为 f(n)=f(n-1)+f(n-3)，n>3，f(1)=1，f(2)=2，f(3)=3。

根据线性代数的概念，我们知道：

```
|Fn,Fn-1,Fn-2| = |Fn-1,Fn-2,Fn-3|*|a,b,c|      --> Fn=a*Fn-1+d*Fn-2+g*Fn-3    --> a=1,d=0,g=1
                                  |d,e,f|      --> Fn-1=b*Fn-1+e*Fn-2+h*Fn-3  --> b=1,e=0,h=0    
                                  |g,h,i|      --> Fn-2=c*Fn-1+f*Fn-2+i*Fn-3  --> c=0,f=1,i=0       
                                  
|Fn-1,Fn-2,Fn-3| = |Fn-2,Fn-3,Fn-4|*|a,b,c| 
                                    |c,d,e|
                                    |f,g,h|
                                    
|F4,F3,F2| = |F3,F1,F1|*|a,b,c| 
                        |c,d,e|
                        |f,g,h|      
                      
                        
|Fn,Fn-1,Fn-2| = |F3,F2,F1|*|a,b,c|^n-3 = |3,2,1|*|1,1,0|^n-3
                            |c,d,e|               |0,0,1|
                            |f,g,h|               |1,0,0|
```

使用矩阵幂优化代码如下：

```java
static int num(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2 || n == 3) {
        return n;
    }
    int[][] base = {
        {1, 1, 0},
        {0, 0, 1},
        {1, 0, 0}};
    int[][] res = matrixPower(base, n - 3);
    return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
}
```

### 0 1 字符串问题

问题描述如下：

给定一个数 N，想象只由 0 和 1 两种字符，组成的所有长度为 N 的字符串。如果某个字符串，任何 0 字符的左边都有 1 紧挨着，认为这个字符串达标。返回有多少达标的字符串。

这里先进行递归尝试：

```java
/**
  * 用剩下的 n 个字符去组成字符串，且前一个字符（第 n-1 个）一定为 1，因为 0 组成的字符串一定不达标
  * 返回达标的字符串个数
  *
  * @return 标的字符串个数
  */
static int num1(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    // 可能性 1：当前位置用 1 字符
    int p1 = num1(n-1);
    // 可能性 2：当前位置用 0 字符，则下个字符一定要用 1 字符
    int p2 = num1(n-2);
    return p1 + p2;
}
```

可以看出，上述起始是前两项为 1 和 2 的斐波那契数列问题，其使用矩阵幂可以优化到 O(logN)，推到过程和斐波那契数列问题类似，这里省略，代码如下所示：

```java
static int num(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = {
        {1, 1},
        {1, 0}
    };
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}
```

### 瓷砖问题

问题描述如下：

用 `1*2` 的瓷砖，把 `N*2` 的区域填满，返回铺瓷砖的方法数。

递归尝试如下：

```java
static int num(int n) {
    if (n == 0) {
        return 0;
    }
    // 只能竖着放
    if (n == 1) {
        return 1;
    }
    // 两个瓷砖竖着放，两个瓷砖横着放
    if (n == 2) {
        return 2;
    }
    // n 位置的瓷砖竖着放
    int p1 = num(n - 1);
    // n 位置的瓷砖横着放
    int p2 = num(n - 2);
    return p1 + p2;
}
```

可以看出，上述也是一个斐波那契数列问题，且前两项分别为 1 和 2。

因此矩阵幂优化后的代码如下：

```java
static int num(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = {
        {1, 1},
        {1, 0}
    };
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}
```

## 总结

 斐波那契数列问题这种优化方式可以推广到更一般的形式。

如果某个递归，除了初始项之外，具有如下的形式：

```
F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) (C1…Ck 和 k 都是常数)
```

并且这个递归的表达式是**严格的、不随条件转移的**，那么都存在类似斐波那契数列的优化（矩阵幂优化），时间复杂度都能优化成 `O(logN)`。