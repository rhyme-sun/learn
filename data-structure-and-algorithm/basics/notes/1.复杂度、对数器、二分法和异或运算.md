# 复杂度、对数器、二分法和异或运算

## 总览

## 衡量算法优劣的指标

衡量算法优劣的核心指标，包括时间复杂度，额外空间复杂度，常数项时间。

### 时间复杂度

时间复杂度由算法的流程决定，其表示数据**最差情况**下算法**常数时间操作**总次数与样本数量的关系。时间复杂度用大 O 法表示，即 O（忽略常数项和低阶项以及高阶项系数，只保留高阶项），之所以能够忽略常数项和低阶项是因为当样本数量很大时，低阶项对总体的运算量级影响很小，只保留高阶项足以表现算法的优劣。

- 常数时间操作：如果一个操作不以具体样本量为转移，每次执行的时间都是固定时间，则称这样的操作为常数时间操作，常见的常数时间操作如下：
  - 算术运算
  - 位运算
  - 赋值、比较、自增、自减
  - 数组寻址

- 如何确定时间复杂度？
  - 按照**最差的情况**想象算法流程处理完数据的状况；
  - 把整个流程彻底拆分为一个个基本动作，保证每个动作都常数时间操作；
  - 如果数据量是 N，看基本动作总数量和 N 是什么关系。

### 额外空间复杂度

额外空间复杂度由算法流程决定，其表示了额外空间和样本数量的关系。你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。

其中作为输入参数的空间，作为输出结果的空间，也不算**额外空间**。因为这些都是必要的、和现实目标有关的，所以都不算。

除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去，这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

### 常数项时间

时间复杂度只是一个很重要的指标。但如果两个时间复杂度一样的算法，还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。

常数项的时间由算法的实现细节决定，当我们需要通过常数项来进一步判断算法的优劣时，如果去理论分析，就要熟知算法常数项操作的每一个细节，这时候建议放弃理论分析，生成随机数据直接测试算法的优劣。

## 对数器

对数器可以用来测试算法的准确性，流程如下：

1. 你想要测的实现某个算法的方法 a；

2. 找一个实现同样算法的方法 b，方法 b 可以是自己用另外的方式实现的方法，也可以是第三方方法；
3. 实现一个随机样本产生器；
4. 让方法 a 和方法 b 跑相同的随机样本，看看得到的结果是否一样；
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法 a 和方法 b；
6. 当样本数量很多时比对测试依然正确，可以确定方法 a 已经正确。

## 二分查找法

对于一个长度固定的数组，通过每次淘汰一半元素的方法找到最终满足需求的元素，叫做二分法查找。通过二分法我们可以在 O(logN) 的时间复杂度内找到我们需要的元素。二分法不要求数组是有序的，只要能够建立起一半元素的淘汰策略即可。比如，二分法可以解决以下几个问题：

- 在一个有序数组（从小到大）中，找某个数是否存在。

  ```java
  public class BSExist {
  
      static int exist(int[] sortedArr, int num) {
          if (sortedArr == null || sortedArr.length == 0) {
              return -1;
          }
          int l = 0;
          int r = sortedArr.length - 1;
          int mid;
          while (l < r) {
              // mid = (l + r) / 2
              // 使用右移运算而不是除法运算，是因为右移运算更快
              // l + ((r - l) >> 1) 而不是 (l + r) >> 1 是为了避免超过 int 的最大值
              mid = l + ((r - l) >> 1);
              if (sortedArr[mid] == num) {
                  return mid;
              } else if (sortedArr[mid] > num) {
                  r = mid - 1;
              } else {
                  l = mid + 1;
              }
          }
          return sortedArr[l] == num ? l : -1;
      }
  
      public static void main(String[] args) {
          int[] array = SortTestUtils.generateRandomArray(10, 10);
          SortTestUtils.comparator(array);
          SortTestUtils.printArray(array);
          System.out.println(exist(array, 0));
          System.out.println(exist(array, 1));
          System.out.println(exist(array, 2));
      }
  }
  ```

- 在一个有序数组（从下到大）中，找 >= 某个数最左侧的位置，即找到 >= 某个数的最小值。

  ```java
  public class BSNearLeft {
  
      static int nearLeft(int[] array, int num) {
          if (array == null || array.length == 0) {
              return -1;
          }
          int l = 0;
          int r = array.length - 1;
          int index = -1;
          while (l <= r) {
              int mid = l + ((r - l) >> 1);
              if (array[mid] >= num) {
                  index = mid;
                  r = mid - 1;
              } else {
                  l = mid + 1;
              }
          }
          return index;
      }
  
      public static void main(String[] args) {
          int[] array = SortTestUtils.generateRandomArray(10, 10);
          SortTestUtils.comparator(array);
          SortTestUtils.printArray(array);
          System.out.println(nearLeft(array, 0));
      }
  }
  ```

- 在一个有序数组（从小到大）中，找 <= 某个数最右侧的位置，即找到 <= 某个数的最大值。

  ```java
  public class BSNearRight {
  
      static int nearLeft(int[] array, int num) {
          if (array == null || array.length == 0) {
              return -1;
          }
          int l = 0;
          int r = array.length - 1;
          int index = -1;
          while (l <= r) {
              int mid = l + ((r - l) >> 1);
              if (array[mid] <= num) {
                  index = mid;
                  l = mid + 1;
              } else {
                  r = mid - 1;
              }
          }
          return index;
      }
  
      public static void main(String[] args) {
          int[] array = SortTestUtils.generateRandomArray(10, 10);
          SortTestUtils.comparator(array);
          SortTestUtils.printArray(array);
          System.out.println(nearLeft(array, 0));
      }
  }
  ```

- 局部最小值问题。

  局部最小值问题：对于一个长度为 N 的无序数组，对于首元素，若第 1 个元素比第 2 个元素小，第 1 个元素就是局部最小值；对末尾元素，若第 N-1 个元素比第 N 个元素大，第 N 元素就是局部最小值；对于中间的元素，若与其相邻前一个元素比它大，后一个元素比它小，则该元素为局部最小值。我们可以使用二分法找到局部最小值的位置，代码如下所示：

  ```java
  public class BSLocalLess {
  
      public static int localLess(int[] arr) {
          if (arr == null || arr.length == 0) {
              return -1; // no exist
          }
          if (arr.length == 1 || arr[0] < arr[1]) {
              return 0;
          }
          if (arr[arr.length - 1] < arr[arr.length - 2]) {
              return arr.length - 1;
          }
          int l = 1;
          int r = arr.length - 2;
          while (l < r) {
              int mid = l + ((r - l) >> 1);
              if (arr[mid] > arr[mid - 1]) {
                  r = mid - 1;
              } else if (arr[mid] > arr[mid + 1]) {
                  l = mid + 1;
              } else {
                  return mid;
              }
          }
          return l;
      }
  
      public static void main(String[] args) {
          int[] array = SortTestUtils.generateRandomArray(10, 10);
          SortTestUtils.printArray(array);
          System.out.println(localLess(array));
      }
  }
  ```

## 异或运算

### 基础知识

- 原码，反码，补码
  - 原码：一个带符号整数的符号位加上数值位的二进制表示叫做原码，其中整数的最高位符号位，为 0 表示正数，为 1 表示负数。
  - 反码：正整数，反码与原码相同；负整数，反码为原码的符号为不变，数值位取反。
  - 补码：正数，补码和源码相同；负数，补码为原码的符号位不变，数值位取反再加 1。

  总的来说就是，正整数的原码、反码、补码均相同；负整数的反码和原码相比，符号位不变，数值位取反，补码和原码相比，符号位不变，数值位取反加一，即反码加一。

  在 Java 中所有的数都已补码的形式来表示，位移操作和位操作也是针对补码进行操作。

- 位移运算：
  - `>>`（带符号右移）：表示带符号位右移，将原来数补码的低位抹去，高位用原来的符号位补充。
  - `>>>`（无符号右移）：表示不带符号右移，将原来数补码的低位抹去，高位补 0。
  - `<<`（左移）：表示左移，将原来数补码的高位抹去，低位补 0。

  带符号整数右移 n（n 为正整数） 位，相当除以 2^n ；左移 n 位，相当于乘以 2^n。比如：`N * 2 + 1` 就相当于 `(N >> 1) | 1`。

- 位运算
  - &（按位与）：将两个整数的补码对应的每一位做与运算。
  - |（按位或）：将两个整数的补码对应的每一位做或运算。
  - ~（按位取反）：将一个整数的补码对应的每一位做取反运算。
  - ^（按位异或）：将一个整数的补码对应的每一位做异或运算。

### 异或运算的性质

两个数的补码，对应位做无进位相加，也就是相异为 1，相同为 0。异或运算有以下性质：

- N ^ N = 0
- N ^ 0 = N
- 满足交换率和结合率，即若干整数做异或运算，最终结果和异或的顺序无关。

### 异或运算的应用

- 如何不用额外变量交换两个整数

  ```java
  public class Swap {
  
      /**
       * 交换数组 i 和 j 位置的值，不能是同一个位置
       */
      public static void swap(int[] arr, int i, int j) {
          arr[i] = arr[i] ^ arr[j];
          arr[j] = arr[i] ^ arr[j];
          arr[i] = arr[i] ^ arr[j];
      }
  
      public static void main(String[] args) {
          int a = 1;
          int b = 2;
          int[] array = {a, b};
  
          System.out.println("Before swap.");
          System.out.println("array[0]=" + array[0]);
          System.out.println("array[1]=" + array[1]);
          swap(array, 0, 1);
          System.out.println("After swap.");
          System.out.println("array[0]=" + array[0]);
          System.out.println("array[1]=" + array[1]);
      }
  }
  ```

  证明：

  ```
  a = a^b;
  b = a^b;
  a = a^b;
  
  a = a^b
  b = a^b = (a^b)^b = a^(b^b) = a^0 = a
  a = a^b = (a^b)^a = (a^a)^b = 0^b = b
  ```

- 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数。代码如下：

  ```java
  public class OddTimes {
  
      /**
       * 一个数组中，有一种数出现了奇数次，其余数均出现偶数次，找出这个数并打印。
       * 将数组中的数做异或运算，更具异或运算的性质，出现偶数次的数异或结果为 0 ，奇数次异或结果为本身。
       */
      static void once(int[] array) {
          if (array == null || array.length == 0) {
              System.out.println("Array can't be empty!");
              return;
          }
          int eor = 0;
          for (int i : array) {
              eor ^= i;
          }
          System.out.println(eor);
      }
  
      public static void main(String[] args) {
          int[] array = {-1, -1, 0, 0, 0, 1, 1, 1, 1};
          once(array);
      }
  }
  ```

- 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数。

  找出一个整数 a 最右侧的 1，比如 10101000 -> 00001000，使用 `a & (~a + 1)` 即可以找到 a 最右侧的 1，过程如下：

  ```
  10101000 假设为 a 的二进制
  01010111 取反
  01011000 加一
  
  10101000
  01011000 与操作，高于最右侧的位，相反，低于最右侧的位为 0，最有侧位为 1
  
  00001000 获得结果
  ```

  代码实现：

  ```java
  public class OddTimes {
  
      /**
       * 一个数组中，有两种种数出现了奇数次，其余数均出现偶数次，找出这两种数并打印。
       * 将数组中的元素做异或运算，假设这两种数分别为 a 和 b，那么根据异或运算性质，最终结果为 a^b；
       * 因为 a!=b，所以 a^b!=0, 就一定存在某位为 1，找到 a^b 右侧第一个为 1 的位置，假设为第 5 位，此时就可以将数组中的数分成两大类，
       * 即第 5 位为 0 和 第 5 位为 1；
       * a 和 b 一定分别存在这两大类中，因为异或运算，只有对应位值不相等是才能得到 1；
       * 在对其中一类的数做异或运算就能得到 a 或 b。
       */
      static void twice(int[] array) {
          if (array == null || array.length == 0) {
              System.out.println("Array can't be empty!");
              return;
          }
          int eor = 0;
          for (int i : array) {
              eor ^= i;
          }
          // 找出最右侧的 1
          int rightOne = eor & (~eor + 1);
  
          int onlyOne = 0;
          for (int i : array) {
              if ((i & rightOne) == 0) {
                  onlyOne ^= i;
              }
          }
          System.out.println(onlyOne);
          System.out.println(onlyOne ^ eor);
      }
  
      public static void main(String[] args) {
          int[] array = {-1, -1, 0, 0, 0, 1, 1, 1, 1, 2};
          twice(array);
      }
  }
  
  ```

  ```
  Note:
  使用 a & (~a + 1) 找出 a 最右侧的 1，这个公式比较常用。
  ```

## 总结

