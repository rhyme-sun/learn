# 动态规划

如果你在调用过程中发现重复过程，将过程结果记录下来，下次再遇到相同调用直接使用结果，这一过程就叫做动态规划。

举个例子，比如我们我们可以使用下面递归代码解决斐波那契数列问题：

```java
/**
  * 求斐波那契数列第 n 项的值
  */
static int f(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    return f(n - 1) + f(n - 2);
}
```

比如我们要求斐波那契第 5 项的值，其递归序列如下所示：

```
         f(5)                                                       f(5)   
      /        \                                                 /        \
    f(4)       f(3)              ----使用缓存---->              f(4)       f(3)-Cache
    /  \       /  \                                           /  \       
  f(3) f(2)  f(2) f(1)                                      f(3) f(2)-Cache               
  /  \                                                     /  \
f(2) f(1)                                                f(2) f(1)
```

从上面递归序列我们可以看出，我们在求 f(5) 时，其下的某些子过程会调用多次，比如上述的 f(3)、f(2)、f(1)。为此我们可以将每个过程首次调用的结果缓存下来，下次遇到时从缓存里这届去，这样就避免了重复的子过程调用。那么这种使用缓存（空间换时间）缓存重复过程结果的优化就是动态规划。

## 尝试到优化

在解决动态规划的问题时，我们先通过尝试（暴力递归）去解决，然后再使用动态规划相关技巧去优化。还是通过例子来说明。

### 机器人走路问题

问题描述如下：

假设有排成一行的 *N* 个位置，记为 *1~N*，*N* 一定大于或等于 2。

开始时机器人在其中的 *M* 位置上（*1<=M<=N*），如果机器人来到 1 位置，那么下一步只能往右来到 2 位置；如果机器人来到 *N* 位置，那么下一步只能往左来 *N-1* 位置；如果机器人来到中间位置，那么下一步可以往左走或者往右走；

规定机器人必须走 *K* 步，最终能来到 *P* 位置（*1<=P<=N*），求机器人从 *P* 位置走到 *K* 位置一共有多少走法？

#### 递归尝试

我们假设机器人目前来到了 cur 位置，还剩下 rest 步，然后考虑这种情况下，机器人从 cur 走向目标位置的 aim 走法数量，代码如下：

```java
static int ways1(int n, int start, int aim, int steps) {
    if (n < 2 || start < 1 || start > n || aim < 1 || aim > n || steps < 1) {
        return -1;
    }
    return process1(n, start, aim, steps);
}

/**
  * 当前来到 cur 位置，考虑有多少种走法。
  *
  * @param n    位置总数
  * @param cur  机器来当前来到的位置
  * @param aim  目标位置
  * @param rest 剩余的步数
  * @return 走法数量
  */
private static int process1(int n, int cur, int aim, int rest) {
    if (rest == 0) {
        return cur == aim ? 1 : 0;
    }
    // 走到了 1 位置，只能往右走
    if (cur == 1) {
        return process1(n, 2, aim, rest - 1);
    }
    // 走到了 n 位置，只能往左走
    if (cur == n) {
        return process1(n, n - 1, aim, rest - 1);
    }
    return process1(n, cur - 1, aim, rest - 1) + process1(n, cur + 1, aim, rest - 1);
}
```

#### 记忆搜索优化

我们考虑下上述递归有没有重复的子过程，比如机器人现在来到了 7 这个位置，还有 8 步要走，其递归序如下：

```
       (7,8)
       /    \
    (6,7)   (8,7)
    / \      / \
(5,6)(8,6) (8,6)(9,6)
```

可以看出机器人来到 8 这个位置，还剩 6 步这个调用出现了重复，因此我们可以使用缓存对其进行优化，优化代码如下：

```java
static int ways2(int n, int start, int aim, int steps) {
    if (n < 2 || start < 1 || start > n || aim < 1 || aim > n || steps < 1) {
        return -1;
    }
    // dp 就是缓存表，其记录机器人来到 cur 位置，还剩 rest 步的走发数量
    // cur 从 1~n，rest 从 0~steps，所以 int[n + 1][steps + 1] 就可以缓存下所有可能出现的结果
    // dp[cur][rest] == -1 -> process1(cur, rest)之前没算过
    // dp[cur][rest] != -1 -> process1(cur, rest)之前算过
    int[][] dp = new int[n + 1][steps + 1];
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= steps; j++) {
            dp[i][j] = -1;
        }
    }
    return process2(n, start, aim, steps, dp);
}

/**
  * cur：1~n
  * rest: 0~steps
  */
private static int process2(int n, int cur, int aim, int rest, int[][] dp) {
    if (dp[cur][rest] != -1) {
        return dp[cur][rest];
    }
    int ans;
    if (rest == 0) {
        ans = cur == aim ? 1 : 0;
    } else if (cur == 1) {
        ans = process2(n, 2, aim, rest - 1, dp);
    } else if (cur == n) {
        ans = process2(n, n - 1, aim, rest - 1, dp);
    } else {
        ans = process2(n, cur - 1, aim, rest - 1, dp) + process2(n, cur + 1, aim, rest - 1, dp);
    }
    dp[cur][rest] = ans;
    return ans;
}
```

上述使用缓存避免相同子过程重复调用的优化叫做**从顶到下的动态规划**，也叫做**记忆化搜索**。

#### 动态规划优化

从上述的记忆搜索优化我们可以看出，我们使用了一个 `dp[cur][rest]` 表缓存了机器人当前再 cur 位置，还有 rest 步状态下走到目标位置的走法数量。换句话说，在 dp 这个缓存表维护好后，我们可以根据任意的 cur 和 rest 从表里拿到我们想要的答案。比如我们要求机器人在 2 这个位置，走到 4 这个位置，一共能够走 4 步的走法数量，那么我们直接获取 `dp[2][4]` 这个位置的数就是我们想要的结果。

那么这个 dp 表要怎么直接维护呢？

其实通过我们递归尝试的逻辑就可以维护出这个 dp 表，为了方面描述，我们假设机器人要走的位置从 1~5，开始在 2 位置，需要走向 4 位置，需要走 6 步。按照递归尝试的逻辑，维护步骤如下：

- dp 表为一个矩阵，矩阵的行序号表示机器人当前来到的位置，矩阵的列序号表示还剩余的步数；

- 然后我们考虑 dp 表的容量，由于 cur 范围为从 1~5，走的步数可能情况为 0~6，所以我们用一个 5*7 的矩阵就可以容纳全部结果（当然了由于 cur 不可能为 0，也就是矩阵的第 1 行不会被使用，但这并不影响我们计算的结果）；

- 当 rest 为 0 时（即对应矩阵的第 1 列），只有当 cur 位置为目标位置时，才有 1 种走法，其余位置全部为 0，因此此时 dp 矩阵为：

  ```
     0 1 2 3 4 5 6
  0  x x x x x x x
  1  0
  2  0
  3  0
  4  1
  5  0
  ```

- 根据递归规则：

  - 当 cur = 1 时，`dp[1][rest]` 位置上的值等于 `dp[2][rest-1]` ，即左下角的值；
  - 当 cur = n 时，`dp[n][rest]` 位置上的值等于 `dp[n-1][rest-1]`，即左上角的值；
  - 当 1<cur<n 时，`dp[cur][rest]` 位置上的值等于 `dp[cur-1][rest-1] + dp[cur+1][rest-1]` ，即左下角和左上角的值的和；

  然后 dp 根据上述规则维护就为：

  ```
     0 1 2 3 4 5 6
  0  x x x x x x x
  1  0 0 0 1 0 4 0
  2  0 0 1 0 4 0 13
  3  0 1 0 3 0 9 0
  4  1 0 2 0 5 0 14
  5  0 1 0 2 0 5 0
  ```

  那么我们想要的结果，即 `dp[2][6]` 的值就为 13。

  > 其实上述矩阵的构成其实是带边的杨辉三角。

代码如下：

```java
static int ways3(int n, int start, int aim, int steps) {
    if (n < 2 || start < 1 || start > n || aim < 1 || aim > n || steps < 1) {
        return -1;
    }
    int[][] dp = new int[n + 1][steps + 1];
    // rest = 0
    dp[aim][0] = 1;
    // 遍历列
    for (int rest = 1; rest <= steps; rest++) {
        // cur = 1;
        dp[1][rest] = dp[2][rest - 1];
        // 遍历行
        // 1<cur<n
        for (int cur = 2; cur < n; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        // cur = n
        dp[n][rest] = dp[n - 1][rest - 1];
    }
    return dp[start][steps];
}
```

### 纸牌比大小问题

问题描述如下：

给定一个整型数组 arr，代表数值不同的纸牌排成一条线，玩家 A 和玩家 B 依次拿走每张纸牌。规定玩家 A 先抽牌，玩家 B 后抽牌，但是每个玩家每次只能拿走最左或最右的纸牌，将每次拿取的点数累加到分数。A 和 B 都绝顶聪明，每次都选择最优的情况拿牌，那么当抽牌结束后，请返回获胜者的分数。

#### 递归尝试

递归尝试体现了你最自然的解决问题策略。代码如下：

```java
static int win1(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int first = f1(arr, 0, arr.length - 1);
    int second = g1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}

/**
  * 在 arr[l..r] 范围内，先手获得的最好分数返回
  * @return 先手拿牌最好分数
  */
private static int f1(int[] arr, int l, int r) {
    // 最后一张牌，你是先手，直接拿走
    if (l == r) {
        return arr[l];
    }
    // 先手在拿最左侧一张牌时，最大分数就为后手在 arr[l+1,r] 内的最大分数加 arr[l]
    int p1 = arr[l] + g1(arr, l + 1, r);
    // 先手在拿最右侧一张牌时，最大分数就为后手在 arr[l,r-1] 内的最大分数加 arr[r]
    int p2 = arr[r] + g1(arr, l, r - 1);
    // 那么先手拿牌的最优解就是 p1 和 p2 的最大值
    return Math.max(p1, p2);
}

/**
  * 在 arr[l..r] 范围内，后手拿牌可获取的最好分数。注意，后手在先手做出了最优选择下做选择。
  * @return 后手拿牌最好分数
  */
private static int g1(int[] arr, int l, int r) {
    if (l == r) {
        // 你是后手，先手把最后一张牌拿走了，所以这里返回 0
        return 0;
    }
    // 对手拿走了 l 位置的牌，那么接下来就相当于你作为先手在 arr[l+1,r] 范围内尝试获取最大分数
    int p1 = f1(arr, l + 1, r);
    // 对手拿走了 r 位置的牌，那么接下来就相当于你作为先手在 arr[l,r-1] 范围内尝试获取最大分数
    int p2 = f1(arr, l, r - 1);
    // 因为考虑你是后手，先手最优情况下，不会留下较大的情况给你，所以这里返回 p1 和 p2 小的那一个
    return Math.min(p1, p2);
}
```

#### 记忆搜索优化

我们下来看下上述递归过程有没有重复过程，假设代表纸牌的数组长度为 7，那么其递归序列为：

```
          f(0,7)
         /      \
   g(1,7)       g(0,6)
   /    \       /     \
f(2,7) f(1,6) f(0,5) f(1,6)
```

可以看出存在相同的过程，那么就可以使用缓存去优化上述递归，优化后的代码如下：

```java
static int win2(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int n = arr.length;
    int[][] fdp = new int[n][n];
    int[][] gdp = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            fdp[i][j] = -1;
            gdp[i][j] = -1;
        }
    }
    int first = f2(arr, 0, arr.length - 1, fdp, gdp);
    int second = g2(arr, 0, arr.length - 1, fdp, gdp);
    return Math.max(first, second);
}

/**
  * 在 arr[l..r] 范围内，先手获得的最好分数返回
  *
  * @return 先手拿牌最好分数
  */
private static int f2(int[] arr, int l, int r, int[][] fdp, int[][] gdp) {
    if (fdp[l][r] != -1) {
        return fdp[l][r];
    }
    int ans;
    if (l == r) {
        ans = arr[l];
    } else {
        int p1 = arr[l] + g2(arr, l + 1, r, fdp, gdp);
        int p2 = arr[r] + g2(arr, l, r - 1, fdp, gdp);
        ans = Math.max(p1, p2);
    }
    fdp[l][r] = ans;
    return ans;
}

/**
  * 在 arr[l..r] 范围内，后手拿牌可获取的最好分数，注意，后手在先手做出了最优选择下做选择。
  *
  * @return 后手拿牌最好分数
  */
private static int g2(int[] arr, int l, int r, int[][] fdp, int[][] gdp) {
    if (gdp[l][r] != -1) {
        return gdp[l][r];
    }
    int ans = 0;
    if (l != r) {
        int p1 = f2(arr, l + 1, r, fdp, gdp);
        int p2 = f2(arr, l, r - 1, fdp, gdp);
        ans = Math.min(p1, p2);
    }
    gdp[l][r] = ans;
    return ans;
}
```

#### 动态规划优化

我们发现上述的 `fdp[l][r]` 和 `gdp[l][r]` 分别表示在卡片数组的 l~r 范围内，先手和后手的最优解。那么如果根据最初的递归过程维护好这两个缓存表，我们就可以根据任意的 l 和 r 值来得到我们想要的答案。

那么 fdp 和 gdp 要怎么维护呢，这就要回到我们最初的尝试中。为了方便描述，假设卡片数组为 `[5,2,9,4,6]`，那么缓存表维护过程如下：

- 首先我们需要 5*5 的矩阵分别来存放先手和后手的最优解；

- 当 r=l 时，先手缓存表对应位置的值就为对应卡片数组位置的值，后手缓存表对应位置为 0，因为 l<=r，所以在缓存表中，l > r 的位置均使用不到，即面的 x；

  ```
    先手缓存表（fdp）                                        后手缓存表（fdp）
     0  1  2  3  4                                          0  1  2  3  4    
  0  5                                                   0  0  
  1  x  2                                                1  x  0              
  2  x  x  9                                             2  x  x  0
  3  x  x  x  4                                          3  x  x  x  0
  4  x  x  x  x  6                                       4  x  x  x  x  0
  ```

- 然后对于 `fdp[l][r]`，通过递归过程可以发现其依赖于 `arr[l]+g[l+1][r]` 和 `arr[r]+g[l][r-1]` 两者中的较大值；

  对于 `gdp[l][r]`，通过递归过程可以发现其依赖于 `f[l+1][r]` 和 `f[l][r-1]` 两者中的较小值；

  根据上述规则，我们就可以维护好上述的缓存表为：

  ```
    先手缓存表（fdp）                                        后手缓存表（fdp）
     0  1  2  3  4                                          0  1  2  3  4    
  0  5  5  11 14 12                                      0  0  2  5  6  14
  1  x  2  9  6  15                                      1  x  0  2  9  6     
  2  x  x  9  9  13                                      2  x  x  0  4  6
  3  x  x  x  4  6                                       3  x  x  x  0  4
  4  x  x  x  x  6                                       4  x  x  x  x  0
  ```

​		因此上述问题的解为 `fdp[0][4]` 和 `gdp[0][4] ` 中的最大值，即为 14。

代码如下所示：

```java
static int win3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int n = arr.length;
    int[][] fdp = new int[n][n];
    int[][] gdp = new int[n][n];
    for (int i = 0; i < n; i++) {
        // l=r
        fdp[i][i] = arr[i];
    }
    for (int startCol = 1; startCol < n; startCol++) {
        int l = 0;
        int r = startCol;
        while (r < n) {
            fdp[l][r] = Math.max(arr[l] + gdp[l + 1][r], arr[r] + gdp[l][r - 1]);
            gdp[l][r] = Math.min(fdp[l + 1][r], fdp[l][r - 1]);
            l++;
            r++;
        }
    }
    return Math.max(fdp[0][n - 1], gdp[0][n - 1]);
}
```

### 背包问题

问题描述如下：

给定两个长度都为 *n* 的数组 weights 和 values，weights[i] 和 values[i] 分别代表 i 号物品的重量和价值（物品的重量和价值都非负）。现有一个载重 bag 的袋子，你装的物品不能超过这个重量，问返回你能装下最多的价值是多少? 

#### 递归尝试

这是一个从左往右递归尝试的问题，详细来说就是从左往右依次递归考虑数组中每个元素的所有可能性，且本次的递归依赖上次的递归结果。

那么对于整个问题递归尝试就为，从左往右依次靠某个货物，其可能性有两种：拿整个货物和不拿整个货物。递归返回我们想要的结果，即背包能装货物的最大价值，每次递归根据上次递归的结果和递归的可能性得到本次的递归结果返回，代码如下所示：

```java
/**
  * 方法 1，尝试递归
  *
  * @param w   货物重量数组
  * @param v   货物价值数组
  * @param bag 背包容量
  * @return 背包能装货物的最大价值
  */    
static int maxValue(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || w.length == 0) {
        return 0;
    }
    return process(w, v, 0, bag);
}

/**
  * 从左往右递归，来到 index 号货物
  *
  * @param w     货物重量数组
  * @param v     货物价值数组
  * @param index 第 index 号货物
  * @param rest  背包剩余容量
  * @return 来到 index 位置时，背包能装货物的最大价值
  */
private static int process(int[] w, int[] v, int index, int rest) {
    if (rest < 0) {
        // -1 表示无效值，上游递归在收到无效值时，不纳入计算结果
        return -1;
    }
    if (index == w.length) {
        return 0;
    }
    // 不拿这个货物
    int p1 = process(w, v, index + 1, rest);
    int p2 = 0;
    int next = process(w, v, index + 1, rest - w[index]);
    if (next != -1) {
        p2 = v[index] + next;
    }
    return Math.max(p1, p2);
}
```

#### 动态规划优化

这里我们直接考虑怎么使用 dp 缓存表去优化，忽略掉缓存优化的讨论过程。

首先上述递归是由重复子过程的，还是举个例子，比如货物重量数组为 `[2,3,5,7....]`，背包容量为 15，递归序如下：

```
        f(0,15)
       /        \
    f(1,15)    f(1,13)
    /             \
  f(2,15)       f(3,10)
  /      \
f(3,15) f(3,10)
```

可以看出上述递归过程中存在 f(3,10) 这个重复过程。

然后我们根据原始递归尝试构建 `dp[index][bag]` 缓存表，其中 index 表示货物序号，bag 表示背包剩余容量。

代码如下：

```java
static int dp(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || w.length == 0) {
        return 0;
    }
    int n = w.length;
    int[][] dp = new int[n + 1][bag + 1];
    for (int index = n - 1; index >= 0; index--) {
        for (int rest = 0; rest <= bag; rest++) {
            int p1 = dp[index + 1][rest];
            int p2 = 0;
            int next = rest - w[index] < 0 ? -1 : dp[index + 1][rest - w[index]];
            if (next != -1) {
                p2 = v[index] + next;
            }
            dp[index][rest] = Math.max(p1, p2);
        }
    }
    return dp[0][bag];
}
```

### 数字字符串转字母

规定 1 和 A 对应、2 和 B 对应、3 和 C 对于，11 和 K 对应，...，26 和 Z 对应。那么一个数字字符串比如 111 就可以转化为：AAA、KA 和 AK。给定一个只有数字字符组成的字符串 str，返回有多少种转化结果。

#### 递归尝试

代码如下：

```java
/**
  * str 只含有数字字符 0~9，按照规则转换成字母字符串
  *
  * @param str
  * @return 转换方案数量
  */
static int number(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    return process(str.toCharArray(), 0);
}

/**
  * 来到 i 位置，考虑递归过程
  *
  * @param str str
  * @param i   i
  * @return 转换方案数量
  */
private static int process(char[] str, int i) {
    if (i == str.length) {
        return 1;
    }
    // i 没到最后，说明有字符
    if (str[i] == '0') { // 之前的决定有无效
        return 0;
    }
    // str[i] != '0'
    // 可能性 1，单独转换 i
    int ways = process(str, i + 1);
    // 可能性 2，转换 i 和 i+1 合起来的数字
    if (i + 1 < str.length && (str[i] - '0') * 10 + str[i + 1] - '0' < 27) {
        ways += process(str, i + 2);
    }
    return ways;
}
```

#### 优化

使用 dp 数字优化，代码如下：

```java
static int dp(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int n = str.length;
    int[] dp = new int[n + 1];
    dp[n] = 1;
    for (int i = n - 1; i >= 0; i--) {
        if (str[i] != '0') {
            int ways = dp[i + 1];
            if (i + 1 < str.length && (str[i] - '0') * 10 + str[i + 1] - '0' < 27) {
                ways += dp[i + 2];
            }
            dp[i] = ways;
        }
    }
    return dp[0];
}
```

### 贴纸问题

给定一个字符串 str，一个字符串类型的数组 arr，出现的字符都是小写英文。arr 每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出 str 来。求返回需要至少多少张贴纸可以完成这个任务，可以重复选择 arr 中的字符串？

比如 str= "babac"，arr = {"ba","c","abcd"}。如果我们选择 ba + ba + c，那么需要 3 张贴纸可以拼接出字符串 babac；如果选择 abcd + abcd，那么需要 2 张贴纸；如果选择 abcd + ba，那么需要 2 张贴纸。所以返回 2。

#### 递归尝试

递归尝试代码如下所示：

```java
static int minStickers1(String[] stickers, String target) {
    int ans = process1(stickers, target);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

/**
  * 方法 1，递归方法，选择少的贴纸字符串，使得贴纸的字符串能够完全覆盖目标字符串的所有字符
  *
  * @param stickers 贴纸数组，一个贴纸可以多次使用
  * @param target   目标字符串
  * @return 最小贴纸数量
  */
private static int process1(String[] stickers, String target) {
    if (target.length() == 0) {
        return 0;
    }
    int min = Integer.MAX_VALUE;
    for (String first : stickers) {
        String rest = minus(target, first);
        if (rest.length() != target.length()) {
            min = Math.min(min, process1(stickers, rest));
        }
    }
    return min + (min == Integer.MAX_VALUE ? 0 : 1);
}
```

#### 优化

这里将贴纸字符串使用一个长度为 26 的数组来表示，数组每个位置存放对应字符出现的次数，比如数组 0 位置为 2，表示这个贴纸字符串 a 一共出现了两次。

然后再针对这个结果对上述代码进行优化，优化后的代码如下所示：

```java
static int minStickers2(String[] stickers, String target) {
    int n = stickers.length;
    // 关键优化（用词频表替代贴纸数组）
    // 贴纸字符串不再用字符串表示，而是用一个长度为 26 数组，数组的每个位置存放其对应字母出现的次数，比如数组 0 位置为 2，表示
    // a 出现了 2 次
    int[][] counts = new int[n][26];
    for (int i = 0; i < n; i++) {
        char[] str = stickers[i].toCharArray();
        for (char cha : str) {
            counts[i][cha - 'a']++;
        }
    }
    int ans = process2(counts, target);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

/**
  * 使用数组表示贴纸
  *
  * @param stickers 所有贴纸
  * @param t        目标字串
  * @return 搞定 target 的最少张数
  */
private static int process2(int[][] stickers, String t) {
    if (t.length() == 0) {
        return 0;
    }
    // target做出词频统计
    // target  aabbc  2 2 1..
    //                0 1 2..
    char[] target = t.toCharArray();
    int[] tcounts = new int[26];
    for (char cha : target) {
        tcounts[cha - 'a']++;
    }
    int N = stickers.length;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < N; i++) {
        // 尝试第一张贴纸是谁
        int[] sticker = stickers[i];
        // 最关键的优化（重要的剪枝，这一步也是贪心!）
        if (sticker[target[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                if (tcounts[j] > 0) {
                    int nums = tcounts[j] - sticker[j];
                    for (int k = 0; k < nums; k++) {
                        builder.append((char) (j + 'a'));
                    }
                }
            }
            String rest = builder.toString();
            min = Math.min(min, process2(stickers, rest));
        }
    }
    return min + (min == Integer.MAX_VALUE ? 0 : 1);
}
```

上述代码相对于第一次尝试主要做了两种优化，依次是将字符用字符频率数组表示，从目标字符串去除贴纸包含相同的字符，效率更高。

第二个优化就是剪枝处理，如过贴纸字符里没有能够组成目标字符串的第一个字符，那么这个贴纸一定无效。

#### 记忆搜索优化

不是所有的问题都可以去设计 dp 数组表去解决，比如这个问题。递归函数的动态参数为 target 剩余字符串，很难设计并直接维护 dp 缓存数组表。因此这里我们使用 Map 作为 dp 表，缓存每个过程的结果，避免相同过程重复调用。优化代码如下所示：

```java
static int minStickers3(String[] stickers, String target) {
    int N = stickers.length;
    int[][] counts = new int[N][26];
    for (int i = 0; i < N; i++) {
        char[] str = stickers[i].toCharArray();
        for (char cha : str) {
            counts[i][cha - 'a']++;
        }
    }
    HashMap<String, Integer> dp = new HashMap<>();
    dp.put("", 0);
    int ans = process3(counts, target, dp);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

/**
  * 方法 3，记忆搜索优化
  */
private static int process3(int[][] stickers, String t, HashMap<String, Integer> dp) {
    if (dp.containsKey(t)) {
        return dp.get(t);
    }
    char[] target = t.toCharArray();
    int[] tcounts = new int[26];
    for (char cha : target) {
        tcounts[cha - 'a']++;
    }
    int N = stickers.length;
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < N; i++) {
        int[] sticker = stickers[i];
        if (sticker[target[0] - 'a'] > 0) {
            StringBuilder builder = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                if (tcounts[j] > 0) {
                    int nums = tcounts[j] - sticker[j];
                    for (int k = 0; k < nums; k++) {
                        builder.append((char) (j + 'a'));
                    }
                }
            }
            String rest = builder.toString();
            min = Math.min(min, process3(stickers, rest, dp));
        }
    }
    int ans = min + (min == Integer.MAX_VALUE ? 0 : 1);
    dp.put(t, ans);
    return ans;
}
```

### 最长公共子序列长度

给定两个字符串 str1 和 str2，返回这两个字符串的最长公共子序列长度。

比如：str1 = “a**12**b**3**c**456**d”，str2 = “**1**ef**23**ghi**4**j**56**k”，最长公共子序列是 “123456”，所以返回长度 6。

> 注意这里的子序列不等于子串，
>
> 子序列要求字符之间一定要连续，子串则要求连续。

#### 递归尝试

代码如下所示：

```java
 static int longestCommonSubsequence1(String s1, String s2) {
        if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
            return 0;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // 尝试
        return process1(str1, str2, str1.length - 1, str2.length - 1);
    }

/**
  * 考虑 str1[0~i] 和 str2[0~j] 范围最小公共子序列长度
  *
  * @param str1 str1
  * @param str2 str2
  * @param i    字符串 1 最后考虑的位置
  * @param j    字符串 2 最后考虑的位置
  * @return 最小公共子序列长度
  */
private static int process1(char[] str1, char[] str2, int i, int j) {
    if (i == 0 && j == 0) {
        return str1[i] == str2[j] ? 1 : 0;
    } else if (i == 0) {
        if (str1[i] == str2[j]) {
            return 1;
        } else {
            return process1(str1, str2, 0, j - 1);
        }
    } else if (j == 0) {
        if (str1[i] == str2[j]) {
            return 1;
        } else {
            return process1(str1, str2, i - 1, 0);
        }
    } else { // i != 0 && j != 0
        // 样本模型（一个样本做行，一个样本做列），使用结尾位置讨论可能性
        // 第一种可能性，公共子序列一定不以 i 位置的字符结尾，可能以 j 位置的字符结尾
        int p1 = process1(str1, str2, i - 1, j);
        // 第二种可能性，公共子序列一定不以 j 位置的字符结尾，可能以 i 位置的字符结尾
        int p2 = process1(str1, str2, i, j - 1);
        // 第三种可能性，公共子序列以 i 和 j 位置的字符结尾
        int p3 = str1[i] == str2[j] ? (1 + process1(str1, str2, i - 1, j - 1)) : 0;
        return Math.max(p1, Math.max(p2, p3));
    }
}
```

#### 动态规划优化

我们可以用一个 m*n 的矩阵来容纳上述问题每个递归子过程的全部结果。比如 `dp[i][j]` 就表示在字符串 1 `char[0~i]` 和字符串 2 `char[0~j]` 范围内最大公共子序列的长度。然后根据递归过程，维护好这个矩阵的数据即可。

优化代码代码如下所示：

```java
static int longestCommonSubsequence2(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    int n = str1.length;
    int m = str2.length;
    int[][] dp = new int[n][m];
    dp[0][0] = str1[0] == str2[0] ? 1 : 0;
    for (int j = 1; j < m; j++) {
        dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
    }
    for (int i = 1; i < n; i++) {
        dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
    }
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            int p1 = dp[i - 1][j];
            int p2 = dp[i][j - 1];
            int p3 = str1[i] == str2[j] ? (1 + dp[i - 1][j - 1]) : 0;
            dp[i][j] = Math.max(p1, Math.max(p2, p3));
        }
    }
    return dp[n - 1][m - 1];
}
```

### 最长回文子序列长度

给定一个字符串 str，返回这个字符串的最长回文子序列长度。比如： str = “a**12**b**3**c**43**def**2**ghi**1**kpm”，最长回文子序列是 1234321 或者 123c321，返回长度 7。

一种解法是将字符串逆序，然后这两个字符串最长公共子序列就是要求字符串的最长回文子序列，这里继续讨论其他方法。

#### 递归尝试

代码如下：

```java
static int longestPalindromeSubsequence(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    return f(str, 0, str.length - 1);
}

/**
  * 在 str[l~r] 范围内讨论最长回文子序列长度
  *
  * @param str 字符串数组
  * @param l   l
  * @param r   r
  * @return 最长回文子序列长度
  */
private static int f(char[] str, int l, int r) {
    if (l == r) {
        return 1;
    }
    if (l == r - 1) {
        return str[l] == str[r] ? 2 : 1;
    }
    // 第一种可能性，回文子序列不以 l 位置字符开头，不以 r 位置字符结尾
    int p1 = f(str, l + 1, r - 1);
    // 第二种可能性，回文子序列以 l 位置字符开头，不以 r 位置字符结尾
    int p2 = f(str, l, r - 1);
    // 第三种可能性，回文子序列不以 l 位置字符开头，以 r 位置字符结尾
    int p3 = f(str, l + 1, r);
    // 第三种可能性，回文子序列以 l 位置字符开头，以 r 位置字符结尾
    int p4 = str[l] != str[r] ? 0 : (2 + f(str, l + 1, r - 1));
    return Math.max(Math.max(p1, p2), Math.max(p3, p4));
}
```

#### 动态规划优化

代码如下所示：

```java
static int longestPalindromeSubsequence(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int n = str.length;
    int[][] dp = new int[n][n];
    dp[n - 1][n - 1] = 1;
    for (int i = 0; i < n - 1; i++) {
        dp[i][i] = 1;
        dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
    }
    for (int l = n - 3; l >= 0; l--) {
        for (int r = l + 2; r < n; r++) {
            int p1 = dp[l + 1][r - 1];
            int p2 = dp[l][r - 1];
            int p3 = dp[l + 1][r];
            int p4 = str[l] != str[r] ? 0 : (2 + dp[l + 1][r - 1]);
            dp[l][r] = Math.max(Math.max(p1, p2), Math.max(p3, p4));
        }
    }
    return dp[0][n - 1];
}
```

我们知道 `dp[l][r]` 位置的数由上述 p1、p2、p3、p4 的四者种的最大值得到，这四个值在矩阵中的分布如下所示：

```
     r-1   r  
l     p2   Y
l+1   p1   p3
```

即 `dp[l][r]` 位置的值是其左边，下变、左下、左下加 2 这 4 这个值的最大值，对于 p2 和 p3 同样是这样，所以  p1<=p2，p1<=p3。

因此在讨论可能性的时候，第一种可能性（p1）可以省略掉，因为其一定不比其他三种可能性的值大。

优化后的代码如下所示：

```java
static int longestPalindromeSubsequence(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int n = str.length;
    int[][] dp = new int[n][n];
    dp[n - 1][n - 1] = 1;
    for (int i = 0; i < n - 1; i++) {
        dp[i][i] = 1;
        dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
    }
    for (int l = n - 3; l >= 0; l--) {
        for (int r = l + 2; r < n; r++) {
            int p2 = dp[l][r - 1];
            int p3 = dp[l + 1][r];
            dp[l][r] = Math.max(p2, p3);
            if (str[l] == str[r]) {
                dp[l][r] = Math.max(dp[l][r], 2 + dp[l + 1][r - 1]);
            }
        }
    }
    return dp[0][n - 1];
}
```

### 象棋跳马问题

问题描述如下：

想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是 (0,0) 位置，那么整个棋盘就是横坐标上 9 条线、纵坐标上 10 条线的区域。给你三个参数 x，y，k，返回马从 (0,0) 位置出发，必须走 k 步，最后落在 (x,y) 上的方法数有多少种？

#### 递归尝试

假设马现在在 (x,y) 处，0<=x<=8，0<=y<=9，这时候其可以去向的位置如下所示：

```
y+2      p8      p1
y+1  p7              p2
y-0          s
y-1  p6              p3         
y-2      p5      p4
    x-2 x-1 x-0 x+1 x+2
```

代码如下：

```java
static int jump(int a, int b, int k) {
    return process(0, 0, a, b, k);
}

/**
  * 当前来到的位置是 (y,x)，还剩下 rest 步需要跳
  * 跳完 rest 步，正好跳到 (a,b) 的方法数是多少
  */
private static int process(int x, int y, int a, int b, int rest) {
    if (x < 0 || x > 8 || y < 0 || y > 9) {
        return 0;
    }
    if (rest == 0) {
        return (a == x && b == y) ? 1 : 0;
    }
    int ways = process(x + 1, y + 2, a, b, rest - 1);
    ways += process(x + 2, y + 1, a, b, rest - 1);
    ways += process(x + 2, y - 1, a, b, rest - 1);
    ways += process(x + 1, y - 2, a, b, rest - 1);
    ways += process(x - 1, y - 2, a, b, rest - 1);
    ways += process(x - 2, y - 1, a, b, rest - 1);
    ways += process(x - 2, y + 1, a, b, rest - 1);
    ways += process(x - 1, y + 2, a, b, rest - 1);
    return ways;
}
```

#### 动态规划优化

递归函数的可变参数有 3 个，因此 dp 表为一个三维数组。

优化代码如下：

```java
static int dp(int a, int b, int k) {
    int[][][] dp = new int[9][10][k + 1];
    dp[a][b][0] = 1;
    for (int rest = 1; rest <= k; rest++) {
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 10; y++) {
                int ways = pick(dp, x + 1, y + 2, rest - 1);
                ways += pick(dp, x + 2, y + 1, rest - 1);
                ways += pick(dp, x + 2, y - 1, rest - 1);
                ways += pick(dp, x + 1, y - 2, rest - 1);
                ways += pick(dp, x - 1, y - 2, rest - 1);
                ways += pick(dp, x - 2, y - 1, rest - 1);
                ways += pick(dp, x - 2, y + 1, rest - 1);
                ways += pick(dp, x - 1, y + 2, rest - 1);
                dp[x][y][rest] = ways;
            }
        }
    }
    return dp[0][0][k];
}

/**
  * 从 dp 表拿去指定位置的数，处理边界问题
  */
private static int pick(int[][][] dp, int x, int y, int rest) {
    if (x < 0 || x > 8 || y < 0 || y > 9) {
        return 0;
    }
    return dp[x][y][rest];
}
```

### 咖啡机

题目描述如下：

给定一个数组 arr，arr[i] 代表第 i 号咖啡机泡一杯咖啡的时间；

给定一个正数 N，表示 N 个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡；

只有一台洗杯子机，一次只能洗一个杯子，时间耗费 a，洗完才能洗下一杯；

每个咖啡杯也可以自己挥发干净，时间耗费 b，咖啡杯可以并行挥发；

假设所有人拿到咖啡之后立刻喝干净，返回所有人去获取咖啡再到全部杯子都变干净的时间。

这个题目可可以拆解为两个部分，第一个部分求最优的排队策略，第二分部分在最优的排队策略下求所有杯子变干净的最小时间。

#### 最优排队策略

使用小根堆模拟派对过程，小根堆中元素为包含咖啡机可用时间和咖啡机泡一杯咖啡需要的时间，小根堆按这两个时间的和排序。

排队过程如下：

每有一个人需要喝咖啡，从小根堆堆弹出和最小的咖啡机使用，使用完毕后更新咖啡机可用时间，放入堆中。

按照同样的逻辑处理下一个人。处理完最后一个人后，我们可以得到一个最优的咖啡机调度序列。

代码如下：

```java
/**
  * 求咖啡机的最优调度策略
  *
  * @param arr 咖啡机泡一杯咖啡需要的时间数组
  * @param n   员工总数
  * @return 在最优调度策略下，员工获取到咖啡时间点数组（递增）
  */
private static int[] bestSchedule(int[] arr, int n) {
    PriorityQueue<Machine> heap = new PriorityQueue<>(new MachineComparator());
    for (int i = 0; i < arr.length; i++) {
        heap.add(new Machine(0, arr[i]));
    }
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        Machine cur = heap.poll();
        cur.timePoint += cur.workTime;
        drinks[i] = cur.timePoint;
        heap.add(cur);
    }
    return drinks;
}

/**
  * 咖啡机
  */
static class Machine {
    /**
      * 咖啡机可用时间点
      */
    public int timePoint;
    /**
      * 咖啡机泡一杯咖啡需要的时间
      */
    public int workTime;

    public Machine(int t, int w) {
        timePoint = t;
        workTime = w;
    }
}

static class MachineComparator implements Comparator<Machine> {

    @Override
    public int compare(Machine o1, Machine o2) {
        return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
    }
}
```

#### 递归尝试

有了这个最优调度序列（每个员工获取到咖啡的时间点数组）后我们就去就全体咖啡杯变干净的最短时间。

递归尝试如下：

```java
static int drinkCoffee2(int[] arr, int n, int wash, int air) {
    if (arr == null || arr.length == 0 || n <= 0) {
        return 0;
    }
    // 获取所有员工从咖啡机获取到咖啡的最优调度策略
    int[] drinks = bestSchedule(arr, n);
    return bestTime(drinks, wash, air, 0, 0);
}

/**
  * 当前来到 i 号员工，考虑其怎么选择才能让全体杯子变干净的时间最短
  *
  * @param drinks 员工获取到咖啡时间数组，题目要求 0 秒喝完咖啡，那么该数组也表示员工开始准备洗杯子的时间数组
  * @param wash   洗杯机洗一杯咖啡需要的时间（串行）
  * @param air    挥发干净时间（并行）
  * @param index  员工序号
  * @param free   洗杯机可用时间点
  * @return 全体杯子变干净的最优时间
  */
private static int bestTime(int[] drinks, int wash, int air, int index, int free) {
    if (index == drinks.length) {
        return 0;
    }
    // 第一种可能性：index 号杯子决定洗
    // 自己杯子变干净的时间
    int selfClean1 = Math.max(drinks[index], free) + wash;
    // 其他杯子变干净的最短时间
    int restClean1 = bestTime(drinks, wash, air, index + 1, selfClean1);
    // 那么全体杯子变干净的时间就是上述的最大值（木桶效应）
    int p1 = Math.max(selfClean1, restClean1);

    // 第二种可能性：index 号杯子决定挥发
    // 自己杯子变干净的时间
    int selfClean2 = drinks[index] + air;
    // 其他杯子变干净的最短时间
    int restClean2 = bestTime(drinks, wash, air, index + 1, free);
    // 那么全体杯子变干净的时间就是上述的最大值（木桶效应）
    int p2 = Math.max(selfClean2, restClean2);

    // 两种可能性的最小值就是要求的杯子变干净的最短时间
    return Math.min(p1, p2);
}
```

#### 动态规划优化

代码如下：

```java
private static int bestTimeDp(int[] drinks, int wash, int air) {
    int N = drinks.length;
    int maxFree = 0;
    for (int i = 0; i < drinks.length; i++) {
        maxFree = Math.max(maxFree, drinks[i]) + wash;
    }
    int[][] dp = new int[N + 1][maxFree + 1];
    for (int index = N - 1; index >= 0; index--) {
        for (int free = 0; free <= maxFree; free++) {
            int selfClean1 = Math.max(drinks[index], free) + wash;
            if (selfClean1 > maxFree) {
                // 因为后面的也都不用填了
                break;
            }
            int restClean1 = dp[index + 1][selfClean1];
            int p1 = Math.max(selfClean1, restClean1);
         
            int selfClean2 = drinks[index] + air;
            int restClean2 = dp[index + 1][free];
            int p2 = Math.max(selfClean2, restClean2);
            dp[index][free] = Math.min(p1, p2);
        }
    }
    return dp[0][0];
}
```

上述动态规划有两个要注意的点：

- 首先 free 的范围我们没有精确值，这时候可以根据业务去找到 free 的上限，以此来构建 dp 表；
- dp 表构建出来后不是所有位置都需要设置值，虽然有的位置被构建出来了，但根据业务实际情况，其永远不会被用到。

### 最小距离累加和

问题描述如下：

给定一个二维数组 matrix，一个人必须从左上角出发，最后到达右下角，沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和。返回最小距离累加和。

#### 动态规划求解

使用 dp 表，代码如下：

```java
static int minPathSum(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;
    int[][] dp = new int[row][col];
    dp[0][0] = m[0][0];
    for (int i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + m[i][0];
    }
    for (int j = 1; j < col; j++) {
        dp[0][j] = dp[0][j - 1] + m[0][j];
    }
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
        }
    }
    return dp[row - 1][col - 1];
}
```

#### 数组压缩

构建 dp 表的过程中我们可以发现，`dp[i][j]` 位置上的数**依赖其上面和左边的数**（第一行只依赖左边的数，第一列只依赖上边的数），因此我们可以使用一个一维数组对 dp 表进行空间优化，代码如下：

```java
static int minPathSum(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;
    int[] dp = new int[col];
    dp[0] = m[0][0];
    for (int j = 1; j < col; j++) {
        dp[j] = dp[j - 1] + m[0][j];
    }
    for (int i = 1; i < row; i++) {
        dp[0] += m[i][0];
        for (int j = 1; j < col; j++) {
            dp[j] = Math.min(dp[j - 1], dp[j]) + m[i][j];
        }
    }
    return dp[col - 1];
}
```

### 货币组成金额

问题描述如下：

arr 是货币数组，其中的值都是正数，代表货币的面值。再给定一个正数 aim，表示需要的金额。**每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的**。从货币数组中选择货币（每个货币只能选择一次），返回组成 aim 的方法数。
例如：arr = [1,1,1]，aim = 2
第 0 个和第 1 个能组成 2，第 1 个和第 2 个能组成 2，第 0 个和第 2 个能组成 2，一共就 3 种方法，所以返回 3。

这是一个从左往右尝试模型。

#### 递归尝试

递归尝试如下：

```java
static int coinWays(int[] arr, int aim) {
    return process(arr, 0, aim);
}

/**
  * index 位置往后正好 rest 这么多的钱，有几种方法，往前不考虑
  */
private static int process(int[] arr, int index, int rest) {
    if (rest < 0) {
        // rest <0 一路递归到这里的方法无效，返回 0，不参与方法数计数
        return 0;
    }
    if (index == arr.length) {
        return rest == 0 ? 1 : 0;
    } else {
        return process(arr, index + 1, rest) + process(arr, index + 1, rest - arr[index]);
    }
}
```

#### 动态规划优化

动态规划优化代码如下：

```java
static int dp(int[] arr, int aim) {
    if (aim == 0) {
        return 1;
    }
    int n = arr.length;
    int[][] dp = new int[n + 1][aim + 1];
    dp[n][0] = 1;
    for (int index = n - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            dp[index][rest] = dp[index + 1][rest] + (rest - arr[index] >= 0 ? dp[index + 1][rest - arr[index]] : 0);
        }
    }
    return dp[0][aim];
}
```

### 面值组成金额

arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。每个值都认为是一种面值，且认为张数是无限的。返回组成 aim 的方法数。
例如：arr = {1,2}，aim = 4

方法如下：1+1+1+1、1+1+2、2+2，一共就 3 种方法，所以返回 3。

#### 递归尝试

递归尝试：

```java
static int coinsWay(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    return process(arr, 0, aim);
}

/**
  * arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好 rest 这么多钱，方法数多少？
  */
private static int process(int[] arr, int index, int rest) {
    if (index == arr.length) {
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
        ways += process(arr, index + 1, rest - (zhang * arr[index]));
    }
    return ways;
}
```

#### 动态规划优化

动态规划优化：

```java
static int dp1(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    int n = arr.length;
    int[][] dp = new int[n + 1][aim + 1];
    dp[n][0] = 1;
    // 从下一行往上一行构建
    for (int index = n - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int ways = 0;
            for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                ways += dp[index + 1][rest - (zhang * arr[index])];
            }
            dp[index][rest] = ways;
        }
    }
    return dp[0][aim];
}
```

#### 去除枚举行为

每一个格子由枚举行为得到，通过观察 dp 表的构建方式（给定几个样本值，推一边 dp 表的构建方式），发现可以继续优化，枚举行为可以被某种计算替代：

```java
static int dp2(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    int n = arr.length;
    int[][] dp = new int[n + 1][aim + 1];
    dp[n][0] = 1;
    for (int index = n - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            // 通过观察 dp 的构建行为得到
            dp[index][rest] = dp[index + 1][rest];
            if (rest - arr[index] >= 0) {
                dp[index][rest] += dp[index][rest - arr[index]];
            }
        }
    }
    return dp[0][aim];
}
```

### 有限张面值货币组成金额

arr 是货币数组，其中的值都是正数，再给定一个正数 aim。**每个值都认为是一张货币，认为值相同的货币没有任何不同**。返回组成 aim 的方法数。
例如：arr = {1,2,1,1,2,1,2}，aim = 4。

方法：1+1+1+1、1+1+2、2+2，一共就 3 种方法，所以返回 3。

这个题和上个题类似，只不过上个题每个面值可以拿任意张货币，而这个题目规定了某种面值货币的张数。

#### 递归尝试

尝试递归如下：

```java
static int coinsWay(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    // 获取货币数组中相同面值的货币出现的次数
    Info info = getInfo(arr);
    return process(info.coins, info.zhangs, 0, aim);
}

// coins 面值数组，正数且去重
// zhangs 每种面值对应的张数
private static int process(int[] coins, int[] zhangs, int index, int rest) {
    if (index == coins.length) {
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    for (int zhang = 0; zhang * coins[index] <= rest && zhang <= zhangs[index]; zhang++) {
        ways += process(coins, zhangs, index + 1, rest - (zhang * coins[index]));
    }
    return ways;
}
```

#### 动态规划优化

动态规划优化：

```java
static int dp1(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    int[] coins = info.coins;
    int[] zhangs = info.zhangs;
    int N = coins.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int ways = 0;
            for (int zhang = 0; zhang * coins[index] <= rest && zhang <= zhangs[index]; zhang++) {
                ways += dp[index + 1][rest - (zhang * coins[index])];
            }
            dp[index][rest] = ways;
        }
    }
    return dp[0][aim];
}
```

#### 去除枚举行为

枚举行为优化：

```java
static int dp2(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    int[] coins = info.coins;
    int[] zhangs = info.zhangs;
    int N = coins.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            dp[index][rest] = dp[index + 1][rest];
            if (rest - coins[index] >= 0) {
                dp[index][rest] += dp[index][rest - coins[index]];
            }
            if (rest - coins[index] * (zhangs[index] + 1) >= 0) {
                dp[index][rest] -= dp[index + 1][rest - coins[index] * (zhangs[index] + 1)];
            }
        }
    }
    return dp[0][aim];
}
```

### Bob 生存问题

题目描述如下：

给定 5 个参数：n, m, row, col, k。
表示在给定的 `n*m` 的区域上，醉汉 Bob 初始在 (row,col) 位置，Bob 一共要迈出 k 步，且每步都会等概率向上下左右四个方向走一个单位。任何时候 Bob 只要离开 `n*m` 的区域，就直接死亡。返回 k 步之后，Bob 还在 `n*m` 的区域的概率。

#### 递归尝试

递归尝试如下：

```java
static double livePossibility(int row, int col, int k, int n, int m) {
    // 生存概率 = 生存下来的走法 / 总的走法（不考虑范围）
    return (double) process(row, col, k, n, m) / Math.pow(4, k);
}

/**
  * 尝试递归
  * 目前在 (row,col) 位置，还有 rest 步要走，走完了如果还在棋盘中就获得 1 次生存走法，返回总的生存点数
  */
private static long process(int row, int col, int rest, int n, int m) {
    // 超出区域
    if (row < 0 || row == n || col < 0 || col == m) {
        return 0;
    }
    // 还在棋盘中
    if (rest == 0) {
        return 1;
    }
    // 还在棋盘中，还有步数要走
    long up = process(row - 1, col, rest - 1, n, m);
    long down = process(row + 1, col, rest - 1, n, m);
    long left = process(row, col - 1, rest - 1, n, m);
    long right = process(row, col + 1, rest - 1, n, m);
    return up + down + left + right;
}
```

#### 动态规划优化

动态规划优化：

```java
private static double dp(int row, int col, int k, int n, int m) {
    long[][][] dp = new long[n][m][k + 1];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            dp[i][j][0] = 1;
        }
    }
    for (int rest = 1; rest <= k; rest++) {
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < m; c++) {
                dp[r][c][rest] = pick(dp, n, m, r - 1, c, rest - 1);
                dp[r][c][rest] += pick(dp, n, m, r + 1, c, rest - 1);
                dp[r][c][rest] += pick(dp, n, m, r, c - 1, rest - 1);
                dp[r][c][rest] += pick(dp, n, m, r, c + 1, rest - 1);
            }
        }
    }
    return (double) dp[row][col][k] / Math.pow(4, k);
}

/**
  * 从 dp 表获取数据，并进行越界判断
  */
private static long pick(long[][][] dp, int n, int m, int r, int c, int rest) {
    if (r < 0 || r == n || c < 0 || c == m) {
        return 0;
    }
    return dp[r][c][rest];
}
```

### 打怪兽问题

题目描述如下：

给定 3 个参数，N、M、K，怪兽有 N 滴血，等着英雄来砍自己，英雄每一次打击，都会让怪兽流失 [0~M] 的血量。到底流失多少？每一次在 [0~M] 上等概率的获得一个值。求 K 次打击之后，英雄把怪兽砍死的概率（中途砍死也算砍死）。

#### 递归尝试

递归尝试如下：

```java
/**
  * 求砍死怪物，递归尝试
  *
  * @param hp     怪兽的血量
  * @param attack 随机伤害的范围为 0~attack
  * @param times  打击次数
  * @return 砍死怪物的概率
  */
static double kill(int hp, int attack, int times) {
    if (hp < 1 || attack < 1 || times < 1) {
        return 0;
    }
 	long all = (long) Math.pow(attack + 1, times);
    long kill = process(hp, attack, times);
    return ((double) kill / (double) all);
}

/**
  * 讨论怪兽还剩 hp 点血，还剩 times 次打击次数时，击杀怪物情况有多少种
  *
  * @param hp     怪兽还剩 hp 点血
  * @param attack 每次的伤害在 [0~attack] 范围上
  * @param times  还有 times 次可以砍
  * @return 击杀怪物情况数
  */
private static long process(int hp, int attack, int times) {
    if (times == 0) {
        return hp <= 0 ? 1 : 0;
    }
    // hp 小于等于 0 后，可以根据打击次数直接计算出击杀情况数量
    if (hp <= 0) {
        return (long) Math.pow(attack + 1, times);
    }
    long ways = 0;
    for (int i = 0; i <= attack; i++) {
        ways += process(hp - i, attack, times - 1);
    }
    return ways;
}
```

#### 动态规划优化

动态规划优化，由构建 dp 表推出剪枝策略，反过来优化递归尝试。

```java
/**
  * 动态规划优化
  *
  * @param totalHp    怪物总血量
  * @param attack     每次的伤害在 [0~attack] 范围上
  * @param totalTimes 攻击次数
  * @return 击杀怪物概率
  */
static double dp1(int totalHp, int attack, int totalTimes) {
    if (totalHp < 1 || attack < 1 || totalTimes < 1) {
        return 0;
    }
    long all = (long) Math.pow(attack + 1, totalTimes);
    long[][] dp = new long[totalTimes + 1][totalHp + 1];
    dp[0][0] = 1;
    for (int times = 1; times <= totalTimes; times++) {
        dp[times][0] = (long) Math.pow(attack + 1, times);
        for (int hp = 1; hp <= totalHp; hp++) {
            long ways = 0;
            for (int i = 0; i <= attack; i++) {
                if (hp - i >= 0) {
                    ways += dp[times - 1][hp - i];
                } else {
                    ways += (long) Math.pow(attack + 1, times - 1);
                }
            }
            dp[times][hp] = ways;
        }
    }
    long kill = dp[totalTimes][totalHp];
    return ((double) kill / (double) all);
}
```

#### 去除枚举行为

去除枚举行为：

```java
/**
  * 去迭代行为优化
  *
  * @param totalHp    怪物总血量
  * @param attack     每次的伤害在 [0~attack] 范围上
  * @param totalTimes 攻击次数
  * @return 击杀怪物概率
  */
static double dp2(int totalHp, int attack, int totalTimes) {
    if (totalHp < 1 || attack < 1 || totalTimes < 1) {
        return 0;
    }
    long all = (long) Math.pow(attack + 1, totalTimes);
    long[][] dp = new long[totalTimes + 1][totalHp + 1];
    dp[0][0] = 1;
    for (int times = 1; times <= totalTimes; times++) {
        dp[times][0] = (long) Math.pow(attack + 1, times);
        for (int hp = 1; hp <= totalHp; hp++) {
            dp[times][hp] = dp[times][hp - 1] + dp[times - 1][hp];
            if (hp - (attack + 1) >= 0) {
                dp[times][hp] -= dp[times - 1][hp - (attack + 1)];
            } else {
                dp[times][hp] -= Math.pow(attack + 1, times - 1);
            }
        }
    }
    long kill = dp[totalTimes][totalHp];
    return ((double) kill / (double) all);
}
```

### 最少货币数量

arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。每个值都认为是一种面值，且认为张数是无限的。返回组成 aim 的最少货币数量。

比如有 arr=[1,2,5,10]，aim=1000，那么组成 aim 需要最少货币张数为 100（都选 10 面值的货币）。

#### 递归尝试

递归尝试如下：

```java
/**
  * 递归尝试
  */
static int minCoins(int[] arr, int aim) {
    if (aim == 0) {
        return 0;
    }
    return process(arr, 0, aim);
}

/**
  * 考虑 index 及之后的面值，每种面值张数自由选择，还剩 rest，返回最小张数
  * 使用 Integer.MAX_VALUE 标记无效值
  */
public static int process(int[] arr, int index, int rest) {
    if (index == arr.length) {
        return rest == 0 ? 0 : Integer.MAX_VALUE;
    } else {
        int ans = Integer.MAX_VALUE;
        for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
            int next = process(arr, index + 1, rest - zhang * arr[index]);
            if (next != Integer.MAX_VALUE) {
                ans = Math.min(ans, zhang + next);
            }
        }
        return ans;
    }
}
```

#### 动态规划优化

动态规划优化：

```java
static int dp(int[] arr, int aim) {
    if (aim == 0) {
        return 0;
    }
    int n = arr.length;
    int[][] dp = new int[n + 1][aim + 1];
    dp[n][0] = 0;
    for (int j = 1; j <= aim; j++) {
        dp[n][j] = Integer.MAX_VALUE;
    }
    for (int index = n - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int ans = Integer.MAX_VALUE;
            for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                int next = dp[index + 1][rest - zhang * arr[index]];
                if (next != Integer.MAX_VALUE) {
                    ans = Math.min(ans, zhang + next);
                }
            }
            dp[index][rest] = ans;
        }
    }
    return dp[0][aim];
}
```

#### 去除迭代行为

去除迭代行为优化（斜率优化）：

```java
static int dp2(int[] arr, int aim) {
    if (aim == 0) {
        return 0;
    }
    int n = arr.length;
    int[][] dp = new int[n + 1][aim + 1];
    dp[n][0] = 0;
    for (int j = 1; j <= aim; j++) {
        dp[n][j] = Integer.MAX_VALUE;
    }
    for (int index = n - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            dp[index][rest] = dp[index + 1][rest];
            if (rest - arr[index] >= 0 && dp[index][rest - arr[index]] != Integer.MAX_VALUE) {
                dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);
            }
        }
    }
    return dp[0][aim];
}
```

### 整数拆分问题

给定一个正数 n，求 n 的裂开方法数，要求后面的数不能比前面的数小，不能拆出 0。
比如 4 的裂开方法有：1+1+1+1、1+1+2、1+3、2+2、4，有 5 种，所以返回 5 。

#### 递归尝试

```java
static int ways(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return process(1, n);
}

/**
  * 考虑某次的拆分状态
  *
  * @param pre  上一个拆出来的数是 pre
  * @param rest 还剩 rest 需要去拆
  * @return 返回拆解的方法数
  */
private static int process(int pre, int rest) {
    if (rest == 0) {
        return 1;
    }
    if (pre > rest) {
        return 0;
    }
    int ways = 0;
    for (int first = pre; first <= rest; first++) {
        ways += process(first, rest - first);
    }
    return ways;
}
```

#### 动态规划优化

```java
static int dp(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    int[][] dp = new int[n + 1][n + 1];
    for (int pre = 1; pre <= n; pre++) {
        dp[pre][0] = 1;
        dp[pre][pre] = 1;
    }
    for (int pre = n - 1; pre >= 1; pre--) {
        for (int rest = pre + 1; rest <= n; rest++) {
            int ways = 0;
            for (int first = pre; first <= rest; first++) {
                ways += dp[first][rest - first];
            }
            dp[pre][rest] = ways;
        }
    }
    return dp[1][n];
}
```

#### 去除迭代行为

通过观察 dp 表的构建方式（代入某个具体的样本去观察），发现迭代行为可以被某种关系的计算行为替代。

```java
static int dp(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    int[][] dp = new int[n + 1][n + 1];
    for (int pre = 1; pre <= n; pre++) {
        dp[pre][0] = 1;
        dp[pre][pre] = 1;
    }
    for (int pre = n - 1; pre >= 1; pre--) {
        for (int rest = pre + 1; rest <= n; rest++) {
            dp[pre][rest] = dp[pre + 1][rest];
            dp[pre][rest] += dp[pre][rest - pre];
        }
    }
    return dp[1][n];
}
```

### 最接近的累加和

给定一个正数数组 arr，请把 arr 中所有的数分成两个集合，尽量让两个集合的累加和接近。

返回：最接近的情况下，较小集合的累加和。

上述问题可以换一个描述，比如我们现在有了数组所有元素的累加总和 sum，那么我们求在 arr 种挑选一些元素使其累加和最接近但不超过 sum/2，此时的累加和就是上述问题所要的答案。

#### 递归尝试

```java
static int sumClosed(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    return process(arr, 0, sum / 2);
}

/**
  * arr[i...] 可以自由选择，请返回累加和尽量接近 rest，但不能超过 rest 的情况下，最近接的累加和
  *
  * @param arr  可选数字数组
  * @param i    选择数字的位置
  * @param rest 靠近值
  * @return 最近接 rest 的累加和（但不超过 rest）
  */
private static int process(int[] arr, int i, int rest) {
    if (i == arr.length) {
        // 没有数选择，返回 0
        return 0;
    } else {
        // 第一种可能性，不选择 i 位置的数
        int p1 = process(arr, i + 1, rest);
        // 第二种可能性，选择 i 位置的数
        int p2 = 0;
        if (arr[i] <= rest) {
            p2 = arr[i] + process(arr, i + 1, rest - arr[i]);
        }
        return Math.max(p1, p2);
    }
}
```

#### 动态规划优化

```java
private static int dp(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    sum /= 2;
    int n = arr.length;
    int[][] dp = new int[n + 1][sum + 1];
    for (int i = n - 1; i >= 0; i--) {
        for (int rest = 0; rest <= sum; rest++) {
            // 第一种可能性，不选择 i 位置的数
            int p1 = dp[i + 1][rest];
            // 第二种可能性，选择 i 位置的数
            int p2 = 0;
            if (arr[i] <= rest) {
                p2 = arr[i] + dp[i + 1][rest - arr[i]];
            }
            dp[i][rest] = Math.max(p1, p2);
        }
    }
    return dp[0][sum];
}
```

### 个数平分下最接近的累加和

给定一个正数数组 arr，请把 arr 中所有的数分成两个集合，如果 arr 长度为偶数，两个集合包含数的个数要一样多，如果 arr 长度为奇数，两个集合包含数的个数必须只差一个。请尽量让两个集合的累加和接近。

返回：最接近的情况下，较小集合的累加和。

#### 递归尝试

```java
static int sumClosedHalfSize(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    if ((arr.length & 1) == 0) { // 数组个数为偶数
        return process(arr, 0, arr.length / 2, sum / 2);
    } else { // 数组个数为奇数
        return Math.max(process(arr, 0, arr.length / 2, sum / 2),
                        process(arr, 0, arr.length / 2 + 1, sum / 2));
    }
}

/**
  * arr[i....]自由选择，挑选的个数一定要是 picks 个，返回离 rest 最近的累加和（不超过 rest）
  *
  * @param arr   样本数组
  * @param i     样本位置
  * @param picks 挑选数量
  * @param rest  基准值
  * @return 离 rest 最近的累加和
  */
private static int process(int[] arr, int i, int picks, int rest) {
    if (i == arr.length) {
        // -1 表示无效值
        return picks == 0 ? 0 : -1;
    } else {
        // 第一种可能，不要 i 位置的数
        int p1 = process(arr, i + 1, picks, rest);
        // 第二种可能，要 i 位置的数
        int p2 = -1;
        int next = -1;
        if (arr[i] <= rest) {
            next = process(arr, i + 1, picks - 1, rest - arr[i]);
        }
        if (next != -1) {
            p2 = arr[i] + next;
        }
        return Math.max(p1, p2);
    }
}
```

#### 动态规划优化

```java
static int dp(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    sum /= 2;
    int n = arr.length;
    int m = (n + 1) / 2;
    int[][][] dp = new int[n + 1][m + 1][sum + 1];
    // 全部初始化为无效值
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= sum; k++) {
                dp[i][j][k] = -1;
            }
        }
    }
    for (int rest = 0; rest <= sum; rest++) {
        dp[n][0][rest] = 0;
    }
    for (int i = n - 1; i >= 0; i--) {
        for (int picks = 0; picks <= m; picks++) {
            for (int rest = 0; rest <= sum; rest++) {
                int p1 = dp[i + 1][picks][rest];
                // 就是要使用arr[i]这个数
                int p2 = -1;
                int next = -1;
                if (picks - 1 >= 0 && arr[i] <= rest) {
                    next = dp[i + 1][picks - 1][rest - arr[i]];
                }
                if (next != -1) {
                    p2 = arr[i] + next;
                }
                dp[i][picks][rest] = Math.max(p1, p2);
            }
        }
    }
    if ((arr.length & 1) == 0) {
        return dp[0][arr.length / 2][sum];
    } else {
        return Math.max(dp[0][arr.length / 2][sum], dp[0][(arr.length / 2) + 1][sum]);
    }
}
```

### N 皇后问题

问题描述如下：

N 皇后问题是指在 N*N 的棋盘上要摆 N 个皇后，要求任何两个皇后不同行、不同列， 也不在同一条斜线上。

给定一个整数 n，返回 n 皇后的摆法有多少种。比如：n=1，返回1；n=2 或 n=3，2 皇后和 3 皇后问题无论怎么摆都不行，返回 0；n=8，返回 92。

递归方案如下：

- 用一个 record 数组记录前 i 行的放置位置，比如 record[i]=j，表示 i 行的皇后放置到了 j 列；
- 考虑当前来到 i 行，依次查看每个列上是否可以放置皇后，如果可以递归去放置 i+1 行的皇后；

代码如下：

```java
static int num(int n) {
    if (n < 1) {
        return 0;
    }
    int[] record = new int[n];
    return process(0, record, n);
}

/**
  * 每一行放一个皇后，当前来到 i 行，一共是 0~n-1 行
  *
  * @param i      当前需要放置皇后的行数
  * @param record 记录 i 皇后之前皇后的放置位置，比如 record[i]=j，就表示 i 行的皇后放到了 j 列上
  * @param n      要放的皇后总数（棋盘的列数）
  * @return N 皇后放置方法数
  */
private static int process(int i, int[] record, int n) {
    if (i == n) {
        // i 来到 n 位置，说明 n 个皇后已经按照规则放置完毕，因此得到一种放置方案
        return 1;
    }
    int res = 0;
    // 考虑皇后在第 i 行，每个列上的放置情况
    for (int j = 0; j < n; j++) {
        if (isValid(record, i, j)) {
            record[i] = j;
            res += process(i + 1, record, n);
        }
    }
    return res;
}

/**
  * 在 i,j 位置放皇后，根据前 i 个放皇后的位置（record 数组）判断当前位置是否合法
  *
  * @param record 以前放皇后的位置，比如 record[i]=j，就表示 i 行的皇后放到了 j 列上
  * @param i      当前皇后放置的行
  * @param j      当前皇后放置的列
  * @return 当前位置是否有效
  */
private static boolean isValid(int[] record, int i, int j) {
    for (int k = 0; k < i; k++) {
        // 由于每行都放一个皇后，这里近判断皇后和之前的皇后是否在同一列或者在同一个对角线即可
        if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {
            return false;
        }
    }
    return true;
}
```

N 皇后问题就没有办法使用动态规划去优化。

N 皇后问题的位运算优化，优化的是常数项时间。

## 总结

### 暴力递归和动态规划的关系

某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划。任何动态规划问题，都一定对应着某一个有重复过程的暴力递归，但不是所有的暴力递归，都一定对应着动态规划。

有重复调用同一个子问题的解，这种递归可以优化，如果每一个子问题都是不同的解，无法优化也不用优化。

解决一个问题，可能有很多尝试方法；可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式；所以一个问题可能有若干种动态规划的解法。

### 递归尝试

#### 递归尝试设计原则

1. 设计递归函数时，每一个可变参数的类型，一定不要比 int 类型更加复杂；
2. 原则 1，可以违反，让类型突破到一维线性结构，那必须是单一可变参数；
3. 如果发现原则 1 被违反，但不违反原则 2，只需要做到记忆化搜索即可，比如贴纸问题；
4. 可变参数的个数，能少则少。

如果设计的暴力递归不符合上述原则，直接推到这种设想，重新设计递归函数。

#### 递归尝试步骤

- 一定要逼自己找到不违反原则情况下的暴力尝试！

- 如果你找到的暴力尝试，不符合原则，马上推到重来！

- 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于 5%！
- 没有设计递归的思路，怎么办？通过 4 中尝试模型去思考，看问题的描述贴近于那种模型，按照模型的套路就能容易的设计出暴力递归。

#### 4 种尝试模型

- 从左往右的尝试模型
- 范围上的尝试模型
- 多样本位置全对应的尝试模型
- 寻找业务限制的尝试模型

### 记忆搜索到动态规划优化

通过例子的形式分析有没有重复过程，如果有就可以使用记忆搜索优化或进行动态规划优化（严格表结构）。

有了递归尝试后，优化步骤：

1. 你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用；
2. 找到哪些参数的变化会影响返回值，对每一个列出变化范围；
3. 参数间的所有的组合数量，意味着表大小；
4. 记忆化搜索的方法就是**傻缓存**，非常容易得到；
5. 规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解；
6. 对于有枚举行为的决策过程，进一步优化（这一步傻缓存做不到）。

### 动态规划的进一步优化

- 空间压缩；

  > 二维数组用一维数组滚动的方式去节约空间。

- 状态化简；

- 四边形不等式；

- 其他优化技巧。

### 动态规划问题解决步骤

1. 设计暴力递归（递归尝试），通过**重要原则**和 **4 种常见尝试模型**去得到好的递归尝试（最关键的一步，没有套路，只有自然智慧）；

2. 分析有没有重复解，指定样本，套递归过程，就可以发现有没有重复解（套路解决）；

3. 用记忆化搜索去掉缓存（傻缓存，没有迭代行为已经是最优解了，有迭代行为还需使用严格表结构去除迭代行为）；

4. 用严格表结构实现动态规划（套路解决）；

   > 记忆化搜索和严格表结构本质上都是构建出 dp 表：
   >
   > - 记忆化搜索是在递归的过程中，边递归，边缓存每一个过程的结果，递归行为执行完毕，dp 缓存表构建完毕；
   >
   > - 严格表则是根据完全根据递归函数直接构建 dp 表，步骤如下：
   >
   >   - 根据递归尝试函数的可变参数，确认 dp 表的维度和容量；
   >
   >   - 根据递归尝试的边界条件初始化 dp 表中对于位置的值；
   >
   >   - 根据递归的行为可分析出 dp 表构建时的依赖关系，根据递归逻辑进一步设置 dp 其他位置的值； 

5. 看看能否继续优化，比如优化迭代行为等（套路解决）。
