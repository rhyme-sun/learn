# 第一阶段

## 总览

复杂度分析，线性表，简单的排序算法和查找算法。

## 数据结构和算法

从广义上来讲，数据结构是指一组数据的存储结构，算法就是操作数据的一组方法。数据结构和算法相辅相成，数据结构服务于算法，算法也要作用在合适的数据结构合适的数据结构之上。

## 复杂度分析 *

### 大 O 复杂度表示法

我们用 T(n) 表示一段程序执行耗时时间，使用 f(n) 表示程序的代码运行次数，t 表示代码每次运行耗时，那么 T(n) = t* f(n)，time 固定时，我们很容易得出 T(n) 于 f(n) 成正比，这个关系大 O 法表示就为 T(n) = O(f(n)，这里的 O 是一个符号，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。大 O 复杂度表示法并不表示代码的真正执行时间，而表示代码执行时间随着数据规模增长的变化趋势，叫做渐进时间复杂度（），简称时间复杂度。

```
Note:
数学分析中的大 O 小 o？
// TODO ...
```

### 时间复杂度分析

- 只关注单次循环执行最多的一段代码：大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。
- 加法法则：总复杂度等于量级最大的那段代码的复杂度。
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

### 时间复杂度

- 常量阶 `O(1) `：只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 `O(1)`。

- 对数阶 `O(logn)`

  ```
  i=1; 
  while (i <= n) 
  { 
  	i = i * 2; 
  }
  ```

- 线性阶 `O(n) O(m + n)`

- 线性对数阶 `O(nlogn)`

- 乘方阶 `O(n^2) ... O(n^k) O(m + n)`

- 指数阶 `O(2^n)`

- 阶乘阶 `O(n!)`

### 最好情况时间复杂度

在最理想的情况下，执行这段代码的时间复杂度。

### 最坏情况时间复杂度

在最糟糕的情况下，执行这段代码的时间复杂度。

### 平均情况时间复杂度

O（每次出现概率 * 次数 / 运行次数 ）= 加权平均时间复杂度

### 均摊时间复杂度

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)，这就是均摊分析的大致思路。

## 数组、栈、队列 *

### 数组

- 数组是一种线性数据结构，它用一组连续的内存空间来存储一组相同类型的数据。

- 随机访问：数组的随机访问特性得益于连续其是使用连续的一组空间存储数据的，且数组存储每个元素的空间长度是相等的，这样当我们使用元素下标访问数组元素的时候，使用以下公式就可以计算出指定元素的内存位置，`a[i]_address = base_address + i * data_type_size`。其中 `base_address` 是数组首元素的地址，`data_type_size` 是每个数组每个元素占用空间的长度。连续空间虽然实现了可以以 O(1) 的时间复杂度随机访问数组内的元素，但为了维护这种连续性，必须在插入或删除数据时进行大量数据的移动（数组尾部除外）工作。

- 数组插入删除的优化：优化的核心思路是避免或减少元素的移动次数。
  - 插入优化
    - 插入元素放到末尾。
    - 插入的元素不在末尾时，条件允许下可以将插入位置上原来的元素移动至末尾，再将元素放入指定位置。
    - 同时插入多个元素，将每个元素移动次数由多次降至 1 次。
  - 删除优化
    - 删除末尾元素
    - 插入的元素不在末尾时，条件允许下可以将末尾元素移动至删除位置。
    - 同时删除多个元素，将每个元素移动次数由多次降至 1 次。
- 要注意数组越界问题。

```
Note:
为什么数组是从 0 开始编号，而不是从 1 开始编号？
根据数组元素位置计算公式 a[i]_address = base_address + i * data_type_size，若数组元素是从 1 开始的，那么计算公式应该变成这样 a[i]_address = base_address + (i - 1) * data_type_size，多了一个减 1 操作，对 CPU 来说就每次获取数据都多运行了一次减法操作。

数组查找一个元素的时间复杂度？
我们知道使用数组元素下标访问元素的时间复杂度为 O(1)，但这不能代表着查找数组里的元素的时间复杂度，就查找数组元素而言，即便是排好序的数组，使用二分法查找的时间复杂度也为 O(logn)，所以不能说数组查找一个元素的时间复杂度为 O(1)。
```

### 栈

- 栈是一种受限的线性表，只允许在一端插入和删除数据，具有先入后出的特点。
- 顺序栈和链式栈
  - 顺序栈：用数组实现，使用 Java 代码简单实现如下：
  - 链式栈：用链表实现，使用 Java 代码简单实现如下：
- 栈的应用场景
  - 栈在函数调用过程中的应用
  - 栈在表达式求值中的应用
  - 栈在括号匹配中的应用

### 队列

- 队列是一种受限的线性表，只允许在一端插入数据和在另一端删除数据，具有先入先出的特点。
- 顺序队列和链式队列
  - 顺序队列：用数组实现
  - 链式队列：用链表实现
  - 循环队列

## 链表 *



## 递归 *

## 排序、二分查找

## 总结

### 参考链接