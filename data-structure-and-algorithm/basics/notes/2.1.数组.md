# 数组

数组（Array）是一种**线性表**数据结构，其用一组连续的内存空间，来存储一组相同类型的数据。

## 线性表

线性表就是数据排成像一条线一样的结构，线性表中的数据最多只有前和后两个方向，除了数组之外，常见的线性表结构还有链表、队列和栈。

与线性表相对的是非线性表，比如树和图，非线性表中的数据不再只是简单的前后关系，数据之间的组织方向可能有多个（大于 2）。

## 随机访问

数据用一组连续的存储空间来存放一组相同类型的数据这一性质，使得数组具有随机访问的特性，详细来讲可以利用数组下标，在 `O(1)` 的时间复杂度内，随机访问到数组中的某个元素。

数组中某个元素存储首地址计算公式为：

```
a[i]_address = base_address + i * data_type_size
```

- i 表示数组元素下标，从 0 开始；
- `a[i]_address` 表示数组 i 为值元素的首地址；

- `base_address` 表示数组的起始地址，也是第一个元素的首地址；
- `data_type_size` 表示数组中每个元素的大小。



> 为什么数组的下标从 0 开始，而不是从 1 开始？
>
> 如果数组下标从 1 开始，那么数组中某个元素首地址的计算公式就为：
>
> ```
> a[i]_address = base_address + (i -1) * data_type_size
> ```
>
> 相比于从 0 开始的计算公式，每次寻址时都会多一个减一操作。



> 数组适合查找，查找时间复杂度为 `O(1)`，这个说法不准确，即便是排好序的数组，你用二分查找，时间复杂度也是 `O(logn)`。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 `O(1)`。

## 数组的插入和删除

随机访问可以是数组这个数据结构的”大杀器“，但维护这种特性是由代价的，代价就是为了维护好内存数据的连续性，在数组新增或删除元素是可能会伴随着大量数据的移动操作。

### 插入

比如在数组第 k 个位置插入了一个元素，原来 k 位置及其后面的元素都需向后移动一位，这样一来插入的时间复杂度就为 `O(n)`。

如果数组中的元素是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据；但是如果数组只是被当作一个存储数据的容器，内部数据没有顺序要求，在插入数据时，可以将直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置，这样就避免了数据的搬移。

### 删除

跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，需要将 k 之后的数据向前移动一位，这样一来删除数据元素的复杂度为 `O(n)`。

如果不需要保证数组中元素的顺序，删除数据时可以将数组末尾的元素替换删除的位置，这样就避免了数据搬移；

此外如果我们需要依次删除数组中 k、k+1、k+2 除的元素，为了保证内存连续性，每一次删除都会伴随着后面元素向前移动一位，数据就会被搬移三次，如果每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除，当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

## 容器

针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector<，相对于数组，容器有以下优点：

- 将数组的一些操作细节封装起来，我们在使用的时候会更加方便，比如前面提到的数组插入、删除数据时需要搬移其他数据等；

- 容器一般都支持动态扩容，比如 Java 中的 ArrayList 每次扩容到原来容量的 1.5 倍大小。

  > 注意：数组扩容涉及到内存的申请和数据的搬移，是比较耗时的，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。

## 总结

以上笔记来自：[05 | 数组：为什么很多编程语言中数组都从0开始编号？ (geekbang.org)](https://time.geekbang.org/column/article/40961)

