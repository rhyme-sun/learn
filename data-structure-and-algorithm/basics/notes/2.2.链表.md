# 链表

链表也是一种常用的线性表结构，比如 LRU 缓存淘汰算法就使用到了链表结构。链表通过指针将一组零散的内存块连接到一起，我们把这里的内存块成为链表的**节点**，节点里除了存储数据以外，还存储了指向下个节点或上个节点的指针。

## 单链表

对于单链表来讲，链表的每个节点存储了指向下个节点的指针 next，链表的首个节点（头节点）没有其他节点指向，其记录了链表的起始地址，链表的最后一个节点（尾节点）指向 null。

和数组一样，链表也支持增删查操作，链表的新增和删除只需要修改节点指针的指向即可，不用搬运数据，时间复杂度为 `O(1)`；链表的随机访问不能像数组那样通过下标来计算，而是需要从头节点开始遍历，时间复杂度为 `O(n)`。

单链表代码如下所示：

```java
public class SinglyLinkedList {

    /**
     * 头节点
     */
    private Node first;
    /**
     * 尾节点
     */
    private Node last;

    private int size;

    public SinglyLinkedList() {
    }

    public int size() {
        return size;
    }

    /**
     * 增加元素到链表尾部
     *
     * @param e e
     */
    public void add(int e) {
        final Node node = new Node(e);
        if (Objects.isNull(first)) {
            first = node;
            last = first;
        } else {
            last.next = node;
            last = node;
        }
        size++;
    }

    /**
     * 在链表指定位置出增加元素
     *
     * @param index index
     * @param e     e
     */
    public void set(int index, int e) {
        final Node newNode = new Node(e);
        if (index == 0) {
            newNode.next = first;
            first = newNode;
            size++;
            return;
        }

        final Node prev = node(index - 1);
        newNode.next = prev.next;
        prev.next = newNode;

        if (index == size) {
            last = newNode;
        }
        size++;
    }

    /**
     * 删除链表中指定元素的数据
     *
     * @param index index
     */
    public void remove(int index) {
        if (index == 0) {
            first = first.next;
            size--;
            return;
        }
        final Node prevNode = node(index - 1);
        if (index == size - 1) {
            prevNode.next = null;
            size--;
            last = prevNode;
            return;
        }
        final Node node = node(index);
        prevNode.next = node.next;
        size--;
    }

    /**
     * 删除第一个值等于给定值的节点
     *
     * @param e e
     */
    public void removeElement(int e) {
        Node prev = first;
        Node x = first;
        for (int i = 0; i < size; i++) {
            if (e == x.value) {
                prev.next = x.next;
                if (i == 0) {
                    first = prev.next;
                }
                if (i == size - 1) {
                    last = prev;
                }
                size--;
                break;
            }
            prev = x;
            x = x.next;
        }
    }

    /**
     * 获取指定位置的值
     *
     * @param index index
     * @return value
     */
    public int get(int index) {
        final Node node = node(index);
        return node.value;
    }

    /**
     * 返回指定位置的节点
     *
     * @param index index
     * @return Node
     */
    private Node node(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        Node x = first;
        for (int i = 0; i < index; i++) {
            x = x.next;
        }
        return x;
    }

    /**
     * 链表翻转
     */
    public void reverse() {
        Node prev = null;
        Node head = first;
        last = first;

        while (head != null) {
            Node next = head.next;
            head.next = prev;
            first = head;

            prev = head;
            head = next;
        }
    }

    /**
     * 单链表节点对象
     */
    private static class Node {

        public int value;

        public Node next;

        Node(int data) {
            value = data;
        }
    }
}
```

## 循环单链表

循环单链表是一种特殊的单链表，它和单链表的区别是循环链表的尾节点会指向头节点。

## 双链表

单向链表只有一个方向，节点只有一个后继指针 next 指向后面的节点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

对于单链表，双链表在某些情况下的删除和插入效率要更高。

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

- 删除结点中“值等于某个给定值”的结点；
- 删除给定指针指向的结点。

如果是删除值等于某个指定值的节点，单链表和双链表都先需要从头节点开始遍历，找到值等于给定值的节点，然后删除，整体的时间复杂度为 `O(n)`；如果是删除某个指针指向的节点，由于单链表的节点不知道谁指向它，所以还需要从头遍历找到待删除节点的前置节点，而双链表每个节点都存放了指向前后节点的指针，可以进行删除操作。

对于链表的插入操作，如果是在某个节点后新增一个节点，单链表会很方便，单如果需要在某个节点前新增一个节点，则还需要找到该节点的前置节点，而双链表就不存在这样的问题。

双链表代码如下所示：

```java
public class DoubleLinkedList {

    /**
     * 头节点
     */
    private DoubleNode first;
    /**
     * 尾节点
     */
    private DoubleNode last;
    /**
     * 元素个数
     */
    private int size;

    public int size() {
        return size;
    }

    /**
     * 在链表末尾添加元素
     *
     * @param e e
     */
    public void add(int e) {
        DoubleNode newNode = new DoubleNode(e);
        if (Objects.isNull(first)) {
            first = newNode;
        } else {
            last.next = newNode;
            newNode.prev = last;
        }
        last = newNode;
        size++;
    }

    /**
     * 在链表指定位置添加元素
     *
     * @param index index
     * @param e     e
     */
    public void set(int index, int e) {
        final DoubleNode newNode = new DoubleNode(e);
        if (index == 0) {
            newNode.next = first;
            first.prev = newNode;
            size++;

            first = newNode;
            return;
        }
        if (index == size) {
            last.next = newNode;
            newNode.prev = last;
            size++;

            last = newNode;
            return;
        }

        final DoubleNode node = node(index);
        newNode.next = node;
        newNode.prev = node.prev;

        node.prev.next = newNode;
        node.prev = newNode;
        size++;
    }

    /**
     * 删除指定位置的元素
     *
     * @param index index
     */
    public void remove(int index) {
        if (index == 0) {
            if (size == 1) {
                first = null;
                last = null;
            } else {
                first.next.prev = null;
                first = first.next;
            }
            size--;
            return;
        }
        if (index == size - 1) {
            if (size == 1) {
                first = null;
                last = null;
            } else {
                last.prev.next = null;
                last = last.prev;
            }
            size--;
            return;
        }

        final DoubleNode node = node(index);
        node.prev.next = node.next;
        node.next.prev = node.prev;
        size--;
    }

    /**
     * 删除第一个值等于给定值的节点
     *
     * @param e e
     */
    public void removeElement(int e) {
        DoubleNode node = first;
        for (int i = 0; i < size; i++) {
            if (e == node.value) {
                if (node == first) {
                    if (size == 1) {
                        first = null;
                        last = null;
                    } else {
                        first.next.prev = null;
                        first = first.next;
                    }
                } else if (node == last) {
                    if (size == 1) {
                        first = null;
                        last = null;
                    } else {
                        last.prev.next = null;
                        last = last.prev;
                    }
                } else {
                    node.prev.next = node.next;
                    node.next.prev = node.prev;
                }
                size--;
                break;
            }
            node = node.next;
        }
    }

    /**
     * 获取指定位置元素
     *
     * @param index index
     * @return 元素值
     */
    public int get(int index) {
        DoubleNode node = node(index);
        return node.value;
    }

    /**
     * 获取指定位置的节点对象
     *
     * @param index index
     * @return 节点对象
     */
    private DoubleNode node(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        DoubleNode node;
        if (index < (size >> 2)) {
            node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
        } else {
            node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
        }
        return node;
    }

    /**
     * 链表翻转
     */
    public void reverse() {
        DoubleNode prev = null;
        DoubleNode head = first;
        while(head != null) {
            DoubleNode next = head.next;
            head.next = prev;
            head.prev = next;

            prev = head;
            head = next;
        }

        DoubleNode temp = first;
        first = last;
        last = temp;
    }

    /**
     * 双链表节点对象
     */
    private static class DoubleNode {
        public int value;
        public DoubleNode prev;
        public DoubleNode next;

        public DoubleNode(int data) {
            value = data;
        }
    }
}
```

## 循环双链表

循环双链表和双链表相比，其头节点的 prev 指针会指向尾节点，尾节点的 next 指针会指向头节点。

## 数组和链表

数组和链表虽然都是线性表，但却有着两种截然不同的内存组织方式，从而导致它们在存储和读取数据上有着不同的表现。其中数组的随机访问的时间复杂度为 `O(1)`，新增和删除的时间复杂度为 `O(n)`，链表则相反，随机访问的时间复杂度为 `O(n)`，插入删除的时间复杂度为 `O(1)`。不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。



数组需要一组连续的内存，这样根据数据的空间局部性原理，CPU 可以对数组中的数据进行预读到缓存，提高数据访问效率，而链表由于数组在内存中的分布是分散的，没有办法进行预读。

数组有一个缺点是不利于扩容，每次扩容都需要额外申请更多的连续内存，再进行数据的拷贝，而链表本身没有大小限制，天然支持动态扩容，但由于链表的内存分散，在数据被回收时容易造成内存碎片。

## 总结

- 以上笔记总结自：[06 | 链表（上）：如何实现LRU缓存淘汰算法? (geekbang.org)](https://time.geekbang.org/column/article/41013)

