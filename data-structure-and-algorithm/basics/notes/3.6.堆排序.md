# 堆排序

堆排序。

## 堆结构

**二叉树**：每个结点至多拥有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。

**完全二叉树**：要么这一层是满的，要么这一层在从左往右变满的状态，这样的二叉树叫做完全二叉树。

堆从结构上来讲是一种完全二叉树结构，分为大根堆和小根堆：

- 大根堆：根节点比子节点数值大；
- 小根堆：根节点比子节点数值小。

我们可以使用数组来模拟堆结构，则对于数组元素下标为 i 的元素，其左子节点位置为 `2*i+1`，右子节点下标为 `2*i+2`，根节点元素下标为 `(i-1)/2`，代码如下所示（大根堆）：

```java
public class MaxHeap {

    private int[] heap;
    private final int limit;
    private int heapSize;

    public MaxHeap(int limit) {
        heap = new int[limit];
        this.limit = limit;
        heapSize = 0;
    }

    public boolean isEmpty() {
        return heapSize == 0;
    }

    public boolean isFull() {
        return heapSize == limit;
    }

    public void push(int value) {
        if (heapSize == limit) {
            throw new RuntimeException("heap is full");
        }
        heap[heapSize] = value;
        heapInsert(heap, heapSize++);
    }

    private void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    /**
      * 返回最大值，并且在大根堆中，把最大值删掉。
      */
    public int pop() {
        int ans = heap[0];
        swap(heap, 0, --heapSize);
        heapify(heap, 0, heapSize);
        return ans;
    }

    private void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 左右两个孩子中，谁大，谁把自己的下标给 largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 根节点和值最大孩子节点比较，值大的下标给 largest
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

## 堆排序

堆排序的过程如下：

- 先让整个数组都变成大根堆结构，建立堆，则堆顶的元素就为数组中的最大值，构建堆有两组方式：

  - 从上到下构建堆，即从最顶层的根节点开始构建堆，时间复杂度为 `O(N*logN)`；

  - 从下到上调整堆，即从最底层的子节点开始调整堆，时间复杂度为 `O(N)` 。

- 然后把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆成为大根堆，一直周而复始，时间复杂度为 `O(N*logN)`；
- 堆的大小减小成 0 之后，排序完成。 

代码如下所示：

```java
public class HeapSort {

    /**
     * 堆排序
     */
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 将数组变成大根堆结构
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }
        // 将堆顶和堆尾元素交换（即最大元素放到了数组末尾），让除去堆尾元素的部分再成为一个大根堆
        int heapSize = arr.length;
        while (heapSize > 0) {
            swap(arr, 0, --heapSize);
            heapify(arr, 0, heapSize);
        }
    }

    private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 左右两个孩子中，谁大，谁把自己的下标给 largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 根节点和值最大孩子节点比较，值大的下标给 largest
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

堆排序优化，将一个数组变成大根堆时，上述方法的时间复杂度为 `O(N*logN)`，可以使用下面方法优化为 `O(N)`：

```java
public class HeapSort {

    /**
     * 堆排序优化
     */
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 将数组变成大根堆结构
        for (int i = arr.length - 1; i >= 0; i--) {
            heapify(arr, i, arr.length);
        }
        // 将堆顶和堆尾元素交换（即最大元素放到了数组末尾），令除去堆尾元素的部分再成为一个大根堆
        int heapSize = arr.length;
        while (heapSize > 0) {
            swap(arr, 0, --heapSize);
            heapify(arr, 0, heapSize);
        }
    }

    private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 左右两个孩子中，谁大，谁把自己的下标给 largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 根节点和值最大孩子节点比较，值大的下标给 largest
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

## 堆的应用

堆的应用

### 几乎有序数组排序

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过 k，并且 k 相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序，过程如下：

- 对于几乎有序数组，可以使用堆进行排序，先将前 k 个数放到小根堆中，那么这 k 中的最小值就为整个数组的最小值，因为超过这个范围的数移动次数一定大于或等于 k，不满足要求；
- 然后将弹出堆顶元素；
- 接着将第 k+1 个放入堆中，继续弹出堆顶元素；
- 依次类推，直到堆中元素全部弹出。

代码如下所示：

```java
public class SortArrayDistanceLessK {

	 static void sortedArrDistanceLessK(int[] arr, int k) {
		if (k == 0) {
			return;
		}
		// JDK 中的堆结构，默认为小根堆
		PriorityQueue<Integer> heap = new PriorityQueue<>();
		int index = 0;
		// 将前 k 个数放入数组
		for (; index <= Math.min(arr.length - 1, k - 1); index++) {
			heap.add(arr[index]);
		}
		// 从第 k+1 个数开始，每 k 个数弹出堆顶元素，由于数组几乎有序，所以堆顶元素就是数组中的最小值
		int i = 0;
		for (; index < arr.length; i++, index++) {
			heap.add(arr[index]);
			arr[i] = heap.poll();
		}
		while (!heap.isEmpty()) {
			arr[i++] = heap.poll();
		}
	}
}
```

