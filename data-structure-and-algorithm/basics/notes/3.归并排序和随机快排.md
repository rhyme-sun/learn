# 归并排序和随机快排

## 归并排序

### 归并排序实现

左边排好序，右边排好序，最后通过 merge 让整体有序，总体来说是个递归行为，代码如下所示：

```java
public class MergeSort {

    /**
     * 递归实现
     */
    public static void mergeSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    private static void process(int[] arr, int l, int r) {
        if (r == l) {
            return;
        }
        int m = l + ((r - l) >> 1);
        process(arr, l, m);
        process(arr, m + 1, r);
        merge(arr, l, m, r);
    }

    private static void merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        int i = 0;
        int p1 = l;
        int p2 = m + 1;
        while (p1 <= m && p2 <= r) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }

        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }

        for (int j = 0; j < help.length; j++) {
            arr[l + j] = help[j];
        }
    }
    
    /**
     * 非递归实现
     */
    public static void mergeSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int n = arr.length;
        // 当前有序的左组长度
        int mergeSize = 1;
        while (mergeSize < n) { // log n
            int l = 0;
            while (l < n) {
                // l...m  左组（mergeSize）
                int m = l + mergeSize - 1;
                if (m >= n) {
                    break;
                }
                //  l...m   m+1...r(mergeSize)
                int r = Math.min(m + mergeSize, n - 1);
                merge(arr, l, m, r);
                l = r + 1;
            }
            // 防止越界
            if (mergeSize > n / 2) {
                break;
            }
            mergeSize <<= 1;
        }
    }
}
```

归并排序的时间复杂度：

`T(N) = 2*T(N/2) + O(N^1)`

根据 master 可知时间复杂度为 O(N*logN)

**归并排序的实质是把比较行为变成了有序信息并传递**，即在做 merge 行为时，左组和右组已经分别有序了，所以比 O(N^2) 的排序快。

### 归并排序面试题

在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和，求数组小和。

比如：有这样的一个数组 [1,3,4,2,5] 
1 左边比 1 小的数：没有
3 左边比 3 小的数：1
4 左边比 4 小的数：1、3
2 左边比 2 小的数：1
5 左边比 5 小的数：1、3、4、 2
所以数组的小和为 1+1+3+1+1+3+4+2=16 

代码如下所示：

```java
public class SmallSum {

    /**
     * 使用归并排序求数组小和，时间复杂度为 O(N*logN)
     */
    static int smallSum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    static int process(int[] arr, int l, int r) {
        if (r == l) {
            return 0;
        }
        int m = l + ((r - l) >> 1);
        return process(arr, l, m) + process(arr, m + 1, r) + merge(arr, l, m, r);
    }

    private static int merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        int i = 0;
        int p1 = l;
        int p2 = m + 1;
        int result = 0;
        while (p1 <= m && p2 <= r) {
            if (arr[p1] < arr[p2]) {
                result += (r - p2 + 1) * arr[p1];
            }
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }

        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }

        for (int j = 0; j < help.length; j++) {
            arr[l + j] = help[j];
        }
        return result;
    }

    /**
     * 一般方法实现，时间复杂度为 O(N^2)
     */
    static int comparator(int[] arr) {
        if (arr == null || arr.length == 1) {
            return 0;
        }
        int result = 0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] < arr[j]) {
                    result += arr[i];
                }
            }
        }
        return result;
    }
}
```



数组中某个元素 x，若其右边的元素 y 比 x 小，则存在一个降序对（x,y），求数组降序对总个数。

比如：有这样的一个数组 [1,3,4,2,5] 
1 右边的降序对个数：0
3 右边的降序对个数：1
4 右边的降序对个数：1
2 右边的降序对个数：0
5 右边的降序对个数：0
所以数组升序对的个数为：0+1+1+0+0=2

代码如下所示：

```java
public class DescendOrderPair {

    /**
     * 使用归并排序求数组小和，时间复杂度为 O(N*logN)
     */
    static int count(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    static int process(int[] arr, int l, int r) {
        if (r == l) {
            return 0;
        }
        int m = l + ((r - l) >> 1);
        return process(arr, l, m) + process(arr, m + 1, r) + merge(arr, l, m, r);
    }

    private static int merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        int i = 0;
        int p1 = l;
        int p2 = m + 1;
        int result = 0;
        while (p1 <= m && p2 <= r) {
            if (arr[p1] > arr[p2]) {
                result += (m - p1 + 1);
            }
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }

        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }

        for (int j = 0; j < help.length; j++) {
            arr[l + j] = help[j];
        }
        return result;
    }

    /**
     * 一般方法实现，时间复杂度为 O(N^2)
     */
    static int comparator(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        int result = 0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    result ++;
                }
            }
        }
        return result;
    }
}
```

## 快速排序

### partition 问题

给定一个数组 arr，和一个整数 num。请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边。
要求额外空间复杂度 O(1)，时间复杂度 O(N)。

代码实现如下：

```java
public class Partition {

    /**
     * 对数组 arr 进行分区，使得 [l,r] 范围内，小于等于 arr[r] 的数再左边，大于 arr[r] 的数在右边。返回分界位置。
     * 实现步骤：
     * 定义小于等于区的右边界（less），起始位置为 l-1；
     * 遍历 [l,r-1]，比较 arr[i] 和 arr[r] 的大小：
     * 若 arr[i] <= arr[r]，和右边界下一个位置做交换，并将右边界右移一位；
     * 若 arr[i] > arr[r]，不做处理，比较下个数。
     * 最后将 r 位置的数和右边界下一个位置做交换，返回 less。
     *
     * @return 分界位置
     */
    static int partition(int[] arr, int l, int r) {
        if (arr == null || l > r) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        int less = l - 1;
        for (int i = l; i < r; i++) {
            if (arr[i] <= arr[r]) {
                swap(arr, ++less, i);
            }
        }
        swap(arr, ++less, r);
        return less;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * for test
     * 查找数组 [l,r] 范围内小于等于 arr[r] 的个数 count，则 l+count-1 就是小于等于边界位置。
     */
    static int comparator(int[] arr, int l, int r) {
        if (arr == null || l > r) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        int count = 0;
        for (int i = l; i <= r; i++) {
            if (arr[i] <= arr[r]) {
                count++;
            }
        }
        return l + count - 1;
    }
}
```

荷兰国旗问题，

给定一个数组 arr，和一个整数 num。请把小于 num 的数放在数组的左边，等于的放中间，大于 num 的数放在数组的右边。
要求额外空间复杂度 O(1)，时间复杂度 O(N)。

代码如下所示：

```java
public class NetherlandsFlag {

    /**
     * 给定一个数组 arr，和一个整数 num。请把小于 num 的数放在数组的左边，等于的放中间，大于 num 的数放在数组的右边。
     * 实现步骤：
     * 定义小于区的右边界 less，其实位置为 l-1，大于区的左边界 more，起始区为 r。
     * 遍历 [l,r] 范围内数组元素，比较 arr[i] 和 arr[r] 的大小：
     * 若 arr[i] < arr[r]，和小于区边界下一个元素做交换，小于区右边界右移一位，比较下个数；
     * 若 arr[i] = arr[r]，不做处理，比较下个数；
     * 若 arr[i] > arr[r]，和大于区的右边界前一个数交换，大于区左边界左移一位，下标不移动。
     * 最后将 r 位置的数，和大于区左边界的数交换。
     *
     * @return 等于区起始和终止位置
     */
    static int[] netherLandsFlag(int[] arr, int l, int r) {
        if (arr == null || l > r) {
            return new int[]{-1, -1};
        }
        if (l == r) {
            return new int[]{l, r};
        }
        int less = l - 1;
        int more = r;
        for (int i = l; i < more; ) {
            if (arr[i] < arr[r]) {
                swap(arr, ++less, i++);
            } else if (arr[i] == arr[r]) {
                i++;
            } else {
                swap(arr, --more, i);
            }
        }
        swap(arr, more, r);
        return new int[]{less + 1, more};
    }

    /**
     * for test
     * 查找数组 [l,r] 范围内小于 arr[r] 的个数 less，大于 arr[r] 的数的个数 more，则 l+less-1 就是小于区边界位置，r-more+1 就是大于区
     * 边界位置，则 l+less 和 r-more 分别就为等于区的起始和终止位置。
     */
    static int[] comparator(int[] arr, int l, int r) {
        if (arr == null || l > r) {
            return new int[]{-1, -1};
        }
        if (l == r) {
            return new int[]{l, r};
        }
        int less = 0;
        int more = 0;
        for (int i = l; i <= r; i++) {
            if (arr[i] < arr[r]) {
                less++;
            } else if (arr[i] > arr[r]) {
                more++;
            }
        }
        return new int[]{l + less, r - more};
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 随机快排

方法一：

在 arr[L..R] 范围上，进行快速排序的过程：

1. 用 arr[R] 对该范围做 partition，小于等于 arr[R] 的数在左部分并且保证 arr[R] 最后来到左部分的最后一个位置，记为 M；小于等于 arr[R] 的数在右部分为（arr[M+1..R]）；
2. 对 arr[L..M-1] 进行快速排序；
3. 对arr[M+1..R]进行快速排序；

因为每一次 partition 都会将最右侧位置的数放到排序正确的位置，所以排序最终能够完成。

代码如下所示：

```java
public class QuickSort {

 	static void quickSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process1(arr, 0, arr.length - 1);
    }

    private static void process1(int[] arr, int l, int r) {
        if (l >= r) {
            return;
        }
        // l..r partition arr[r]  [<=arr[r]   arr[r]    >arr[r]]
        int m = Partition.partition(arr, l, r);
        process1(arr, l, m - 1);
        process1(arr, m + 1, r);
    }
}
```

方法二：

在 arr[L..R] 范围上，进行快速排序的过程：

1. 用 arr[R] 对该范围做 partition（荷兰国旗方法分区），小于 arr[R] 的数在左部分，等于 arr[R] 的数中间，大于 arr[R] 的数在右部分。假设等于 arr[R] 的数所在范围是 [a,b]。
2. 对 arr[L..a-1] 进行快速排序；
3. 对 arr[b+1..R] 进行快速排序；

因为每一次 partition 都会将一批数的位置放到排序的正确位置上，所以排序最终能够能完成。

代码如下所示：

```java
public class QuickSort {

    static void quickSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process2(arr, 0, arr.length - 1);
    }

    private static void process2(int[] arr, int l, int r) {
        if (l >= r) {
            return;
        }
        int[] equalArea = NetherlandsFlag.netherLandsFlag(arr, l, r);
        process2(arr, l, equalArea[0] - 1);
        process2(arr, equalArea[1] + 1, r);
    }
}
```



方法一和方法二的时间复杂度：

数组已经有序的时候就是复杂度最高的时候：

每次分区都只会处理左侧或右侧位置，每次分区的的时间复杂度为 O(N-i)，一共分区 N 次，等差数列求和，时间复杂度为 O(N^2)。

方法二比方法一好的地方就在于方法一每次只能将一个数放到正确位置，而方法二每次能够将一批数放到正确位置。



方法三：

在 arr[L..R] 范围上，进行快速排序的过程：

1. 在这个范围上，随机选一个数记为 num；
2. 用 num 对该范围做 partition，小于 num 的数在左部分，等于 num 的数在中间，大于 num 的数在右部分。假设等于 num 的数所在范围是[a,b]；
3. 对 arr[L..a-1] 进行快速排序；
4. 对arr[b+1..R] 进行快速排序；

因为每一次 partition 都会将一批数的位置放到排序的正确位置上，所以排序最终能够能完成。

代码如下所示：

```java
public class QuickSort {

    static void quickSort3(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process3(arr, 0, arr.length - 1);
    }

    private static void process3(int[] arr, int l, int r) {
        if (l >= r) {
            return;
        }
        swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
        int[] equalArea = NetherlandsFlag.netherLandsFlag(arr, l, r);
        process3(arr, l, equalArea[0] - 1);
        process3(arr, equalArea[1] + 1, r);
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```



方法三的时间复杂度：

- 通过分析知道，划分值越靠近中间，性能越好，越靠近两边，性能越差；
- 随机选一个数进行划分的目的就是让好情况和差情况都变成等概率事件；
- 把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N；
- 那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望。

时间复杂度 O(N*logN)，额外空间复杂度 O(logN ) 都是这么来的。