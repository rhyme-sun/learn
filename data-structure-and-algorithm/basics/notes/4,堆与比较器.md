# 堆与比较器

## 堆

### 堆结构

完全二叉树：要么这一层是满的，要么这一层在从左往右变满的状态。

堆结构从结构上来讲是一种完全二叉树结构。

大根堆：根节点比子节点数值大。

小根堆：根节点比子节点数值小。

使用数组存储（描述）堆，则数组元素下标为 i 的元素，左子节点位置为 `2*i+1`，右子节点下标为 `2*i+2`，根节点元素下标为 `(i-1)/2`。

堆的结构实现（大根堆）：

```java
public static class MyMaxHeap {

    private int[] heap;
    private final int limit;
    private int heapSize;

    public MyMaxHeap(int limit) {
        heap = new int[limit];
        this.limit = limit;
        heapSize = 0;
    }

    public boolean isEmpty() {
        return heapSize == 0;
    }

    public boolean isFull() {
        return heapSize == limit;
    }

    public void push(int value) {
        if (heapSize == limit) {
            throw new RuntimeException("heap is full");
        }
        heap[heapSize] = value;
        heapInsert(heap, heapSize++);
    }

    private void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    /**
      * 返回最大值，并且在大根堆中，把最大值删掉。
      */
    public int pop() {
        int ans = heap[0];
        swap(heap, 0, --heapSize);
        heapify(heap, 0, heapSize);
        return ans;
    }

    private void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 左右两个孩子中，谁大，谁把自己的下标给 largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 根节点和值最大孩子节点比较，值大的下标给 largest
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

### 堆排序

1. 先让整个数组都变成大根堆结构，建立堆的过程：
   - 从上到下构建堆，即从最顶层的根节点开始构建堆，时间复杂度为 O(N*logN)；
   - 从下到上调整堆，即从最底层的子节点开始调整堆，时间复杂度为 O(N) 。
2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为 O(N*logN)。
3. 堆的大小减小成 0 之后，排序完成。 

```java
public class HeapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 将数组变成大根堆结构
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }
        // 将堆顶和堆尾元素交换（即最大元素放到了数组末尾），令除去堆尾元素的部分再成为一个大根堆
        int heapSize = arr.length;
        while (heapSize > 0) {
            heapify(arr, 0, heapSize);
            swap(arr, 0, --heapSize);
        }
    }

    private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 左右两个孩子中，谁大，谁把自己的下标给 largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 根节点和值最大孩子节点比较，值大的下标给 largest
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

堆排序优化

将一个数组变成大根堆时，上述方法的时间复杂度为 O(N*logN)，可以使用下面方法优化为 O(N)。

```java
public class HeapSort {

    /**
     * 堆排序优化
     */
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 将数组变成大根堆结构
        for (int i = arr.length - 1; i >= 0; i--) {
            heapify(arr, i, arr.length);
        }
        // 将堆顶和堆尾元素交换（即最大元素放到了数组末尾），令除去堆尾元素的部分再成为一个大根堆
        int heapSize = arr.length;
        while (heapSize > 0) {
            heapify(arr, 0, heapSize);
            swap(arr, 0, --heapSize);
        }
    }

    private static void heapInsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            // 左右两个孩子中，谁大，谁把自己的下标给 largest
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            // 根节点和值最大孩子节点比较，值大的下标给 largest
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

堆排序时间复杂度：O(N*logN)

### 堆的应用

和堆相关的算法题目。

已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过 k，并且 k 相对于数组长度来说是比较小的。

请选择一个合适的排序策略，对这个数组进行排序。 

使用堆，先将前 k 个数放到小根堆中，那么这 k 中的最小值就为整个数组的最小值，因为超过这个范围的数移动次数一定大于或等于 k，不满足要求，然后将弹出堆顶元素；接着将第 k+1 个放入堆中，继续弹出，依次类推，直到堆中元素全部弹出。代码如下所示：

```java
public class SortArrayDistanceLessK {

	public static void sortedArrDistanceLessK(int[] arr, int k) {
		if (k == 0) {
			return;
		}
		// 默认小根堆
		PriorityQueue<Integer> heap = new PriorityQueue<>();
		int index = 0;
		// 0...k-1
		for (; index <= Math.min(arr.length - 1, k - 1); index++) {
			heap.add(arr[index]);
		}
		int i = 0;
		for (; index < arr.length; i++, index++) {
			heap.add(arr[index]);
			arr[i] = heap.poll();
		}
		while (!heap.isEmpty()) {
			arr[i++] = heap.poll();
		}
	}
}
```

更复杂的堆， 支持存储对象（范型），自定义比较器（决定是大根堆或小根堆），resign 堆（在堆排好顺序后，调用对象内部方法手动修改属性值，重新调整堆中元素顺序）。代码如下：

```java
public static class MyHeap<T> {
    private ArrayList<T> heap;
    private HashMap<T, Integer> indexMap;
    private int heapSize;
    private Comparator<? super T> comparator;

    public MyHeap(Comparator<? super T> com) {
        heap = new ArrayList<>();
        indexMap = new HashMap<>();
        heapSize = 0;
        comparator = com;
    }

    public boolean isEmpty() {
        return heapSize == 0;
    }

    public int size() {
        return heapSize;
    }

    public boolean contains(T key) {
        return indexMap.containsKey(key);
    }

    public void push(T value) {
        heap.add(value);
        indexMap.put(value, heapSize);
        heapInsert(heapSize++);
    }

    public T pop() {
        T ans = heap.get(0);
        int end = heapSize - 1;
        swap(0, end);
        heap.remove(end);
        indexMap.remove(ans);
        heapify(0, --heapSize);
        return ans;
    }

    public void resign(T value) {
        int valueIndex = indexMap.get(value);
        heapInsert(valueIndex);
        heapify(valueIndex, heapSize);
    }

    private void heapInsert(int index) {
        while (comparator.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    private void heapify(int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            int largest = left + 1 < heapSize && (comparator.compare(heap.get(left + 1), heap.get(left)) < 0)
                ? left + 1
                : left;
            largest = comparator.compare(heap.get(largest), heap.get(index)) < 0 ? largest : index;
            if (largest == index) {
                break;
            }
            swap(largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    private void swap(int i, int j) {
        T o1 = heap.get(i);
        T o2 = heap.get(j);
        heap.set(i, o2);
        heap.set(j, o1);
        indexMap.put(o1, j);
        indexMap.put(o2, i);
    }
}
```

## 比较器

比较器的实质就是重载比较运算符；

比较器可以很好的应用在特殊标准的排序上；

比较器可以很好的应用在根据特殊标准排序的对象结构上，而不仅仅是 int 数值。

### 比较器的统一约定

即如下方法：

```
int compare(T o1, T o2);

```

返回负数的情况，就是 o1 比 o2 优先的情况，即排序 o1 会在 o2 前；
返回正数的情况，就是 o2 比 o1 优先的情况，即排序 o2 会在 o1 前；
返回0的情况，就是 o1 与 o2 同样优先的情况。