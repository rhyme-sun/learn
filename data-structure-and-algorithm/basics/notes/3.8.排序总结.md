# 排序算法总结

这里总结下各个排序算法的思路，并分析其时间复杂度、额外空间复杂度和稳定性。

## 排序算法稳定性

排序算法稳定性是指**同样大小的样本再排序之后不会改变相对次序**，比如原数组为 `[2,1,3,2]`，从小到大排序为 `[1,2,2,3]`，排序稳定要求原数组的 2 的相对次序在排序后不会发生改变，即排完序后原数组第一个 2 仍然要在最后一个 2 前面。

原数组数组中在前面位置 a 在排完序后也要在前面。

对基础类型来说，稳定性毫无意义，对非基础类型来说，稳定性有重要意义，有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的。

这里简要总结下排序算法的思路，并讨论其稳定性。

## 选择排序

选择排序的排序思路是（数组长度为 n，从小到大排序）：

- 在数组的 `0~n-1` 范围内选择一个最小的值放到 0 位置；
- 在数组的 `1~n-1` 范围内选择一个最小值放到 1 位置；
- ......
- 在数组的 `n-2~n-1` 范围内选择一个最小值放到 `n-1` 位置，至此排序完毕。

### 时间复杂度分析

选择排序需要循环 `n-1` 次，在最差情况下每次比较交换的次数依次为 `n-1`、`n-2`、....、1 次，所以其时间复杂度为：

```
(n-1+1)*(n-1)/2=(n^2-n)/2
```

忽略掉系数和低阶项，所以时间复杂度为 `O(N^2)`。

### 额外空间复杂度分析

选择排序需要交换数据两个位置的数据，需要一个额外空间，所以额外空间复杂度为 `O(1)`。

### 稳定性分析

选择排序是不稳定的。举个例子，原数组为 `[2,2,2,5,1,2]`，在第一次循环时就把第一个位置的 2 和后面的 1 交换了，这样 2 的相对顺序就改变了，所以选择排序时不稳定的。

## 冒泡排序

冒泡排序的思路是（数组长度为 n，从小到大排序）：

- 在 `0~n-1` 范围内，从数组第一个数开始依次判断相邻两个数的大小，大则交换；

- 在 `0~n-2` 范围内，从数组第一个数开始依次判断相邻两个数的大小，大则交换；
- ......
- 在 `0~2` 范围内，判断第一个数和第二数的大小，大则交换，支持排序完毕。

### 时间复杂度分析

冒泡排序需要循环 `n-1` 次，在最差情况下每次比较交换的次数依次为 `n-1`、`n-2`、....、1 次，所以其时间复杂度为：

```
(n-1+1)*(n-1)/2=(n^2-n)/2
```

忽略掉系数和低阶项，所以时间复杂度为 `O(N^2)`。

### 额外空间复杂度分析

冒泡排序需要交换数据两个位置的数据，需要一个额外空间，所以额外空间复杂度为 `O(1)`。

### 稳定性分析

冒泡排序是稳定的。决定冒泡排序的稳定性的关键在于处理相等的情况，如果相等不交换位置则是稳定的，如果相等交换了位置则是不稳定的。

## 插入排序

插入排序的算法思路是（数组长度为 n，从小到大排序）：

- 在 `0~1` 位置，从 1 位置依次向前看，小则交换；

- 在 `0~2` 位置，从 2 位置依次详情看，小则交换；
- ......
- 在 `0~n-1` 位置，从 n-1 位置依次向前看，小则交换，至此排序完毕。

### 时间复杂度分析

插入排序需要循环 `n-1` 次，在最差情况下每次比较交换的次数依次为 1、2、......、`n-2`、`n-1` 次，所以其时间复杂度为：

```
(n-1+1)*(n-1)/2=(n^2-n)/2
```

忽略掉系数和低阶项，所以时间复杂度为 `O(N^2)`。

### 额外空间复杂度分析

插入排序需要交换数据两个位置的数据，需要一个额外空间，所以额外空间复杂度为 `O(1)`。

### 稳定性分析

插入排序是稳定的。决定插入排序的稳定性的关键在于处理相等的情况，如果相等不交换位置则是稳定的，如果相等交换了位置则是不稳定的。

## 归并排序

归并排序的算法思想是，对于一个数组，将其二等分，让其左边和右边分别排好序，最后再通过 merge 分别有序的左组和右组，让整个数组有序。

### 时间复杂度分析

归并排序利用了二分法的思想，数组二分的次数为 `log(N)`，每次 `merge` 时都需要进行 n 的倍数次比较移动，所以时间复杂度为 `N*log(N)`。

### 空间复杂度分析

归并排序每次 merge 时需要创建和 merge 元素个数相等的数据来存放 merge 结果，所示额外空间复杂度为 `O(N)`。

### 稳定性分析

归并排序是稳定的。归并排序是否稳定取决于在 merge 左右组时对于相等数据的处理，数据相等时如果拷贝的时左组的数据则是稳定的，如果拷贝的是右组的数据则是不稳定的。

## 快速排序

快速排序时基于 partition 问题递归实现的。

partition 问题又两中方式，分别为 ：

- 分区（partition）问题：即给定一个数组 arr，选定一个分界数 a，把小于等于 a 的数放在数组的左边，大于 a 的数放在数组的右边，要求额外空间复杂度 `O(1)`，时间复杂度 `O(N)`；
- 荷兰国旗问题：即给定一个数组 arr，选定一个分界数 a，把小于 a 的数放在数组的左边，等于的放中间，大于 a 的数放在数组的右边，要求额外空间复杂度 `O(1)`，时间复杂度 `O(N)`。

下面说明一下在 `arr[l~r]` 范围上随机快排的步骤：

- 在这个范围上，随机选一个数记为 n；
- 用 n 对该范围做 partition（荷兰国旗分区），小于 n 的数在左部分，等于 n 的数在中间，大于 n 的数在右部分，假设等于 n 的数所在范围是 `[a,b]`；
- 对 `arr[l~a-1]` 进行快速排序；
- 对 `arr[b+1..r]` 进行快速排序。

因为每一次 partition 都会将一批数的位置放到排序的正确位置上，所以排序最终能够能完成。

### 时间复杂度分析

- 通过分析知道，划分值越靠近中间（时间复杂度越接近于 `O(logN)`），性能越好，越靠近两边（时间复杂度越接近于 `O(N^2)`），性能越差；
- 随机选一个数进行划分的目的就是让好情况和差情况都变成等概率事件；
- 把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是 1/N；
- 那么所有情况都考虑，得到时间复杂度为 `O(N*logN)`，额外空间复杂度为 `O(logN)` 。

### 额外空间复杂度分析

见上述时间复杂度分析。

### 稳定性分析

快速排序是不稳定的，快速排序时基于 partition 问题递归实现的，在解决 partition 问题的过程中是不稳定的。

## 堆排序

堆排序（从小到大）的过程如下：

- 先让整个数组都变成大根堆结构，建立堆，则堆顶的元素就为数组中的最大值，构建堆有两中方式：

  - 从最顶层的根节点开始构建堆，时间复杂度为 `O(N*logN)`；
  - 从最底层的子节点开始调整堆，时间复杂度为 `O(N)` ；

  > 然后把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆成为大根堆，一直周而复始，时间复杂度为 `O(N*logN)`；
  >

- 堆的大小减小成 0 之后，排序完成。 

### 时间复杂度分析

时间复杂度的粗略证明：

对于从顶层开始构建堆，每次迭代的时间复杂度为：`O(logi)`，所以时间复杂度为：

```
T(N) = log1 + log2 + ... + logN = log(1*2*......N) = log(N!) < log(N^N) = N*log(N)
```

对于从底层开始调整堆，每次调整的时间复杂度随着深度的降低而变化，比如堆（堆本质是一个完全二叉树）的最下层节点（叶子节点），规模是 N/2，其比较次数为 1，倒数第 2 层节点的规模为 N/4，比较调整次数为 2，依次类推，所以时间复杂度为：

```
T(N) = N/2 * 1 + N/4 * 2 + N/8 * 3 + N/16 * 4 + ......
2T(N) = N*1 + N/2*2 + N/4 * 3 + N/8*4 + ......

错位相减得：

T(N) = N + N/2 + N/4 + N/8 + ...... = N(1/2 + 1/4 + 1/8 + ......) 

等比数列求和，若公比大于 -1 小于 1，则等比数列的和收敛到一个常数 C，所以

T(N) = C*N = N
```

### 额外空间复杂度分析

堆排序在调整堆时需要交换数组两个元素的位置，所以时间复杂度为 `O(1)`。

### 稳定性分析

堆排序是不稳定的。

## 计数排序

计数排序是桶排序的一种，其对排序的数据范围有要求，这里假设我们要排序的数据为整数，且范围在 0~200 之间，这样我们就可以创建一个长度为 201 的数组（数组的一个位置可以理解为一个桶），然后遍历需要排序的数据，将数据出现的次数存放到创建数组对应下标的位置，比如 0 这个数字一共出现了 7 次，那么数组 0 位置就存放 7；最后遍历桶数组，根据数组下标和对应个数就可以输出排好序的数据。

### 时间复杂度分析

计数排序通过两次循环，第一次维护号计数数组，第二次输出排序数组，每次的时间复杂度都为 `O(N)`，所以计数排序的时间复杂度为 `O(N)`。

### 额外空间复杂度分析

计数排序需要样本数据范围个桶来存放每个数出现的次数，所以额外空间复杂度为 `O(M)`。

### 稳定性分析

计数排序是稳定的。

## 基数排序

计数排序也是桶排序的一种，同样地其对样本数据也有要求，要求样本是 10 进制的正整数，比如说有这样一组样本数据：`[12, 56, 34, 90, 6, 122]`

- 获取最大值的十进制位数；
- 将这些样本数据高位补零，使得所有数据数字的个数和最大值一样，样本数据就为：`[012, 056, 034, 090, 006, 122]`；
- 准备 0 ~ 9 一共 10 个桶；
- 从左到右遍历数据，将数据放入个位数对应的桶中，然后桶中依次弹出（队列，先进先出），这样数据顺序就变为 `[090, 012, 122, 034, 056, 006]`；
- 接着和上一步一样，不过此时根据是十位数进行操作，数据顺序就变为 `[006, 012, 122, 034, 056, 090]`；
- 接着操作百位数，数据顺序就变为 `[006, 012, 034, 056, 090, 122]`，去掉高位的 0，排序完毕。

### 时间复杂度分析

基数排序进行数据位数次循环，每次时间复杂度为 `O(N)`，一般排序数的位数都较小，可视为常数，所以基数排序的时间复杂度为 `O(N)`。

### 额外空间复杂度分析

基数时间复杂度需要 10 个桶来存放每位对应桶序号的数字，额外空间复杂度为 `O(M)`。

### 稳定性分析

基数排序的桶是个队列结构，如果两个数是相等的，左边的数会先进先出，所以排完序后相对顺序不会改变，是稳定的。

## 排序算法注意事项

归并排序的额外空间复杂度可以变成 `O(1)`，“归并排序内部缓存法”，但是将变得不再稳定。

原地归并排序是垃圾贴，会让时间复杂度变成 `O(N^2)` 

快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。

## 总结

| 排序算法 | 时间复杂度  | 额外空间复杂度 | 稳定性 |
| -------- | ----------- | -------------- | ------ |
| 选择排序 | `O(N^2)`    | `O(1)`         | 无     |
| 冒泡排序 | `O(N^2)`    | `O(1)`         | 有     |
| 插入排序 | `O(N^2)`    | `O(1)`         | 有     |
| 归并排序 | `O(N*logN)` | `O(N)`         | 有     |
| 随机快排 | `O(N*logN)` | `O(logN)`      | 无     |
| 堆排序   | `O(N*logN)` | `O(1)`         | 无     |
| 计数排序 | `O(N)`      | `O(M)`         | 有     |
| 基数排序 | `O(N)`      | `O(M)`         | 有     |

关于排序算法，有以下几点总结：

- 不基于比较的排序，对样本数据有严格要求，不易改写，基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用；
- 基于比较的排序，时间复杂度的极限是 `O(N*logN)`；
- 时间复杂度 `O(N*logN)`，额外空间复杂度低于 `O(N)`，且稳定的基于比较的排序是不存在的；
- 为了绝对的速度选快速排序，为了省空间选堆排序，为了稳定性选归并排序。

上述笔记总结自：

- [左程云_算法与数据结构基础班【马士兵教育】-学习视频教程-腾讯课堂 (qq.com)](https://ke.qq.com/course/2145184?tuin=b09cbb87) 第 5 课