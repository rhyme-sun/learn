# 链表、栈、队列、递归行为、哈希表

## 链表

### 单链表

链表节点结构

```java
static class Node {
    public int value;
    public Node next;

    public Node(int data) {
        value = data;
    }
}
```

链表翻转

```java
public static Node reverse(Node head) {
    Node pre = null;
    Node next;
    while (head != null) {
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```

链表元素删除

```java
public static Node remove(Node head, int num) {
    while (head != null) {
        if (head.value != num) {
            break;
        }
        head = head.next;
    }
    // head来到 第一个不需要删的位置
    Node pre = head;
    Node cur = head;
    //
    while (cur != null) {
        if (cur.value == num) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
```

### 双链表

链表节点结构

```java
static class DoubleNode {
    public int value;
    public DoubleNode last;
    public DoubleNode next;

    public DoubleNode(int data) {
        value = data;
    }
}
```

链表翻转

```java
public static DoubleNode reverse(DoubleNode head) {
    DoubleNode pre = null;
    DoubleNode next;
    while (head != null) {
        next = head.next;
        head.next = pre;
        head.last = next;
        pre = head;
        head = next;
    }
    return pre;
}
```

链表元素删除

// TODO ...

### 循环单链表

### 循环双链表

## 栈

栈是一种后入先出结构，即只能在栈顶操作（增删）元素。

用链表实现

```java
public class LinkedStack {

    static class Node {

        String data;
        Node last;

        public Node(String data, Node last) {
            this.data = data;
            this.last = last;
        }
    }

    private Node top;

    private int capacity;
    private int size;

    public LinkedStack(int initCapacity) {
        this.capacity = initCapacity;
    }

    /**
     * 入栈
     * 1<-2<-3<-4
     */
    public boolean push(String e) {
        // 栈已满
        if (size == capacity) {
            return false;
        }
        top = new Node(e, top);
        size++;
        return true;
    }

    /**
     * 出栈
     */
    public String pop() {
        if (size == 0) {
            return null;
        }
        String data = top.data;
        top = top.last;
        size--;
        return data;
    }
}
```

用数组实现

```java
public class ArrayStack {

    private String[] data;

    /**
     * 栈中元素的数量
     */
    private int size;

    /**
     * 栈容量
     */
    private int capacity;

    public ArrayStack(int initCapacity) {
        this.data = new String[initCapacity];
        this.capacity = initCapacity;
    }

    /**
     * 入栈
     *
     * @param e 元素
     */
    public boolean push(String e) {
        // 栈已满
        if (size == capacity) {
            return false;
        }
        data[size++] = e;
        return true;
    }

    /**
     * 出栈
     */
    public String pop() {
        if (size == 0) {
            return null;
        }
        return data[--size];
    }
}
```

返回栈中最小的数，要求时间复杂度为 O(1) 

用两个栈，一个栈用来存放元素，一个栈用来存放栈中最小目前最小元素，有两种实现方法，代码如下所示：

```java
public class GetMinStack {

    static class MinStack1 {
        private Stack<Integer> stackData;
        private Stack<Integer> stackMin;

        public MinStack1() {
            this.stackData = new Stack<>();
            this.stackMin = new Stack<>();
        }

        public void push(int newNum) {
            if (this.stackMin.isEmpty()) {
                this.stackMin.push(newNum);
            } else if (newNum <= this.getMin()) {
                this.stackMin.push(newNum);
            }
            this.stackData.push(newNum);
        }

        public int pop() {
            if (this.stackData.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            int value = this.stackData.pop();
            if (value == this.getMin()) {
                this.stackMin.pop();
            }
            return value;
        }

        public int getMin() {
            if (this.stackMin.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            return this.stackMin.peek();
        }
    }

    static class MinStack2 {
        private Stack<Integer> stackData;
        private Stack<Integer> stackMin;

        public MinStack2() {
            this.stackData = new Stack<Integer>();
            this.stackMin = new Stack<Integer>();
        }

        public void push(int newNum) {
            if (this.stackMin.isEmpty()) {
                this.stackMin.push(newNum);
            } else if (newNum < this.getMin()) {
                this.stackMin.push(newNum);
            } else {
                int newMin = this.stackMin.peek();
                this.stackMin.push(newMin);
            }
            this.stackData.push(newNum);
        }

        public int pop() {
            if (this.stackData.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            this.stackMin.pop();
            return this.stackData.pop();
        }

        public int getMin() {
            if (this.stackMin.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            return this.stackMin.peek();
        }
    }
}
```

用栈实现队列，用两个栈，一个栈用于数据存放入队的数据，一个栈用来存放出队的数据。当数据入队时，将元素放置入队栈中，当数组出队时，先将入队栈的元素全部弹出并放到出队栈，并弹出出队栈顶的元素。其次要注意一点的是，从入队栈转移元素到出队栈时，必须保证一次全部转移完毕，并且只有在出队栈为空时才能够转移，这样才能保证正确的出队顺序。代码如下所示：

```java
public class TwoStacksImplementQueue {

    static class TwoStacksQueue {
        public Stack<Integer> stackPush;
        public Stack<Integer> stackPop;

        public TwoStacksQueue() {
            stackPush = new Stack<>();
            stackPop = new Stack<>();
        }

        /**
         * 将 push 栈中的所有数据导入 pop 栈
         */
        private void pushToPop() {
            if (stackPop.empty()) {
                while (!stackPush.empty()) {
                    stackPop.push(stackPush.pop());
                }
            }
        }

        public void add(int pushInt) {
            stackPush.push(pushInt);
        }

        public int poll() {
            if (stackPop.empty() && stackPush.empty()) {
                throw new RuntimeException("Queue is empty!");
            }
            pushToPop();
            return stackPop.pop();
        }

        public int peek() {
            if (stackPop.empty() && stackPush.empty()) {
                throw new RuntimeException("Queue is empty!");
            }
            pushToPop();
            return stackPop.peek();
        }
    }

    public static void main(String[] args) {
        TwoStacksQueue test = new TwoStacksQueue();
        test.add(1);
        test.add(2);
        test.add(3);
        System.out.println(test.peek());
        System.out.println(test.poll());
        System.out.println(test.peek());
        System.out.println(test.poll());
        System.out.println(test.peek());
        System.out.println(test.poll());
    }
}
```

## 队列

队列是一种先入先出结构，即只能子队列头部添加元素，在队列尾部移除元素。

用链表实现

```java
public class LinkedQueue {

    static class Node {

        /**
         * 数据
         */
        String data;

        /**
         * 指向下一个节点
         */
        Node next;

        public Node(String data) {
            this.data = data;
        }
    }

    private int capacity;
    private int size;

    private Node head;
    private Node tail;

    public LinkedQueue(int initCapacity) {
        this.capacity = initCapacity;
    }

    /**
     * 入队
     * 1->2->3->4
     */
    public boolean push(String e) {
        if (size == capacity) {
            return false;
        }
        Node node = new Node(e);
        if (head == null) {
            head = node;
        } else {
            tail.next = node;
        }
        tail = node;
        size++;
        return true;
    }

    /**
     * 出队
     */
    public String poll() {
        if (head == null) {
            return null;
        }
        String data = head.data;
        head = head.next;
        size--;
        return data;
    }
}
```

用数组实现

```java
public class ArrayQueue {

    private String[] data;

    private int capacity;
    private int size;

    private int getIndex;
    private int putIndex;

    public ArrayQueue(int initCapacity) {
        this.data = new String[initCapacity];
        this.capacity = initCapacity;
    }

    /**
     * 入队
     */
    public boolean push(String e) {
        if (size == capacity) {
            return false;
        }
        data[putIndex] = e;
        size++;
        putIndex = nextIndex(putIndex);
        return true;
    }

    /**
     * 出队
     */
    public String poll() {
        if (size == 0) {
            return null;
        }
        String e = data[getIndex];
        size--;
        getIndex = nextIndex(getIndex);
        return e;
    }

    private int nextIndex(int i) {
        return i < capacity - 1 ? i + 1 : 0;
    }
}
```

使用队列实现栈

使用两个队列，当有元素入栈时，将元素放入到其中某一个队列中，当有元素需要出栈时，将有元素的队列中的元素依次出队，并留下最后一个元素作为弹出元素，之后交换两个队列的指针。代码如下所示：

```java
public class TwoQueueImplementStack {

    static class TwoQueueStack<T> {
        public Queue<T> queue;
        public Queue<T> help;

        public TwoQueueStack() {
            queue = new LinkedList<>();
            help = new LinkedList<>();
        }

        public void push(T value) {
            queue.offer(value);
        }

        public T poll() {
            while (queue.size() > 1) {
                help.offer(queue.poll());
            }
            T ans = queue.poll();
            Queue<T> tmp = queue;
            queue = help;
            help = tmp;
            return ans;
        }

        public T peek() {
            while (queue.size() > 1) {
                help.offer(queue.poll());
            }
            T ans = queue.poll();
            help.offer(ans);
            Queue<T> tmp = queue;
            queue = help;
            help = tmp;
            return ans;
        }

        public boolean isEmpty() {
            return queue.isEmpty();
        }
    }
}
```

## 递归

递归定义：大问题可不可以通过范围缩小但同等定义的子问题来解决，确定好子问题缩小的边界（递归的终止条件），最后设法将子问题的结论变成大问题的结论。

任何递归都可以用迭代来实现。

递归的时间复杂度

子问题规模相等的递归问题可以使用下面公式（Master 公式）计算时间复杂度：

```
T(N) = a * T(N/b) + O(N^d)
其中的 a、b、d 都是常数，a 表示子问题个数，N/b 表示子问题数据量规模，b 为常数表面规模相等，O(N^d) 表示出去子问题外，程序的时间复杂度）的递归函数。
```

具体的计算公式为：

- 如果 log(b,a) < d，复杂度为 O(N^d)。

- 如果 log(b,a) > d，复杂度为 O(N^log(b,a))。
- 如果 log(b,a) == d，复杂度为 O(N^d  * logN)。

例如：用递归方法求数组中的最大值，代码如下所示：

```java
public class GetMaxOfArray {

	/**
	 * 求 arr 中的最大值
	 */
	public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}

	/**
	 * 在 arr[l..r]范围上求最大值
	 */
	public static int process(int[] arr, int l, int r) {
		// arr[l..r]范围上只有一个数，直接返回，递归终止条件
		if (l == r) {
			return arr[l];
		}
		int mid = l + ((r - l) >> 1);
		int leftMax = process(arr, l, mid);
		int rightMax = process(arr, mid + 1, r);
		return Math.max(leftMax, rightMax);
	}
}

```

上述算法就满足 Master 公式的要求，其中子问题个数为 2，即分别求数组左边和右边的值，也就是 a=2；每次将数组二等分，所以子问题的数据规模为 N/2，即 b=2，不考虑子问题的复杂度，其余算法流程的复杂度为 O(1)，即 d=0。

根据公式 log(2,2) > 0，得到上述算法的复杂度为 O(N^log(2,2)) = O(N)。

## 哈希表

哈希表的增删改查的时间复杂度为 O(1)。

## 有序表

有序表是指表中所有数据元素的数值以递增或递减方式有序排列，是数据元素的**数值的有序性**，而和元素存储的先后顺序无关。和顺序表不同的是，有序表是一种逻辑结构，而顺序表是一种存储结构，顺序表的存储结构和其存储的先后顺序有关。

Java 中的有序表，如 TreeMap。

有序表的增删改查的时间复杂度为 O(logN)。