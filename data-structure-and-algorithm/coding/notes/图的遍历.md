# 图的遍历

图的遍历有两种方式，分为宽度优先遍历和深度优先遍历（广度优先遍历）。

深度优先遍历和宽度优先遍历的思想在解决图相关问题时会经常使用，因此要熟知这两种遍历方式。

比如我们有下面这样的图：

```
   A
 /   \
 B   C
 \   /
   D
   |
   E
```

## 深度优先遍历

深度优先遍历的思路为，从一个节点出发，尽可能深地向下遍历，当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点，去处理该节点的未被处理的其它节点。直到源节点全部子节点处理完毕。

比如上述图，从节点 A 出发深度优先遍历的顺序为：

- A->B->D->E：尽可能深的向下遍历；
- E->D：E 没有子节点，向上回溯到 D；
- D->B：D 没有为遍历的子节点，向上回溯到 B；
- B->A：B 没有未遍历的子节点，向上回溯到 A；
- A->C：A 遍历到 C；
- C->A：C 没有未遍历的子节点，向上回溯到 A；
- A 的全部子节点遍历完毕，遍历结束。

图的深度优先遍历可以**借助栈来实现**，代码如下所示：

```java
static void dfs(Node start) {
    if (start == null) {
        return;
    }
    Stack<Node> stack = new Stack<>();
    // 记录图的节点是否遍历过
    Set<Node> set = new HashSet<>();
    stack.push(start);
    set.add(start);
    while (!stack.isEmpty()) {
        Node cur = stack.peek();
        for (Node next : cur.nexts) {
            // 选择其中一个没有遍历过的子节点处理，所以结尾有个 break
            if (!set.contains(next)) {
                stack.push(cur);
                stack.push(next);
                set.add(next);
                break;
            }
        }
    }
}
```

深度优先遍历的时间复杂度为：`O(N)`，额外空间复杂度为：`O(N+D)`。

其中 N 为图节点的个数，D 为图最大深度。因为每个节点都会遍历一次，所以时间复杂度为 `O(N)`，因为需要栈和 Set 来存放节点，栈的最大大小为图的最大深度，Set 则存放了全部节点，所以额外空间复杂为 `O(N+D)`。

## 宽度优先遍历

宽度优先遍历的思想为，从一个节点出发，往下依次遍历同一级的各个节点，直到遍历到最下一级的最后一个节点。

比如上述图，从节点 A 出发的宽度优先遍历顺序为：

- A：根节点；
- B->C：遍历第二级节点；
- D：遍历第三级节点；
- E：遍历第四级节点。

图的宽度优先遍历可以**借助队列实现**，代码如下所示：

```java
static void bfs(Node start) {
    if (start == null) {
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    Set<Node> set = new HashSet<>();
    queue.add(start);
    set.add(start);
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        for (Node next : cur.nexts) {
            if (!set.contains(next)) {
                queue.add(next);
            }
        }
    }
}
```

宽度优先遍历的时间复杂度为：`O(N)`；额外空间复杂度为 `O(N)`。

## 相关题目

相关题目。

### 统计文件数目

给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算。

这个题目要使用到 Java 文件操作 API，涉及到的 API 包括：

```java
// 得到一个文件或目录对象
File f = new File(".");
// 判断当前文件是否为目录
f.isDirectory();
// 判断当前文件是否为文件
f.isFile();
// 列出文件下的文件
File[] files = f.listFiles();
```

解决思路如下：

如果把文件组织看作一颗多叉树，文件表示树的节点，给出的目录作为树的根节点。那么整棵多叉树的叶子节点的数量就是目录下文件的数目。多叉树可以看作图，统计子节点的数目可以使用**深度优先遍历**或**宽度优先遍历**去实现。

代码如下所示：

```java
static int dfs(File dir) {
    if (dir == null || !dir.isDirectory()) {
        return 0;
    }
    Stack<File> stack = new Stack<>();
    stack.push(dir);
    int count = 0;
    while (!stack.isEmpty()) {
        File cur = stack.pop();
        for (File file : cur.listFiles()) {
            if (file.isDirectory()) {
                stack.push(file);
            }
            if (file.isFile()) {
                count++;
            }
        }
    }
    return count;
}

static int bfs(File dir) {
    if (dir == null || !dir.isDirectory()) {
        return 0;
    }
    Queue<File> queue = new LinkedList<>();
    queue.add(dir);
    int count = 0;
    while (!queue.isEmpty()) {
        File cur = queue.poll();
        for (File file : cur.listFiles()) {
            if (file.isDirectory()) {
                queue.add(file);
            } 
            if (file.isFile()) {
                count++;
            }
        }
    }
    return count;
}
```











