# 第四课



## 1 非常频繁的数组查询

题目描述如下：

数组为 {3, 2, 2, 3, 1}，给出一个查询结果 (0, 3, 2)，意思是在数组里下标 0~3 这个范围上，有几个 2，这里答案返回 2。
假设给你一个数组 arr，现在给出的参数有数组查询范围 `[l,r]` 和要查询出现次数的值 v，返回 v 出现的次数。设计一种结果，支持高效的查询。

解题思路：

- 统计数组中每个值出现的位置，比如 {3, 2, 2, 3, 1}，3 出现的位置为 [0,3]，位置下标升序排列；
- 找 `[l,r]` 范围内 v 出现的个数，就是找到 v 所有出现的位置，看有那些在 `[l,r]` 范围内。
  因为位置下标数组是递增排列的，可以用二分法在下标数组中找到小于 r+1 的个数和小于 l 的个数，其差值就是在 `[l,r]` 范围内值为 v 的数组元素的个数。

## 2 子数组最大累加和

题目描述如下：

返回一个数组中，数组元素有正有负，子数组最大累加和。

解题思路如下：

- 在以 i-1 结尾的最大累加和知道的前提下，考虑以 i 位置结尾的子数组的最大累加和，0 位置的累加和得出，那么就得出任意位置结尾最大累加和的值。
  最大值就是全部子数组中最大累加和的值。

## 3 子矩阵最大累加和

题目描述如下：

返回一个二维数组中，子矩阵最大累加和。

这个题目利用到数组压缩技巧，解决思路如下：

- 从第一行选择子矩阵计算最大累加和，发现就是在求一维数组子数组最大累加和问题；
- 从前两行选择子矩阵计算最大累加和，这时候利用数组压缩技巧，将第一行对应位置的值和第二行对应位置值相加，然后继续求一维数组子数组最大累加和问题；
- 继续考虑 1~3 行、1~n 行、2~2 行、2~n 行、...、n~n 行，全部利用数组压缩技巧转成一维数组解决问题；
- 返回最大累加和。

## 4 不相邻子序列最大累加和

返回一个数组中，选择的数字不能相邻的情况下，最大子序列累加和。

动态规划

递归尝试，假设当前来到 index 位置，考虑 index 位置是否参数累加和计算，返回最大累加和。



严格递推思路：

* 定义 `dp[i]` ，表示 `arr[0...i]` 范围上，在不能取相邻数的情况下，返回所有组合中的最大累加和；
* 累加和有以下三种可能性：
  * 选出的组合，不包含 `arr[i]`，那么 `dp[i] = dp[i-1]`；
  * 选出的组合，只包含 `arr[i]`，那么 `dp[i] = arr[i]`；
  * 选出的组合，包含 `arr[i]`, 且包含 `arr[0...i-2]` 范围上的累加和，那么 `dp[i] = arr[i] + dp[i-2]`；
* 综上所述：`dp[i] = Max{dp[i-1], arr[i] , arr[i] + dp[i-2]}`

## 5 最少糖果数目

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目 。

进阶：在上面的条件上增加，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要分多少糖。



这个题需要使用到预处理结构——上下坡数组。解决思路如下：

- 生成上坡数组，对于数组的 i 位置，`i>i-1`，i 位置设置为前一个位置加 1；`i<=i-1`，i 位置设置为 1；
- 生成下坡数组，对于数组的 i 位置，`i>i+1`，i 设置为后一个位置加 1；`i<=i+1`，i 位置设置为 1；

- 预处理结构生成完毕后，依次遍历上坡和下坡数组，每个位置取最大值，生成上下坡数组，这个数组的累加和就是题目的答案。

代码如下：

```java
static int candy(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int[] up = upArray(arr);
    int[] down = downArray(arr);
    int candy = 0;
    for (int i = 0; i < up.length; i++) {
        candy += Math.max(up[i], down[i]);
    }
    return candy;
}

private static int[] upArray(int[] arr) {
    int[] upArray = new int[arr.length];
    upArray[0] = 1;
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > arr[i - 1]) {
            upArray[i] = upArray[i - 1] + 1;
        } else {
            upArray[i] = 1;
        }
    }
    return upArray;
}

private static int[] downArray(int[] arr) {
    int[] downArray = new int[arr.length];
    downArray[arr.length - 1] = 1;
    for (int i = arr.length - 2; i >= 0; i--) {
        if (arr[i] > arr[i+1]) {
            downArray[i] = downArray[i+1] + 1;
        } else {
            downArray[i] = 1;
        }
    }
    return downArray;
}
```

对于进阶条件，在生成预处理结构是有所改变：

- 生成上坡数组，对于数组的 i 位置，`i>i-1`，i 位置设置为前一个位置加 1；`i=i-1`，i 位置和前一个位置设置成一样；`i<i-1`，i 位置设置为 1；
- 生成下坡数组，对于数组的 i 位置，`i>i+1`，i 设置为后一个位置加 1；`i=i-1`，i 位置和前一个位置设置成一样；`i<=i+1`，i 位置设置为 1；
- 预处理结构生成完毕后，依次遍历上坡和下坡数组，每个位置取最大值，生成上下坡数组，这个数组的累加和就是题目的答案。

### 心得

上下坡数组翻反应了数组中数据的波段变化。

拿上坡数组举例，构建时考察相邻两个数的大小，如果前一个位置比当前位置小，往往会用一个正数或者差值来表明正在上坡，如果小表明到达了另外一个坡的坡底，这时候会将值还原成坡底的代表值（一般为 0，这里为 1）。

## 6 达标数组

生成长度为 size 的达标数组，什么叫达标？
达标：对于任意的 `i<k<j`，满足 `[i]+[j]!=[k]*2`，给定一个正数 size，返回长度为 size 的达标数组。

解题思路：

这个题从小规模往规模靠。

比如已经有了一个长度为 3 的达标数组 `[a,b,c]`，那么 `[2a-1,2b-1,2c-1]` 和 `[2a,2b,2c]` 也都是达标数组。
现在有了两个长度为 3 的达标数组，如果我们能够将其整合到一块，那么就可以得到一个长度为 6 的达标数组，那么它们能不能整合到一块呢？
答案是可以的，`[2a-1,2b-1,2c-1,2a,2b,2c]` ，这个数组左边是偶数域，右边是奇数域，一个奇数加一个偶数不可能是一个数的两倍。

具体构建时，我们可以从 1 个达标数组开始构建，过程如下：

```
[1]
[2*1-1,1*2] -> [1,2]
[1*2-1,2*2-1,1*2,2*2] -> [1,3,2,4] 去掉一个 [1,3,2]
[1*2-1,2*2-1,1*2,2*2] -> [1,3,2,4]
```

代码如下所示：

```java
static int[] makeNo(int size) {
    if (size == 1) {
        return new int[]{1};
    }
    // 用长度为要求一般的基数组进行构建，左边奇数，右边偶数
    int halfSize = (size + 1) / 2;
    int[] base = makeNo(halfSize);
    // base -> 等长奇数达标来
    // base -> 等长偶数达标来
    int[] ans = new int[size];
    int index = 0;
    for (; index < halfSize; index++) {
        ans[index] = base[index] * 2 - 1;
    }
    for (int i = 0; index < size; index++, i++) {
        ans[index] = base[i] * 2;
    }
    return ans;
}

private static boolean isValid(int[] arr) {
    int N = arr.length;
    for (int i = 0; i < N; i++) {
        for (int k = i + 1; k < N; k++) {
            for (int j = k + 1; j < N; j++) {
                if (arr[i] + arr[j] == 2 * arr[k]) {
                    return false;
                }
            }
        }
    }
    return true;
}
```

## 7 交错字符串

给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。

两个字符串 s 和 t 交错的定义与过程如下，其中每个字符串都会被分割成若干非空子字符串：

```
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
交错是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
```

这个题属于动态规划中的样本对应模型。



dp 表的构建思路如下：

- `dp[i][j]` 表示 s1 的前 i 个字符和 s2 的前 j 个字符是否能够交错组成 s3 的前 `i+j` 个字符；
- `dp[i][j]` 为 true 的条件为 `s1[i-1]==s3[i+j-1]` 且 `dp[i-1][j]` 为 true 或 `s2[j-1]==s3[i+j-1]` 且 `dp[i][j-1]` 为 true；
- 可以看出 `(i,j)` 位置的值依赖 `(i-1,j-1)` 位置的值，构建好边界，我们便可以推出整个 dp 表；
- 那么 `dp[s1.length-1][s2.length-1]` 就是我们想要的解。



## 8 大楼轮廓线问题

城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。

每个建筑物的几何信息由数组 buildings 表示，其中三元组 `buildings[i]=[lefti,righti,heighti]` 表示：

`lefti` 是第 i 座建筑物左边缘的 x 坐标。
`righti` 是第 i 座建筑物右边缘的 x 坐标。
`heighti` 是第 i 座建筑物的高度。
你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。

天际线 应该表示为由 “关键点” 组成的列表，格式 `[[x1,y1],[x2,y2],...]` ，并按 x 坐标进行排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

解题思路：

- 从左往右遍历大楼，最大高度的变换产生轮廓线（高度的变换有两种方式，向上增加和向下减少）；

- 在每个大楼的起始 x 和终止 x 可能会发生最大高度变换；

  这里用一个结构来描述某个位置的高度变换：

  ```java
  static class Node {
      public int x;
      public boolean isAdd;
      public int h;
  
      public Node(int x, boolean isAdd, int h) {
          this.x = x;
          this.isAdd = isAdd;
          this.h = h;
      }
  }
  ```

  比如 `Node(3,true,5)` 表示 3 这个位置有一个高度为 5 的向上的变换。

- 找到每个位置的最大高度，依次从左往右遍历这些位置，考察其高度变换是否会产生轮廓线。



来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/the-skyline-problem
