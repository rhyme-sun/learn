# 线段树

线段树是常用的用来维护**区间信息**的数据结构。这里的区间信息是指线段树可以在 `O(logN)` 的时间复杂度内实现单点修改、区间修改、区间求和等操作。

下面通过一个例子来说明线段树这种结构。

简单来说，线段树是一种每次将数组的范围一份为二，直到不能分为止，再用二叉树组织起来的结构。树的每个节点代表了数组中某个连续的区间，完整的一级的节点从左往右合起来就是数组的全部范围（这里划分区间时下标从 1 开始）。树的叶子节点表示数组中某个位置的元素。

比如我们有下面这个数组 [1,5,0,8,1]，将数组拆分成若干个区间，组成线段树结构如下（下标从 1 开始）：

```
          1~5
        /      \
      1~2      3~5
     /  \     /   \
   1~1  2~2  3~3  4~5
   (1)  (5)  (0) /   \
                4~4  5~5
                (8)  (1)
```

如上图所示，树的每个节点表示了数组指定范围，比如上述的 3~5 就表示数组 3~5 范围的树。父节点的范围会等分到左右子节点，直到不能够等分为止。叶子节点存放一个位置的数。线段树的每一层都涵盖了原数组的全部元素。



对于上述树结构可以用数组来表示，**下标从 1 开始**。若原数组长度为 L，那么用来存放线段树结构的数组最多需要 4L 长度。用来表示线段树的数组有以下性质，对于 i 位置的元素，其对于线段树的左子节点数组下标为 `2*i`，右子节点下标为 `2*i+1`，父节点下标为 `i/2`。

## 代码实现

首先来看下，为了存储上述的数组区间信息，线段树包含下面元素：

```java
int n;

private int[] arr;

private int[] sum;

private int[] lazy;

private int[] change;

private boolean[] update;
```

这里有 6 个属性，分别表示：

- n：线段树数据数组长度（即下面 arr 数组的长度）；

- arr：用来存放原始数组数据，下标从 1 开始，因此长度比原数组多 1；
- sum：用来存放线段树每个节点对应区间的累加和，比如 `sum[1]` 就表示线段树根节点代表区间（整个数组）的累加和；
- lazy：对应每个区间累加标志，初始值为 0，比如，`lazy[i]=m`，表示 i 这个区间对应的元素需要全部增加 m，但没有立即累加到累加和数组中；
- change 和 update：配合使用，用来更新线段树节点数据。

### 线段树构造函数

```java
public SegmentTree(int[] origin) {
    // 线段树的下标从 1 开始，所以这里要将长度加 1
    n = origin.length + 1;
    arr = new int[n];
    for (int i = 1; i < n; i++) {
        arr[i] = origin[i - 1];
    }
    // 用来支持脑补概念中，某一个范围的累加和信息
    sum = new int[n << 2];
    // 用来支持脑补概念中，某一个范围沒有往下传递的累加任务
    lazy = new int[n << 2];
    // 用来支持脑补概念中，某一个范围有没有更新操作的任务
    change = new int[n << 2];
    // 用来支持脑补概念中，某一个范围更新任务，更新成了什么
    update = new boolean[n << 2];
}
```

构造函数的入参是原始数组，改造成 arr 数组，从 1 开始，记其长度为 n，sum、lazy、change、update 因为要存放和节点对应的信息，因此长度为 4n。

### 线段树的构建

数据有了数据数组 arr 后，我们就可以用在这个数组的基础上按照线段树的组织方式构建线段树。

构建线段树时从根节点开始，即从数组的 [1-N] 范围开始从上往下构建，并且构建时利用了后序遍历的思想，用左右子节点的区间和得出父节点的区间和。

线段树构建代码：

```java
public void build() {
    // 使用 arr 数组构建线段树，区间范围为 [1~N]，左闭右闭，N 表示 arr 数组中最后一个元素的下标
    // 从线段树的根节点从上往下构建（rt=1）
    build(1, n - 1, 1);
}

/**
  * @param l  线段节点代表区间左范围
  * @param r  线段节点代表区间右范围
  * @param rt 当前区间 [l,r] 对应线段树节点在 sum[] 数组中的位置（下标），
  *           和 l 和 r 合起来表示线段树上的一个节点信息
  */
private void build(int l, int r, int rt) {
    if (l == r) {
        sum[rt] = arr[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(l, mid, rt << 1);
    build(mid + 1, r, rt << 1 | 1);
    pushUp(rt);
}

private void pushUp(int rt) {
    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
}
```

### 区间增加

在原始数组的任意区间 `[l,r]` 增加值 c。

增加的步骤如下：

- 我们称用户需要增加值的区间为任务区间，线段树每个节点对应的区间为节点区间，区间增加操作以每个节点区间作为单位；
- 从线段树的根节点开始，如果任务区间包住了节点区间，就可以在这个节点区间进行操作，不会做任务之外的事情，且任务不下发，任务下发延迟到任务区间包不住节点区间后处理；
- 如果任务区间包不住节点区间，就不能在这个区间操作，因为会修改到任务外的数，这时候就先进行**任务下发**操作，任务下发后在子区间继续进行区间增加任务；
- 最后要将左右子节点更新的状态同步到父节点中，即最后的 pushUp 操作。

代码如下所示：

```java
/**
  * 区间增加
  *
  * @param l 区间左边界
  * @param r 区间右边界
  * @param c 增加的值
  */
public void add(int l, int r, int c) {
    // 从根节点开始考察，下发增加任务
    add(l, r, c, 1, n - 1, 1);
}

/**
  * 将原数组 L~R 范围内数增加 C。
  *
  * @param L  任务区间左边界
  * @param R  任务区间右边界
  * @param C  增加的值
  *
  * @param l  节点区间左范围
  * @param r  节点区间右范围
  * @param rt 当前区间 [l,r] 对应线段树节点在 sum[] 数组中的位置（下标），
  *           和 l 和 r 合起来表示线段树上的一个节点信息
  */
private void add(int L, int R, int C, int l, int r, int rt) {
    // L <= l~r <= R
    // 任务区间如果包含了当前的节点区间，在此范围收集信息，绝不会做任务之外的工作，下级节点暂不下发
    // 包住不下发，是线段树在范围新增能够达到 O(logN) 的本质
    if (L <= l && r <= R) {
        sum[rt] += C * (r - l + 1);
        lazy[rt] += C;
        return;
    }
    // 任务包不住节点区间，拆分区间，分配任务，以前被包住没有下发的旧任务要先下发一级
    int mid = (l + r) >> 1;
    // 下发旧任务信息
    pushDown(rt, mid - l + 1, r - mid);
    // 更新新任务信息
    if (L <= mid) {
        add(L, R, C, l, mid, rt << 1);
    }
    if (R > mid) {
        add(L, R, C, mid + 1, r, rt << 1 | 1);
    }
    pushUp(rt);
}
```

任务下发包括更新任务的下发和增加任务的下发：

- 更新任务下发：
  - 如果当前节点数据有更新，则需要下发任务到子节点；
  - 将左右子节点的更新标志设置为 true；
  - 将父节点的更新值下发到左右子节点；
  - 清空左右子节点的增加信息（lazy 数组对应位置设置为 0）；
  - 修改左右子节点的值（修改 sum 数组中的值）；
  - 更新完毕后，最后要清空当前节点的更新标志。
- 新增任务下发：
  - 如果当前节点中存在旧的新增信息，则需要下发的子节点；
  - 将父节点的增加值下发到左右子节点（lazy）；
  - 将下发的值增加到左右子节点（sum）;
  - 清空当前节点增加标志。


> 注意，任务下发时先进行更新任务的下发，再进行新增任务的下发，因为更新任务需要清空新增任务。

```java
/**
  * 之前的，所有懒增加，和懒更新，从父范围，下发给左右两个子范围
  *
  * @param rt 父级范围对应下标
  * @param ln 左子树元素结点个数
  * @param rn 右子树元素结点个数
  */
private void pushDown(int rt, int ln, int rn) {
    if (update[rt]) {
        update[rt << 1] = true;
        update[rt << 1 | 1] = true;
        change[rt << 1] = change[rt];
        change[rt << 1 | 1] = change[rt];
        lazy[rt << 1] = 0;
        lazy[rt << 1 | 1] = 0;
        sum[rt << 1] = change[rt] * ln;
        sum[rt << 1 | 1] = change[rt] * rn;
        update[rt] = false;
    }
    // 懒信息下发一层
    if (lazy[rt] != 0) {
        lazy[rt << 1] += lazy[rt];
        lazy[rt << 1 | 1] += lazy[rt];
        sum[rt << 1] += lazy[rt] * ln;
        sum[rt << 1 | 1] += lazy[rt] * rn;
        lazy[rt] = 0;
    }
}
```

### 区间修改

区间修改是指将原数组任意区间 `[l,r]` 里的值修改为 c。

区间更新的逻辑和区间新增类似，从线段树的根节点开始，考察任务区间和节点区间的包含关系。如果任务区间能够包住节点区间，那么接在当前节点区间进行更新任务，且任务不下发，下发任务延迟到任务区间包不住节点区间的时候处理。

当任务区间包不住节点区间时，需要先进行任务下发操作，再在子区间进行任务更新操作，子区间任务更新完成后要将子区间的状态同步到父区间。

代码如下所示：

```java
/**
  * 区间更新
  *
  * @param l 区间左边界
  * @param r 区间右边界
  * @param c 修改的值
  */    
public void update(int l, int r, int c) {
    // 从根节点开始考察，下发更新任务
    update(l, r, c, 1, n - 1, 1);
}

/**
  * 在 L~R 范围内将所有元素的值变为 C
  *
  * @param L  增加数组的左边界
  * @param R  增加数组的右边界
  * @param C  增加的值
  * @param l  线段区间左范围
  * @param r  线段区间右范围
  * @param rt 区间范围在数组中的下标
  */
private void update(int L, int R, int C, int l, int r, int rt) {
    // 全包了，更新范围边界
    if (L <= l && r <= R) {
        update[rt] = true;
        change[rt] = C;
        sum[rt] = C * (r - l + 1);
        lazy[rt] = 0;
        return;
    }
    // 包不住，先下发
    int mid = (l + r) >> 1;
    pushDown(rt, mid - l + 1, r - mid);
    if (L <= mid) {
        update(L, R, C, l, mid, rt << 1);
    }
    if (R > mid) {
        update(L, R, C, mid + 1, r, rt << 1 | 1);
    }
    pushUp(rt);
}
```

### 单点修改

单点修改是指修改原数组某个位置上的值。

单点修改的逻辑就很简单了，其相当于修改了左右相等区间范围的值，代码如下：

```java
/**
  * 将 index 位置的更新为 c
  *
  * @param index 更新位置
  * @param c     增加的值
*/
public void change(int index, int c) {
	update(index, index, c);
}
```

### 区间求和查询

区间求和表示查询原数组任意区间 `[l,r]` 范围内的累加和。

其主要的思路和区间新增和区间修改类似。从线段树的根节点开始，当任务区间能够包住节点区间后，直接在节点区间上进行求和任务。如果任务区间包不住节点区间，则先要进行旧任务的下发，再在子节点上进行求和任务。

代码如下所示：

```java
/**
  * 区间求和
  *
  * @param l 区间左边界
  * @param r 区间右边界
  * @return [l,r] 区间累加和
  */
public int query(int l, int r) {
    return query(l, r, 1, n-1, 1);
}

/**
  * 查询 L~R 范围累加和
  *
  * @param L  增加数组的左边界
  * @param R  增加数组的右边界
  * @param l  线段区间左范围
  * @param r  线段区间右范围
  * @param rt 区间范围在数组中的下标
  */
private int query(int L, int R, int l, int r, int rt) {
    if (L <= l && r <= R) {
        return sum[rt];
    }
    int mid = (l + r) >> 1;
    pushDown(rt, mid - l + 1, r - mid);
    int ans = 0;
    if (L <= mid) {
        ans += query(L, R, l, mid, rt << 1);
    }
    if (R > mid) {
        ans += query(L, R, mid + 1, r, rt << 1 | 1);
    }
    return ans;
}
```

## 总结

**线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况**。

上面的描述很抽象，下面给个具体的使用场景。

比如我们需要求数组任意范围的累加和信息，并同时存在对数组区间的新增和更新操作，这时候就可以使用线段树将原本为 `O(K)` 的区间修改或新增时间复杂度优化到 `O(logK)`。

