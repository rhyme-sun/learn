# 滑动窗口

滑动窗口是一个虚拟的结构，其一般要依附于某个数据结构，常见的为数组或者字符串。窗口有左右两个位置的指针（L 和 R），两个位置之间的元素个数就是窗口的宽度。当窗口右侧向右移动一个单位时，相当于有一个元素进入了窗口，当左侧向右移动一个单位时，相当于有一个元素从窗口出去了。

使用滑动窗口解决问题的一般思路为让窗口左右两侧分别在某些条件下移动，每次移动后利用窗口可以提供的信息去求解。

这里的信息是指能够以 `O(1)` 的时间复杂度得到信息，包括：

- 窗口的宽度（窗口内的元素个数，`R-L+1`）；
- 窗口内的最大值；
- 窗口内的最小值。

在获取窗口内的最大值和最小值的时候需要使用**单调双端队列**在窗口每次移动时将窗口内的最大值或最小值的**下标**维护在队列头部。

这里从窗口内获取最大值为例，主要的思路为：

- 首先我们需要一个单调双端队列，因为我们要获得最大值，所以从队列头部到队列尾部元素的值需要从大到小排列；

- 当有一个元素进入窗口时，将其入队，入队前要进行下面操作：

  当队列不为空或者尾部元素下标对应值**小于等于**新入队下标对应值时弹出队列尾部元素。

  相关代码如下：

  ```java
  // 样本数组
  int[] arr;
  // JDK 自带的双端队列
  Deque<Integer> maxQ = new LinkedList<>();
  // 一个元素进入了窗口，需要将此时窗口右侧对应的下标 r 入队
  int r;
  while(!maxQ.isEmpty() && arr[maxQ.peekLast()] <= arr[r]) {
  	maxQ.pollLast();	
  }
  maxQ.addLast(r);
  ```

- 当一个元素从窗口出去时，如果队列头部的元素过期了，则需要将其弹出，过期是指出窗口的元素恰好时此时对了头部的元素。

  这里也说明了为什么队列里要存放下标，而不是存放数组中的值，因为存放值没有办法判断队列中的元素是否过期，存放下标则可以。

  相关代码如下：

  ```java
  // 窗口左侧
  int l;
  if (maxQ.peekFirst() == l) {
      maxQ.pollFirst();
  }
  // 向右移动
  l++;
  ```

## 窗口能够解决问题的特征

- 样本数据一般为数组或者字符串；
- 一般会给一固定个长度的限制条件。

利用滑动窗口实现的算法的时间复杂度一般为 `O(N)`，即窗口从头到尾把数组全部遍历一遍后就得到问题的解了。

## 相关题目

相关题目。

### 绳子覆盖的最大宽度

题目描述如下：

给定一个有序数组 arr，代表坐落在 x 轴上的点，给定一个正数 k，代表绳子的长度，返回绳子最多压中几个点？即使绳子边缘处盖住点也算盖住。

解决思路为：

- 使用滑动窗口，记窗口的左右两侧分别为 L 和 R，让窗口按照下面规则在样本数组上移动：

  - 如果 arr[R]-arr[L]+1 <= k，R 向右侧移动；

  - 如果 arr[R]-arr[L]+1 > k，L 向左移动；

- 每次移动后，记录 L 到 R-1 位置元素个数，统计最大值，直到 R 到达数组末尾。

代码如下所示：

```java
static int maxPoint(int[] arr, int k) {
    if (arr == null || arr.length == 0 || k <= 0) {
        return 0;
    }
    int n = arr.length;
    int l = 0, r = 0;
    int max = 1;
    while (r < n) {
        if (arr[r] - arr[l] <= k) {
            r++;
        } else {
            l++;
        }
        max = Math.max(max, r - 1 - l + 1);
    }
    return max;
}
```

时间复杂度为 `O(N)`，额外空间复杂度为 `O(1)`。

这道题利用了滑动窗口，让窗口左右两侧分别在在某种条件下移动，每次移后利用窗口的宽度去求解。

### 窗口内的最大值

本体可作为模板代码，要可以手写。

问题描述如下：

假设一个固定大小为 W 的窗口，依次划过 arr，返回每一次滑出状况的最大值。例如，arr = [4,3,5,4,3,3,6,7]，W = 3，返回：[5,5,5,4,6,7]。

对于这个问题我们可以使用单调双端队列去实现，代码如下所示：

```java
static int[] max(int[] arr, int w) {
    if (arr == null || arr.length == 0 || w < 1) {
        return null;
    }
    int n = arr.length;
    int[] res = new int[n - w + 1];
    Deque<Integer> maxQ = new LinkedList<>();
    int l = 0, r = 0;
    for (; r < n; r++) {
        // r 入队
        while (!maxQ.isEmpty() && arr[maxQ.peekLast()] <= arr[r]) {
            maxQ.pollLast();
        }
        maxQ.addLast(r);

        if (r > w - 1) {
            // l 出队
            if (maxQ.peekFirst() == l) {
                maxQ.pollFirst();
            }
            l++;
        }
        res[l] = arr[maxQ.peekFirst()];
    }
    return res;
}
```







