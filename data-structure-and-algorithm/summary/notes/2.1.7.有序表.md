# 有序表

所谓有序表，是指这样的线性表，其中所有元素以递增或递减方式有序排列，新增删除数据时会自动调整以维持这种顺序。

有序表有多种实现方式，比如使用平衡二叉搜索树或跳表。有序表所有操作的时间复杂度都是 `O(logN)`，非常高效。



有序表和哈希表的本质区别就是：哈希表的 key 是通过哈希函数散列组织的，而有序表的 key 是按照值的大小组织的。

有序表除了支持哈希表的所有操作之外，还提供了一些由于 key 的有序性可以实现的其他操作。例如：找到最大或最小的 key（first key/last key）、找到小于等于某个 key 的最大的 key（floor key）、找到大于等于某个 key 的最小的 key（ceiling key）。

## 从数据库索引到平衡二叉搜索树

关系型数据库有一个重要的查询优化就是索引，索引可以极大提高检索数据的效率，因为数据在很多情况下都是读多写少，所以查询效率的提高十分关键。

那么怎么设计一种结构来提高检索效率呢，并且在数据新增、更新和删除后同样如此？

我们先来考虑如果没有索引，查询数据的某行时，需要根据过滤的字段值遍历所有行，和对应列上的字段进行比较，如果相等就然后改行，时间复杂度为 O(N)，对于数据库查询来讲这是一个很慢的复杂度。

我们认为数据库里的任何列，其值之间是可以排序的（即两两之间可以比大小）。

我们知道二叉搜索树的概念，对于树上的某个节点，其左子树上的节点都小于它，其右子树上的节点都大于它。

如果我们将一个列的全部值按照搜索二叉树的结构去组织。我们在查询某个值时，从根节点出发，通过判断大小决定搜索的方向（排除一半错误的方向），查询数据的复杂度就变成了 `O(logN)`。后序对于数据的新增、修改和删除只要维护好这个二叉搜索树的结构，就可以一直享受 `O(logN)` 查询复杂度。

上述的二叉搜索树就可以看作是一个索引，但这个索引存在一个问题。

极端情况下，二叉搜索树所有节点可能都在其左边界或右边界上，这样二叉树的结构就退化成了链表结构，时间复杂度又退化成了 `O(logN)`。推广到一般情况就是，在节点个数一定的情况下，二叉树的高度决定了二叉树的检索效率，高度越高，检索效率就越低。

那么怎么解决二叉搜索树由于高度变高而查询效率变低的问题呢？

答案是通过左旋和右旋让二叉树变平衡。

> 平衡的概念或者平衡二叉树的概念就是二叉树任意节点的左右子树都是平衡的，其高度差不会超过 1。当二叉搜索树是平衡的，那么检索树上的任意节点次数都不会超过 `O(logN)`。

左旋的过程如下：

- 节点 A 左旋，让其向左边倒；
- 将 A 的右孩子 B 提上来，节点 A 作为 B 的左孩子，B 原本的左孩子作为节点 A 的右孩子；

```
   A                                              B
  / \                                            / \ 
 M   B                                          A   C 
    / \           --节点 A 左旋-->              / \  / \
   N   C                                      M  N T  K
      / \
      T  K
```

右旋的过程如下：

- 节点 A 右旋，然其向右边倒；
- 将 A 的左孩子 B 提上来，节点 A 作为 B 的右孩子，B 原本的右孩子作为作为节点 A 的左孩子；

```
      A                                            B
     / \                                          / \
    B   M                                        C   A
   / \            --节点 A 右旋-->               / \  / \
  C   N                                        K  T N  M
 / \
 K T
```

左旋和右旋一定是基于某个节点来讨论的，节点往哪个方向旋转，就让其往哪个方向倒。

**左旋和右旋最重要的一点性质就是其不会破坏二叉树原本的搜索性**。因此我们可以使用旋转让二叉搜索树在高度过大时，变成一棵**平衡二叉搜索树**。

单个节点旋转的时间复杂度为 `O(1)`。



> 我们能不能使用类似于哈希表的结构来构建索引呢？
>
> 我们知道通过 key 去从哈希表获取 value，时间复杂度为 `O(1)`。虽然时间复杂度好，但哈希表建立的是某个 key 到 某个value 的映射关系，它不能够高效处理范围查询的情况。类似于范围检索，还是要依赖一个有序的结构才能够做到高效。

## AVL 树

平衡二叉搜索树有不同的实现，比如 AVL 树，红黑树，它们主要的不同点在于其对平衡性的定义不同，但对平衡性的调整可以达到 `O(logN)`。

AVL 树有着最严格的平衡性定义，其平衡性的定义和平衡二叉树一样，任何节点左右子树的高度差都不超过 1。

AVL 树在新增和删除节点的过程中伴随着调整动作（新增时如果树不平衡了会伴随着旋转操作，删除时会选择合适的节点替代删除的节点），保证 AVL 树的平衡性。

关于新增，在构建节点时会出现不平衡的情况，AVL 局部上破坏平衡性的情况有四种（从某个节点出发）：

- LL：表示节点的左子树的左边过高导致树不平衡；

  ```
      A                             B
     /                             / \ 
    B     --LL，右旋 A-->          C   A    
   /                  
  C                       
  ```

- LR：表示节点的左子树的右边过高导致树不平衡；

  ```
    A                                             A                             C
   /                                             /                             / \  
  B      --LL，让 C 想办法到 A 位置，先左旋 B-->     C         --再右旋 A-->        B   A
   \                                           /
    C                                         B
  ```

- RL：表示节点的右子树的左边过高导致树不平衡；

  ```
  A                                              A                               C 
   \                                              \                             / \ 
    B   --RL,让 C 想办法到 A 位置，先右旋 B-->         C      --再左旋 A-->          A  B
   /                                                \
  C                                                  B
  ```

- RR：表示节点的右子树的右边过高导致树不平衡。

  ```
  A                                B
   \                              / \
    B     --RR，左旋 A-->         A   C
     \
      C
  ```

> 注意：在创建树时可能会出现 LL 和 LR 同时存在的情况，要去做 LL 调整，因为 LR 调整后可能不平衡；也可能出现 RL 和 RR 同时存在的情况，要去做 RR 调整，因为做 RL 调整可能会不平衡。

关于删除，删除节点时会下面操作：

- 如果删除的节点没有左右孩子，直接删除就好；
- 如果删除的节点有右孩子没有左孩子，让右孩子顶上去；
- 如果删除的节点有左孩子没有右孩子，让左孩子顶上去；
- 如果删除的节点既有左孩子也有右孩子，让左子树的最右节点或让右子树的最左节点顶上去。

删除某个节点后，会按照上述规则选择某个节点替代删除的节点，节点成功删除后，替代节点原位置往上的父级节点需要依次调整保持树的平衡性。

### 代码实现

AVL 树代码如下所示：

```java
public class AVLTreeMap {

    static class AVLNode<K extends Comparable<K>, V> {

        public K k;
        public V v;
        public AVLNode<K, V> l;
        public AVLNode<K, V> r;
        /**
         * 平衡因子，当前节点作为根节点时树的高度
         */
        public int h;

        public AVLNode(K key, V value) {
            k = key;
            v = value;
            h = 1;
        }
    }

    static class AVLTree<K extends Comparable<K>, V> {

        private AVLNode<K, V> root;
        private int size;

        public AVLTree() {
            root = null;
            size = 0;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                return false;
            }
            AVLNode<K, V> lastNode = findLastIndex(key);
            return lastNode != null && key.compareTo(lastNode.k) == 0 ? true : false;
        }

        public void put(K key, V value) {
            if (key == null) {
                return;
            }
            AVLNode<K, V> lastNode = findLastIndex(key);
            if (lastNode != null && key.compareTo(lastNode.k) == 0) {
                lastNode.v = value;
            } else {
                size++;
                root = add(root, key, value);
            }
        }

        public void remove(K key) {
            if (key == null) {
                return;
            }
            if (containsKey(key)) {
                size--;
                root = delete(root, key);
            }
        }

        public V get(K key) {
            if (key == null) {
                return null;
            }
            AVLNode<K, V> lastNode = findLastIndex(key);
            if (lastNode != null && key.compareTo(lastNode.k) == 0) {
                return lastNode.v;
            }
            return null;
        }

        public K firstKey() {
            if (root == null) {
                return null;
            }
            AVLNode<K, V> cur = root;
            while (cur.l != null) {
                cur = cur.l;
            }
            return cur.k;
        }

        public K lastKey() {
            if (root == null) {
                return null;
            }
            AVLNode<K, V> cur = root;
            while (cur.r != null) {
                cur = cur.r;
            }
            return cur.k;
        }

        public K floorKey(K key) {
            if (key == null) {
                return null;
            }
            AVLNode<K, V> lastNoBigNode = findLastNoBigIndex(key);
            return lastNoBigNode == null ? null : lastNoBigNode.k;
        }

        public K ceilingKey(K key) {
            if (key == null) {
                return null;
            }
            AVLNode<K, V> lastNoSmallNode = findLastNoSmallIndex(key);
            return lastNoSmallNode == null ? null : lastNoSmallNode.k;
        }

        public int size() {
            return size;
        }

        /**
         * 新增节点
         *
         * @param cur   从 cur 出发
         * @param key   新增节点的 key
         * @param value 新增节点的 value
         * @return cur 这棵树的新头部
         */
        private AVLNode<K, V> add(AVLNode<K, V> cur, K key, V value) {
            if (cur == null) {
                return new AVLNode<>(key, value);
            } else {
                if (key.compareTo(cur.k) < 0) {
                    cur.l = add(cur.l, key, value);
                } else {
                    cur.r = add(cur.r, key, value);
                }
                cur.h = getHeight(cur);
                return maintain(cur);
            }
        }

        /**
         * 删除树节点
         *
         * @param cur 从 cur 出发
         * @param key 删除节点的 key
         * @return cur 这棵树的新头部
         */
        private AVLNode<K, V> delete(AVLNode<K, V> cur, K key) {
            if (key.compareTo(cur.k) > 0) {
                cur.r = delete(cur.r, key);
            } else if (key.compareTo(cur.k) < 0) {
                cur.l = delete(cur.l, key);
            } else {
                if (cur.l == null && cur.r == null) {
                    cur = null;
                } else if (cur.l == null && cur.r != null) {
                    cur = cur.r;
                } else if (cur.l != null && cur.r == null) {
                    cur = cur.l;
                } else {
                    AVLNode<K, V> des = cur.r;
                    while (des.l != null) {
                        des = des.l;
                    }
                    cur.r = delete(cur.r, des.k);
                    des.l = cur.l;
                    des.r = cur.r;
                    cur = des;
                }
            }
            if (cur != null) {
                cur.h = getHeight(cur);
            }
            return maintain(cur);
        }

        /**
         * 在节点变动时，调整树的使其平衡
         */
        private AVLNode<K, V> maintain(AVLNode<K, V> cur) {
            if (cur == null) {
                return null;
            }
            int leftHeight = cur.l != null ? cur.l.h : 0;
            int rightHeight = cur.r != null ? cur.r.h : 0;
            if (Math.abs(leftHeight - rightHeight) > 1) {
                if (leftHeight > rightHeight) {
                    int leftLeftHeight = cur.l != null && cur.l.l != null ? cur.l.l.h : 0;
                    int leftRightHeight = cur.l != null && cur.l.r != null ? cur.l.r.h : 0;
                    if (leftLeftHeight >= leftRightHeight) {
                        cur = rightRotate(cur);
                    } else {
                        cur.l = leftRotate(cur.l);
                        cur = rightRotate(cur);
                    }
                } else {
                    int rightLeftHeight = cur.r != null && cur.r.l != null ? cur.r.l.h : 0;
                    int rightRightHeight = cur.r != null && cur.r.r != null ? cur.r.r.h : 0;
                    if (rightRightHeight >= rightLeftHeight) {
                        cur = leftRotate(cur);
                    } else {
                        cur.r = rightRotate(cur.r);
                        cur = leftRotate(cur);
                    }
                }
            }
            return cur;
        }

        private AVLNode<K, V> rightRotate(AVLNode<K, V> cur) {
            AVLNode<K, V> left = cur.l;
            cur.l = left.r;
            left.r = cur;
            cur.h = getHeight(cur);
            left.h = getHeight(left);
            return left;
        }

        private AVLNode<K, V> leftRotate(AVLNode<K, V> cur) {
            AVLNode<K, V> right = cur.r;
            cur.r = right.l;
            right.l = cur;
            cur.h = getHeight(cur);
            right.h = getHeight(right);
            return right;
        }

        /**
         * 获取节点的高度
         */
        private int getHeight(AVLNode<K, V> cur) {
            return Math.max((cur.l != null ? cur.l.h : 0), (cur.r != null ? cur.r.h : 0)) + 1;
        }

        private AVLNode<K, V> findLastIndex(K key) {
            AVLNode<K, V> pre = root;
            AVLNode<K, V> cur = root;
            while (cur != null) {
                pre = cur;
                if (key.compareTo(cur.k) == 0) {
                    break;
                } else if (key.compareTo(cur.k) < 0) {
                    cur = cur.l;
                } else {
                    cur = cur.r;
                }
            }
            return pre;
        }

        private AVLNode<K, V> findLastNoSmallIndex(K key) {
            AVLNode<K, V> ans = null;
            AVLNode<K, V> cur = root;
            while (cur != null) {
                if (key.compareTo(cur.k) == 0) {
                    ans = cur;
                    break;
                } else if (key.compareTo(cur.k) < 0) {
                    ans = cur;
                    cur = cur.l;
                } else {
                    cur = cur.r;
                }
            }
            return ans;
        }

        private AVLNode<K, V> findLastNoBigIndex(K key) {
            AVLNode<K, V> ans = null;
            AVLNode<K, V> cur = root;
            while (cur != null) {
                if (key.compareTo(cur.k) == 0) {
                    ans = cur;
                    break;
                } else if (key.compareTo(cur.k) < 0) {
                    cur = cur.l;
                } else {
                    ans = cur;
                    cur = cur.r;
                }
            }
            return ans;
        }
    }
}
```

## Size Balanced Tree

SB 树的平衡性规定如下，任何叔叔节点作为根节点的树的节点个数不能比侄子节点作为根节点的树的节点个数要少。比如对于下面的二叉树：

```
     A
   /   \
  B     C
 / \   / \
D  E   F  G
```

B 是 F 和 G 的叔叔节点，以 B 为根节点的树的节点个数不能比以 F 或 G 作为根节点的树的节点个数要小。



SB 破坏平衡性的情况有四种（针对某个节点而言）：

- LL：节点的左儿子的左儿子的节点数量比节点右儿子的节点数量多；
- LR：节点的左儿子的右儿子的节点数量比节点右儿子的节点数量多；
- RL：节点的右儿子的左儿子的节点数量比节点左儿子的节点数量多；
- RR：节点的右儿子的右儿子的节点数量比节点左儿子的节点数量多。

SB 树调整行为和 AVL 树一致，但需要重新考察子节点发生改变的节点是否具有平衡性。

SB 树的调整行为的优势或者说是平衡因子的优势在于，SB 树节点删除时可以先不去调整，延迟到新增节点的时候再去调整，也可以保证整个棵树的平衡性。

如果删除的时候不去调整树，那么有可能整棵树会退化成链表结构，但前提时在一直没有节点新增的情况下才会出现这种极端情况。既然没有节点新增，假设删除期间节点最多个数为 N，那么即使退化成链表，时间复杂度依然为 `O(logN)`（这里的 N 代表删除期间最多的节点个数）。**可以看出 SB 树的想法是，能够少调整就少调整，即使少调整了，依然能够得到一个较好的时间复杂度**。

### 代码实现

SB 树的代码如下所示：

```java
public class SizeBalancedTreeMap {

    static class SBTNode<K extends Comparable<K>, V> {

        public K key;
        public V value;
        public SBTNode<K, V> l;
        public SBTNode<K, V> r;
        /**
         * 以该节点为根节点的树的节点数量
         */
        public int size;

        public SBTNode(K key, V value) {
            this.key = key;
            this.value = value;
            size = 1;
        }
    }

    static class SizeBalancedTree<K extends Comparable<K>, V> {

        private SBTNode<K, V> root;

        public int size() {
            return root == null ? 0 : root.size;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            SBTNode<K, V> lastNode = findLastIndex(key);
            return lastNode != null && key.compareTo(lastNode.key) == 0 ? true : false;
        }

        public void put(K key, V value) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            SBTNode<K, V> lastNode = findLastIndex(key);
            if (lastNode != null && key.compareTo(lastNode.key) == 0) {
                lastNode.value = value;
            } else {
                root = add(root, key, value);
            }
        }

        public void remove(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            if (containsKey(key)) {
                root = delete(root, key);
            }
        }

        public K getIndexKey(int index) {
            if (index < 0 || index >= this.size()) {
                throw new RuntimeException("invalid parameter.");
            }
            return getIndex(root, index + 1).key;
        }

        public V getIndexValue(int index) {
            if (index < 0 || index >= this.size()) {
                throw new RuntimeException("invalid parameter.");
            }
            return getIndex(root, index + 1).value;
        }

        public V get(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            SBTNode<K, V> lastNode = findLastIndex(key);
            if (lastNode != null && key.compareTo(lastNode.key) == 0) {
                return lastNode.value;
            } else {
                return null;
            }
        }

        public K firstKey() {
            if (root == null) {
                return null;
            }
            SBTNode<K, V> cur = root;
            while (cur.l != null) {
                cur = cur.l;
            }
            return cur.key;
        }

        public K lastKey() {
            if (root == null) {
                return null;
            }
            SBTNode<K, V> cur = root;
            while (cur.r != null) {
                cur = cur.r;
            }
            return cur.key;
        }

        public K floorKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            SBTNode<K, V> lastNoBigNode = findLastNoBigIndex(key);
            return lastNoBigNode == null ? null : lastNoBigNode.key;
        }

        public K ceilingKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            SBTNode<K, V> lastNoSmallNode = findLastNoSmallIndex(key);
            return lastNoSmallNode == null ? null : lastNoSmallNode.key;
        }
        
        private SBTNode<K, V> maintain(SBTNode<K, V> cur) {
            if (cur == null) {
                return null;
            }
            int leftSize = cur.l != null ? cur.l.size : 0;
            int leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
            int leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
            int rightSize = cur.r != null ? cur.r.size : 0;
            int rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
            int rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
            if (leftLeftSize > rightSize) {
                cur = rightRotate(cur);
                cur.r = maintain(cur.r);
                cur = maintain(cur);
            } else if (leftRightSize > rightSize) {
                cur.l = leftRotate(cur.l);
                cur = rightRotate(cur);
                cur.l = maintain(cur.l);
                cur.r = maintain(cur.r);
                cur = maintain(cur);
            } else if (rightRightSize > leftSize) {
                cur = leftRotate(cur);
                cur.l = maintain(cur.l);
                cur = maintain(cur);
            } else if (rightLeftSize > leftSize) {
                cur.r = rightRotate(cur.r);
                cur = leftRotate(cur);
                cur.l = maintain(cur.l);
                cur.r = maintain(cur.r);
                cur = maintain(cur);
            }
            return cur;
        }

        private SBTNode<K, V> rightRotate(SBTNode<K, V> cur) {
            SBTNode<K, V> leftNode = cur.l;
            cur.l = leftNode.r;
            leftNode.r = cur;
            leftNode.size = cur.size;
            cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
            return leftNode;
        }

        private SBTNode<K, V> leftRotate(SBTNode<K, V> cur) {
            SBTNode<K, V> rightNode = cur.r;
            cur.r = rightNode.l;
            rightNode.l = cur;
            rightNode.size = cur.size;
            cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
            return rightNode;
        }

        private SBTNode<K, V> findLastIndex(K key) {
            SBTNode<K, V> pre = root;
            SBTNode<K, V> cur = root;
            while (cur != null) {
                pre = cur;
                if (key.compareTo(cur.key) == 0) {
                    break;
                } else if (key.compareTo(cur.key) < 0) {
                    cur = cur.l;
                } else {
                    cur = cur.r;
                }
            }
            return pre;
        }

        private SBTNode<K, V> findLastNoSmallIndex(K key) {
            SBTNode<K, V> ans = null;
            SBTNode<K, V> cur = root;
            while (cur != null) {
                if (key.compareTo(cur.key) == 0) {
                    ans = cur;
                    break;
                } else if (key.compareTo(cur.key) < 0) {
                    ans = cur;
                    cur = cur.l;
                } else {
                    cur = cur.r;
                }
            }
            return ans;
        }

        private SBTNode<K, V> findLastNoBigIndex(K key) {
            SBTNode<K, V> ans = null;
            SBTNode<K, V> cur = root;
            while (cur != null) {
                if (key.compareTo(cur.key) == 0) {
                    ans = cur;
                    break;
                } else if (key.compareTo(cur.key) < 0) {
                    cur = cur.l;
                } else {
                    ans = cur;
                    cur = cur.r;
                }
            }
            return ans;
        }

        /**
         * 新增节点
         *
         * @param cur   从 cur 出发
         * @param key   新增节点的 key
         * @param value 新增节点的 value
         * @return cur 这棵树的新头部
         */
        private SBTNode<K, V> add(SBTNode<K, V> cur, K key, V value) {
            if (cur == null) {
                return new SBTNode<K, V>(key, value);
            } else {
                cur.size++;
                if (key.compareTo(cur.key) < 0) {
                    cur.l = add(cur.l, key, value);
                } else {
                    cur.r = add(cur.r, key, value);
                }
                return maintain(cur);
            }
        }

        /**
         * 删除树节点
         *
         * @param cur 从 cur 出发
         * @param key 删除节点的 key
         * @return cur 这棵树的新头部
         */
        private SBTNode<K, V> delete(SBTNode<K, V> cur, K key) {
            cur.size--;
            if (key.compareTo(cur.key) > 0) {
                cur.r = delete(cur.r, key);
            } else if (key.compareTo(cur.key) < 0) {
                cur.l = delete(cur.l, key);
            } else {
                if (cur.l == null && cur.r == null) {
                    cur = null;
                } else if (cur.l == null && cur.r != null) {
                    cur = cur.r;
                } else if (cur.l != null && cur.r == null) {
                    cur = cur.l;
                } else {
                    SBTNode<K, V> pre = null;
                    SBTNode<K, V> des = cur.r;
                    while (des.l != null) {
                        pre = des;
                        des = des.l;
                        des.size--;
                    }
                    if (pre != null) {
                        pre.l = des.r;
                        des.r = cur.r;
                    }
                    des.l = cur.l;
                    des.size = des.l.size + (des.r == null ? 0 : des.r.size) + 1;
                    cur = des;
                }
            }
            // cur = maintain(cur);
            return cur;
        }

        private SBTNode<K, V> getIndex(SBTNode<K, V> cur, int kth) {
            if (kth == (cur.l != null ? cur.l.size : 0) + 1) {
                return cur;
            } else if (kth <= (cur.l != null ? cur.l.size : 0)) {
                return getIndex(cur.l, kth);
            } else {
                return getIndex(cur.r, kth - (cur.l != null ? cur.l.size : 0) - 1);
            }
        }
    }
}
```

## 跳表

跳表不是平衡二叉搜索树结构。结构如下所示：

![](../images/2.1.7.SkipList.png)

跳表的构建过程如下：

- 首先跳表有一个起始节点，每当有一个新的节点加入时，需要从起始节点的最高层出发进行构建；

- 跳表的每个节点都有若干个层次，至少有一层，起始节点的层次和层次最高的节点相同；

- 每当创建一个新的节点时，会循环以 0.5 的概率给跳表增加层次（从 1 开始加），比如说当前节点随机增加到了第 5 层，接下来看这个节点怎么加入现有的跳表结构当中：

  从起始节点的最高层出发（**不能从第 5 层出发，从最高层出发才能有 O(logN)，如果头结点没有 5 层需先增加到 5 层**），往右在每层中找新增值应该新增的位置（新增的位左边比它小，右边比它大，即找到小于新增值最右侧位置，然后将新增值放到这个位置的右侧），根据找到的结果，分为以下几种情况：

  - 如果没有找到并且当前层数大于 5，不处理（该节点在大于 5 的层新增不进去），从起始节点的下一层继续考察；
  - 如果没有找到并且当前层数等于 5，起始节点的第 5 层指向新增节点，新增节点的第 5 层指向头节点第 5 层之前指向的节点，从起始节点的下一层继续考察；
  - 如果找到了并且当前层数大于 5，不处理，从起始节点的下一层继续考察；
  - 如果找到了并且当前层数等于 5，将新增节点的第五层放到找到节点的右侧（相当于做一个单链表的插入操作，将找到节点第 5 层节点指向新增节点，将新增节点第 5 层指向找到节点之前第 5 层指向的节点），然后从找到节点的第 4 层继续考察。

当我们查找某个 key 时，从起始节点的**最高层**出发，依次找小于等于这个 key 的最右侧节点，没有就接着从起始节点的下一层开始找，有就从找到节点的下一层开始找，直到找到了第 1 层。

从起始节点最高开始找小于它的最大值，直到找到第一层，这一过程的时间复杂度为 `O(logN)`。

跳表一共有 N 个节点，跳表的层数为 `logN + 1`，每层查询和新增节点都要从最高层处理到最低层，且每层只处理一次，因此时间复杂度为 `O(logN)`。

下面证明一下跳表节点数 N 和层数 K 的关系：

``` 
层数    每层节点数
1      N = N/2^0        每个节点都有第一层，所以第一层的节点个数为 N
2      N/2 = N/2^1		有 1/2 的节点可以增加一层，所以第二层层的节点个数为 N/2
3      N/4 = N/2^2      在 N/2 个有第二层的节点中，由于 1/2 的概率增加一层，所以第三层的节点个数为 N/4
4      N/8 = N/2^3      ....
...    ...              ....
K      1=N/N=N/2^logN   根据规律，认为第 N 层的节点有 1 个

f(x) = N/2^(x-1)，将 x=K 带入得 N/2^(K-1) = N/2^logN
即层数和节点个数的关系为 K = logN + 1 
```

### 代码实现

跳表的代码如下所示：

```java
package learn.algorithm.structure.orderedlist;

import java.util.ArrayList;

/**
 * 跳表
 */
public class SkipListMap {

    static class SkipListNode<K extends Comparable<K>, V> {

        public K key;
        public V val;
        /**
         * 每层的下个节点，下标代表层数
         */
        public ArrayList<SkipListNode<K, V>> nextNodes;

        public SkipListNode(K k, V v) {
            key = k;
            val = v;
            nextNodes = new ArrayList<>();
        }

        public boolean isKeyLess(K otherKey) {
            //  otherKey == null -> false
            return otherKey != null && (key == null || key.compareTo(otherKey) < 0);
        }

        public boolean isKeyEqual(K otherKey) {
            return (key == null && otherKey == null)
                    || (key != null && otherKey != null && key.compareTo(otherKey) == 0);
        }

    }

    static class SkipList<K extends Comparable<K>, V> {

        /**
         * 以 0.5 的概率怎加层数
         */
        private static final double PROBABILITY = 0.5;
        private SkipListNode<K, V> head;
        private int size;
        private int maxLevel;

        public SkipList() {
            head = new SkipListNode<>(null, null);
            head.nextNodes.add(null); // 0
            size = 0;
            maxLevel = 0;
        }

        /**
         * 从起始节点的最高层开始找到小于 key 的最右侧节点
         * 从最高层找到最底层
         *
         * @param key key
         * @return 小于 key 的最右侧节点
         */
        private SkipListNode<K, V> mostRightLessNodeInTree(K key) {
            if (key == null) {
                return null;
            }
            int level = maxLevel;
            SkipListNode<K, V> cur = head;
            while (level >= 0) {
                cur = mostRightLessNodeInLevel(key, cur, level--);
            }
            return cur;
        }

        /**
         * 现在来到的节点是 cur，来到了 cur 的 level 层，在 level 层上，找到小于 key 最后一个节点并返回
         *
         * @param key   key
         * @param cur   cur
         * @param level cur 当前层次
         * @return level 层小于 key 的最大值
         */
        private SkipListNode<K, V> mostRightLessNodeInLevel(K key,
                                                            SkipListNode<K, V> cur,
                                                            int level) {
            SkipListNode<K, V> next = cur.nextNodes.get(level);
            while (next != null && next.isKeyLess(key)) {
                cur = next;
                next = cur.nextNodes.get(level);
            }
            return cur;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                return false;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key);
        }

        public void put(K key, V value) {
            if (key == null) {
                return;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> find = less.nextNodes.get(0);
            if (find != null && find.isKeyEqual(key)) {
                find.val = value;
            } else {
                size++;
                int newNodeLevel = 0;
                while (Math.random() < PROBABILITY) {
                    newNodeLevel++;
                }
                // newNodeLevel
                while (newNodeLevel > maxLevel) {
                    head.nextNodes.add(null);
                    maxLevel++;
                }
                SkipListNode<K, V> newNode = new SkipListNode<K, V>(key, value);
                for (int i = 0; i <= newNodeLevel; i++) {
                    newNode.nextNodes.add(null);
                }
                int level = maxLevel;
                SkipListNode<K, V> pre = head;
                while (level >= 0) {
                    // level 层中，找到最右的 < key 的节点
                    pre = mostRightLessNodeInLevel(key, pre, level);
                    if (level <= newNodeLevel) {
                        newNode.nextNodes.set(level, pre.nextNodes.get(level));
                        pre.nextNodes.set(level, newNode);
                    }
                    level--;
                }
            }
        }

        public V get(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key) ? next.val : null;
        }

        public void remove(K key) {
            if (containsKey(key)) {
                size--;
                int level = maxLevel;
                SkipListNode<K, V> pre = head;
                while (level >= 0) {
                    pre = mostRightLessNodeInLevel(key, pre, level);
                    SkipListNode<K, V> next = pre.nextNodes.get(level);
                    // 1）在这一层中，pre 下一个就是 key
                    // 2）在这一层中，pre 的下一个 key 是大于要删除的 key
                    if (next != null && next.isKeyEqual(key)) {
                        // free delete node memory -> C++
                        // level : pre -> next(key) -> ...
                        pre.nextNodes.set(level, next.nextNodes.get(level));
                    }
                    // 在 level 层只有一个节点了，就是默认节点 head
                    if (level != 0 && pre == head && pre.nextNodes.get(level) == null) {
                        head.nextNodes.remove(level);
                        maxLevel--;
                    }
                    level--;
                }
            }
        }

        public K firstKey() {
            return head.nextNodes.get(0) != null ? head.nextNodes.get(0).key : null;
        }

        public K lastKey() {
            int level = maxLevel;
            SkipListNode<K, V> cur = head;
            while (level >= 0) {
                SkipListNode<K, V> next = cur.nextNodes.get(level);
                while (next != null) {
                    cur = next;
                    next = cur.nextNodes.get(level);
                }
                level--;
            }
            return cur.key;
        }

        public K ceilingKey(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null ? next.key : null;
        }

        public K floorKey(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key) ? next.key : less.key;
        }

        public int size() {
            return size;
        }
    }
}
```

## 红黑树

红黑树具有以下定义：

- 每一个节点不是红就是黑；

- 头节点为黑节点，叶子节点为黑（叶子节点包括空节点）；

- 节点有红有黑的情况下，两个红不能相邻；
- 任何节点节点往下走的每一条路径黑节点的个数相同。

平衡因子定义为：对于红黑树，从任何节点出发，最长的路径是最接近红黑相间的，最短的路径是最接近全为黑节点的。要求最长的路径节点个数不能超过最短路径节点个数的两倍。

红黑树的优势在于其是一种积压结构，将调整行为积累下来，减少了调整次数，减少使用时的 IO 压力。 

## 相关题目

### 子数组累加和达标问题

题目描述如下：

给定一个数组 arr，和两个整数 a 和 b（a<=b），求 arr 中有多少个子数组，累加和在 `[a,b]` 这个范围上。返回达标的子数组数量。

这个题有利用归并排序的解，这里介绍用有序表的解法，思路如下：

- 首先考虑在数组的 i 位置，以 i 结尾的子数组的累加和在 `[a, b]` 范围的数量怎么求？

  假设数组从 0~i 位置的累加和为 s，那么用 s 减去某个前缀和（比如 j）得到的结果就是 j~i 这个子数组的累加和。因此求以 i 结尾的子数组累加和在 [a, b] 中的问题可以转换为求 i 前面的前缀和在 `[s-b, s-a]` 范围内的数量。

- 那么现在的问题就转换成了从 i 位置前缀和在 `[s-b, s-a]` 范围内的数量，具体统计时可以同下面方法：
  - 找到小于 `s-a+1` 的个数 m；
  - 找到小于 `s-b` 的个数 n；
  - `m-n` 的值就是前缀和在  `[s-b, s-a]` 范围内的数量。

- 现在我们需要一种结构，能够快速的解决上述转换后的问题。

  比如我们有这样的前缀和数组：`[0, -1, 3, 5, 2, 3, 1, 2, 8, 2, 6]`，现在想从数组中找到小于 7 的值的个数。

  最简单的可以使用遍历的方法去做，沿途统计小于 7 的数量即可，但这样的时间复杂度为 `O(N)`。

  为了解决这个问题，先引入一个二叉搜索树的结构，每个节点有两个值（a,b），a 代表累加和数组中的值，b 代表以其为根节点的子树的节点的数量。用上述样本构建的结构如下所示（先不考虑二叉树的平衡性）：

  ```
        (0,11)   
         /   \
    (-1,1)  (3,9)
            /  \
         (2,4) (5,3)
          /       \
       (1,1)     (7,2)
                  /
                (6,1)
  ```

  有了上述结构后，我们再来考虑求小于 7  的个数，统计方法为：

  - 从根节点（0,11）开始，发现 0<7，向右走，同时记录根节点数量减去右子节点（3,9）节点数量的值（11-9=2）；

  - 来到了（3,9）节点，3<7，继续向右走，同时记录该节点数量减去右子节点（5,3）节点数量的值（9-3=6）；

  - 来到了（5,3）节点，5<7，继续向右走，同时记录该节点数量减去右子节点（7,2）节点数量的值（3-2=1）；

  - 来到了（7,1）节点，7=7，停止走动，记录该节点左子节点（6,1）的节点数量 1；

    > 走到某个节点时发现还可以继续走，但没有可以走的位置了，也停止走动

  - 最后将记录的数量累加得 2+6+1+1=10，就为小于 7 的数量个数。

  可以看出用上述方法统计小于某个数的个数，时间复杂的和数的深度有关，如果二叉树时平衡的，时间复杂度为 `O(logN)`。

  因此我们需要一种有序表结构，能快速地帮助我们找到小于某个值的数量，并保证平衡性。

代码如下所示：

```java
static int countRangeSum(int[] nums, int lower, int upper) {
    // 有序表，能够方便我们快速地东累加和数组中找到小于某个值的个数
    SizeBalancedTreeSet treeSet = new SizeBalancedTreeSet();
    long sum = 0;
    int ans = 0;
    treeSet.add(0);
    for (int i = 0; i < nums.length; i++) {
        // i 位置之前（包括 i）的累加和
        sum += nums[i];
        long a = treeSet.lessKeySize(sum - lower + 1);
        long b = treeSet.lessKeySize(sum - upper);
        ans += a - b;
        // 加入累加和
        treeSet.add(sum);
    }
    return ans;
}
```

这里使用 SB 树进行改造，并支持查找小于某个数的数量，代码如下：

```java 
static class SBTNode {
    public long key;
    public SBTNode l;
    public SBTNode r;
    /**
      * 记录和当前 key 不相同的节点数量（以当前节点为根节点的数的物理节点总数），作为 SB Tree 的平衡因子
      */
    public long size;
    /**
      * 以当前节点为根节点的数的逻辑节点总数
      */
    public long all;

    public SBTNode(long k) {
        key = k;
        size = 1;
        all = 1;
    }
}

static class SizeBalancedTreeSet {

    private SBTNode root;
    /**
      * 记录某个 key 是否出现过
      */
    private HashSet<Long> set = new HashSet<>();

    public void add(long sum) {
        boolean contains = set.contains(sum);
        root = add(root, sum, contains);
        set.add(sum);
    }

    /**
      * 返回小于某个 key 的数量
      */
    public long lessKeySize(long key) {
        SBTNode cur = root;
        long ans = 0;
        while (cur != null) {
            if (key == cur.key) {
                return ans + (cur.l != null ? cur.l.all : 0);
            } else if (key < cur.key) {
                cur = cur.l;
            } else {
                ans += cur.all - (cur.r != null ? cur.r.all : 0);
                cur = cur.r;
            }
        }
        return ans;
    }

    public long moreKeySize(long key) {
        return root != null ? (root.all - lessKeySize(key + 1)) : 0;
    }

    private SBTNode add(SBTNode cur, long key, boolean contains) {
        if (cur == null) {
            return new SBTNode(key);
        } else {
            cur.all++;
            if (key == cur.key) {
                return cur;
            } else { // 还在左滑或者右滑
                if (!contains) {
                    cur.size++;
                }
                if (key < cur.key) {
                    cur.l = add(cur.l, key, contains);
                } else {
                    cur.r = add(cur.r, key, contains);
                }
                return maintain(cur);
            }
        }
    }

    private SBTNode maintain(SBTNode cur) {
        if (cur == null) {
            return null;
        }
        long leftSize = cur.l != null ? cur.l.size : 0;
        long leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
        long leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
        long rightSize = cur.r != null ? cur.r.size : 0;
        long rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
        long rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
        if (leftLeftSize > rightSize) {
            cur = rightRotate(cur);
            cur.r = maintain(cur.r);
            cur = maintain(cur);
        } else if (leftRightSize > rightSize) {
            cur.l = leftRotate(cur.l);
            cur = rightRotate(cur);
            cur.l = maintain(cur.l);
            cur.r = maintain(cur.r);
            cur = maintain(cur);
        } else if (rightRightSize > leftSize) {
            cur = leftRotate(cur);
            cur.l = maintain(cur.l);
            cur = maintain(cur);
        } else if (rightLeftSize > leftSize) {
            cur.r = rightRotate(cur.r);
            cur = leftRotate(cur);
            cur.l = maintain(cur.l);
            cur.r = maintain(cur.r);
            cur = maintain(cur);
        }
        return cur;
    }

    private SBTNode rightRotate(SBTNode cur) {
        long same = cur.all - (cur.l != null ? cur.l.all : 0) - (cur.r != null ? cur.r.all : 0);
        SBTNode leftNode = cur.l;
        cur.l = leftNode.r;
        leftNode.r = cur;
        leftNode.size = cur.size;
        cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
        // all modify
        leftNode.all = cur.all;
        cur.all = (cur.l != null ? cur.l.all : 0) + (cur.r != null ? cur.r.all : 0) + same;
        return leftNode;
    }

    private SBTNode leftRotate(SBTNode cur) {
        long same = cur.all - (cur.l != null ? cur.l.all : 0) - (cur.r != null ? cur.r.all : 0);
        SBTNode rightNode = cur.r;
        cur.r = rightNode.l;
        rightNode.l = cur;
        rightNode.size = cur.size;
        cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
        // all modify
        rightNode.all = cur.all;
        cur.all = (cur.l != null ? cur.l.all : 0) + (cur.r != null ? cur.r.all : 0) + same;
        return rightNode;
    }
}
```

### 窗口内的中位数

有一个滑动窗口：L 是滑动窗口最左位置、R 是滑动窗口最右位置，一开始 L 和 R 都在数组左侧；

想知道每一个窗口状态的中位数（数学计算上的中位数）。

我们知道窗口内的最大值和最小值可以使用单调双端队列实现，要求中位数，需要借助有序表这种结构，以 O(logN) 的时间复杂度从有序表中取出某个位置的数。

基本思路如下：

- 和上个题目一样，这里的有序表使用 SB 数来实现，窗口内可能存在相同的数，这里采取的做法是封装下窗口内的数字，值相同是用下标去判断值的大小：

  ```java
  static class Node implements Comparable<Node> {
      public int index;
      public int value;
  
      public Node(int i, int v) {
          index = i;
          value = v;
      }
  
      @Override
      public int compareTo(Node o) {
          return value != o.value ? Integer.valueOf(value).compareTo(o.value)
              : Integer.valueOf(index).compareTo(o.index);
      }
  }
  ```

- 在窗口向右移动时，将进入窗口的元素放入有序表中，从窗口出去的元素从有序表中移除；

- 每次都去有序表获取中间位置的元素，窗口宽度为偶数的话获取中间两个数，求中位数，奇数的话获取中间那个数即可；

代码如下所示：

```java
static double[] medianSlidingWindow(int[] nums, int k) {
    SizeBalancedTreeMap<Node> map = new SizeBalancedTreeMap<>();
    for (int i = 0; i < k - 1; i++) {
        map.add(new Node(i, nums[i]));
    }
    double[] ans = new double[nums.length - k + 1];
    int index = 0;
    for (int i = k - 1; i < nums.length; i++) {
        map.add(new Node(i, nums[i]));
        if (map.size() % 2 == 0) {
            Node upmid = map.getIndexKey(map.size() / 2 - 1);
            Node downmid = map.getIndexKey(map.size() / 2);
            ans[index++] = ((double) upmid.value + (double) downmid.value) / 2;
        } else {
            Node mid = map.getIndexKey(map.size() / 2);
            ans[index++] = (double) mid.value;
        }
        map.remove(new Node(i - k + 1, nums[i - k + 1]));
    }
    return ans;
}
```

有序表的结构和上述 SB 树结构类似。

### 读写都为 `O(logN)` 的列表

设计一个顺序表包含如下三个方法：

> 顺序表是指，表中元素的排列顺序和元素的放入顺序一致（自然时序）。

```java
// 把 num 加入到 index 位置
void add(int index, int num);

// 取出 index 位置的值
int get(int index);

// 把 index 位置上的值删除
void remove(int index);
```

要求三个方法时间复杂度 `O(logN)`。

上述方法在 `ArrayList` 中有，但 add 和 remove 时间复杂度为 `O(N)`；上述方法在 `LinkedList` 中也有，找到某个 index 位置做操作的时间复杂度为 `O(N)`。

可以使用有序表去实现上三个方法。

这里选择 SB 树实现的有序表去实现上述功能，底层数据结构为二叉树，**规定对于二叉树的任意子树，左子树的自然时序要早于根节点早于右子树，且左旋和右旋时不会影响自然时序**。

然后对于新增、删除和查询方法的实现和 SB Tree 中方法逻辑类似。不同的是 SB Tree 使用 key 去找到要操作的元素，这里需要使用 index 找到要操作的元素。

实现的代码如下：

```java
static class SBTNode<V> {
    public V value;
    public SBTNode<V> l;
    public SBTNode<V> r;
    public int size;

    public SBTNode(V v) {
        value = v;
        size = 1;
    }
}

static class SBTList<V> {

    private SBTNode<V> root;

    public void add(int index, V num) {
        SBTNode<V> cur = new SBTNode<V>(num);
        if (root == null) {
            root = cur;
        } else {
            if (index <= root.size) {
                root = add(root, index, cur);
            }
        }
    }

    public V get(int index) {
        SBTNode<V> ans = get(root, index);
        return ans.value;
    }

    public void remove(int index) {
        if (index >= 0 && size() > index) {
            root = remove(root, index);
        }
    }

    public int size() {
        return root == null ? 0 : root.size;
    }

    private SBTNode<V> add(SBTNode<V> root, int index, SBTNode<V> cur) {
        if (root == null) {
            return cur;
        }
        root.size++;
        int leftAndHeadSize = (root.l != null ? root.l.size : 0) + 1;
        if (index < leftAndHeadSize) {
            root.l = add(root.l, index, cur);
        } else {
            root.r = add(root.r, index - leftAndHeadSize, cur);
        }
        root = maintain(root);
        return root;
    }

    private SBTNode<V> remove(SBTNode<V> root, int index) {
        root.size--;
        int rootIndex = root.l != null ? root.l.size : 0;
        if (index != rootIndex) {
            if (index < rootIndex) {
                root.l = remove(root.l, index);
            } else {
                root.r = remove(root.r, index - rootIndex - 1);
            }
            return root;
        }
        if (root.l == null && root.r == null) {
            return null;
        }
        if (root.l == null) {
            return root.r;
        }
        if (root.r == null) {
            return root.l;
        }
        SBTNode<V> pre = null;
        SBTNode<V> suc = root.r;
        suc.size--;
        while (suc.l != null) {
            pre = suc;
            suc = suc.l;
            suc.size--;
        }
        if (pre != null) {
            pre.l = suc.r;
            suc.r = root.r;
        }
        suc.l = root.l;
        suc.size = suc.l.size + (suc.r == null ? 0 : suc.r.size) + 1;
        return suc;
    }

    private SBTNode<V> get(SBTNode<V> root, int index) {
        int leftSize = root.l != null ? root.l.size : 0;
        if (index < leftSize) {
            return get(root.l, index);
        } else if (index == leftSize) {
            return root;
        } else {
            return get(root.r, index - leftSize - 1);
        }
    }

    private SBTNode<V> rightRotate(SBTNode<V> cur) {
        SBTNode<V> leftNode = cur.l;
        cur.l = leftNode.r;
        leftNode.r = cur;
        leftNode.size = cur.size;
        cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
        return leftNode;
    }

    private SBTNode<V> leftRotate(SBTNode<V> cur) {
        SBTNode<V> rightNode = cur.r;
        cur.r = rightNode.l;
        rightNode.l = cur;
        rightNode.size = cur.size;
        cur.size = (cur.l != null ? cur.l.size : 0) + (cur.r != null ? cur.r.size : 0) + 1;
        return rightNode;
    }

    private SBTNode<V> maintain(SBTNode<V> cur) {
        if (cur == null) {
            return null;
        }
        int leftSize = cur.l != null ? cur.l.size : 0;
        int leftLeftSize = cur.l != null && cur.l.l != null ? cur.l.l.size : 0;
        int leftRightSize = cur.l != null && cur.l.r != null ? cur.l.r.size : 0;
        int rightSize = cur.r != null ? cur.r.size : 0;
        int rightLeftSize = cur.r != null && cur.r.l != null ? cur.r.l.size : 0;
        int rightRightSize = cur.r != null && cur.r.r != null ? cur.r.r.size : 0;
        if (leftLeftSize > rightSize) {
            cur = rightRotate(cur);
            cur.r = maintain(cur.r);
            cur = maintain(cur);
        } else if (leftRightSize > rightSize) {
            cur.l = leftRotate(cur.l);
            cur = rightRotate(cur);
            cur.l = maintain(cur.l);
            cur.r = maintain(cur.r);
            cur = maintain(cur);
        } else if (rightRightSize > leftSize) {
            cur = leftRotate(cur);
            cur.l = maintain(cur.l);
            cur = maintain(cur);
        } else if (rightLeftSize > leftSize) {
            cur.r = rightRotate(cur.r);
            cur = leftRotate(cur);
            cur.l = maintain(cur.l);
            cur.r = maintain(cur.r);
            cur = maintain(cur);
        }
        return cur;
    }
}
```

## 总结

> 积压结构
>
> 像 ArrayList、HashMap 和这里提到的 SB 树，红黑树就是一种积压结构。积压顾名思义就是将压力积累下来，通过一次性的处理去释放解决。
>
> 比如 ArrayList 和 HashMap 的扩容问题，其是在容量到达阈值后，将容量扩大一倍，而不是一开始容量唯一，新增一个，增加一个容量。其将扩容的压力积累下来，一次性释放，在继续积累。虽然在一次释放的过程存在一定的时间代价，但均摊下来的时间复杂度是低的。
>
> SB 树和红黑树也是这样，不过其面对的压力是平衡性，其将平衡性的调整压力积累下来，一次性调整。
>
> 而本文介绍的 AVL 树就不是积压结构，对于每次的删除和新增都需要调整，使得树保持平衡性。为什么数据库索引里没有用 AVL 树，而使用红黑树、B+ 树等这些积压结构呢？
>
> 这是考虑到磁盘 IO 很慢，频繁地更新结构会导致 IO 便频繁。而积压结构相当于将 IO 操作打包了，一次性解决，能够有效地提升效率。
