# 类与命名空间

类：构成程序的主体。

名称空间：以树形结构组织类，隔离类，同一名称空间下类名唯一，不同名称空间类名可重复。

```c#
using System;

namespace HelloWorld
{
    public class Point 
    {
        public int x, y;
        public Point(int x, int y) 
        {
            this.x = x;
            this.y = y;
        }
    }
}
```

> 引用名称空间快捷键 `Crtl + .`

## 类库的引用

- DLL 引用（黑盒引用）

  [(7条消息) VS2019没有添加引用选项，不显示程序集_eyys的博客-CSDN博客](https://blog.csdn.net/weixin_43788859/article/details/112443821)

  NuGet 添加对 DLL 的引用：NuGet 打包多个所需的引用类库，不用自己处理依赖关系。

  [(7条消息) Visual Studio 设置NuGet的国内镜像_P了个F的博客-CSDN博客](https://blog.csdn.net/ypfnet/article/details/108276103)



- 项目引用（白盒引用，引用源代码）

  一个项目可以包含在多个 Solution 中，Project 重用。

## 类

类是对显示世界的抽象得到的结果。

- 事物包括物质（属性）和运动（方法）；
- 建模是一个去伪存真，由表及里的过程。



对象也叫实例，是类经过实例化的在内存中的实体。



引用变量和实例的关系

孩子与气球

气球不一定由孩子牵着

多个孩子可以使用各自的绳子牵着同一个气球，也都可以通过一根绳子牵着气球。





### 类的三大成员

- 属性

  存储数据，组合起来表示当前对象的状态。

- 方法

  表示对象能够做什么。

- 事件

  类或对象通知其他类或对象的机制，C# 特有。善用事件机制十分重要。



某些特殊的类在成员的侧重点不同：

- 模型类或对象重在属性，如 Entity Framework；
- 工具类重在方法，如 Math，Console；
- 通知类重在事件，如 Timer。



### 静态成员和实例成员

类的成员，不用实例化就可以访问。

对象成员，实例化后访问。

绑定，指的是编译器将把成员和一个类或对象关联起来。









### 示例

1. NuGet 添加对 EntityFramework 的引用；
2. 右击项目添加 New Items；
3. 选择 Data -> ADO.NET Entity Data Model
4. 链接数据库，选择表，生成操作表的实体。



### 析构函数

```c#
~Student()
{
    ....
}
```

### 静态构造器

```c#
class Student
{
    public static int Amount;
    static Student()
    {
        Amount = 100;
    }
}
```







### 创建对象

```c#
Student stu = new Student(1, "Alice");

Type t = typeof(Student);
object o = Activator.CreateInstance(t, 1, "Alice");

Student stu = t as stu;
```

## 类的声明和访问级别

类在名称空间里声明。

在类内部声明类——成员类。

在 C# 和 Java 里声明即定义。在 C++ 里声明（头文件）和定义（cpp 文件）是分开的，也可以都放到头文件中。





类的修饰符

- new
- public
- protected
- internal
- private
- abstract
- sealed
- static



没有任何修饰符等于加了 internal。在同一个项目里可以正常访问。public 可以跨项目引用访问。每个项目编译结果就是一个 Assembly（程序集）。

常见的程序集有两种 dll 和 exe。



## 类的继承和成员访问

类在功能上的扩展。

只能有一个基类，但可以实现多个接口。

sealed 类不能被继承。

子类的访问级别不能超过父类的访问级别。



实例构造器是不被继承的。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        Car car = new Car();
        car.Owner = "Alice";
    }
}


class Vehicle
{
    public string Owner { get; set; }

    public Vehicle(string owner)
    {
        Owner = owner;
    }
}

class Car : Vehicle
{
    public Car() : base("Foo")
    {

    }

    // or

    public Car(string owner) : base(owner)
    {
    }
}
```

### 类成员的访问级别

类成员的访问级别是以类的访问级别为上限的。

C# 成员的默认访问级别为 private，类的默认访问级别为 internal。





### 面向对象的实现风格

Class-based

Prototype-based



### 重写和多态

父 virtual 子 override

没有添加上面关键字则是隐藏。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        Vehicle v = new Car();
        v.Run();
        Console.WriteLine(v.Speed); 
    }
}

class Vehicle
{

    private int _speed;

    public virtual int Speed
    {
        get
        { 
            return _speed;
        }

        set
        { 
            _speed = value;
        }
    }
    public virtual void Run()
    {
        Console.WriteLine("I'm runing");
    }
}

class Car : Vehicle
{

    public override int Speed
    {
        get
        {
            return 10;
        }
    }

    public override void Run()
    {
        Console.WriteLine("Car is running");
    }
}
```



## 抽象类

```c#
abstract class Vehicle
{
    public abstract void Run();
}

class Car : Vehicle
{
    public override void Run
    {
        Console.WriteLine("Car is running");
    }
}
```



## 接口

接口——供需双方都遵守的契约。

### 单元测试

依赖反转。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        var fan = new DeskFan(new PowerSupply());
        var res = fan.Work();
        Console.WriteLine(res);
    }
}

public interface IPowerSupply
{
    int GetPower();
}

public class PowerSupply : IPowerSupply
{
    public int GetPower()
    {
        return 110;
    }
}

public class DeskFan
{
    private IPowerSupply _powerSupply;

    public DeskFan(IPowerSupply powerSupply)
    {
        _powerSupply = powerSupply; 
    }

    public string Work()
    { 
        int power = _powerSupply.GetPower();
        if (power <= 0)
        {
            return "Won't work.";
        }
        else if (power < 100)
        {
            return "Slow";
        }
        else if (power < 200)
        {
            return "Work fine.";
        }
        else
        {
            return "Warning!";
        }
    }
}
```

xUnit 和 Moq

```c#
public class InterfaceExampleTests
{
    [Fact]
    public void PowerSupplyLowerThanZero()
    {
        var mock = new Mock<IPowerSupply>();
        mock.Setup(ps => ps.GetPower()).Returns(() => 0);
        var powerSupply = mock.Object;
        var fan = new DeskFan(powerSupply);

        var expected = "Won't work.";
        var actual = fan.Work();
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void PowerSupplyHigerThan200()
    {
        var mock = new Mock<IPowerSupply>();
        mock.Setup(ps => ps.GetPower()).Returns(() => 220);
        var powerSupply = mock.Object;
        var fan = new DeskFan(powerSupply);

        var expected = "Warning!";
        var actual = fan.Work();
        Assert.Equal(expected, actual);
    }
}
```



### 接口隔离原则

接口隔离原则。

服务调用者不会多要，不要使用胖接口（包含调用者使用不到的功能）。



单一职责原则。

服务提供者不会多给。

### 接口显式实现

接口不直接将接口暴露出去。



```c#
interface IGentleman
{
    void Love();
}

interface IKiller
{
    void Kill();
}

class WarmKiller : IGentleman,IKiller
{
    public void Love()
    {}
    
    public void Kill()
    {}
    
    // 显式实现，只有 IKiller 的对象可以访问
    public void IKiller.Kill()
    {}
}

static void Main()
{
    IKiller killer = new WarmKiller();
    killer.Kill();
    kill.Love(); // Can't access.
    
    var wk = (IGentleman) killer;
    wk.Love();
}
```



### 反射

以不变应万变，更松的耦合。

```c#
static void Main()
{
    ITank tank = new HeavyTank();
    
   	var t = tank.GetType();
    object o = Activator.CreateInstance(t);
    
    MethodInfo fireMi = t.GetMethodInfo("Fire");
    MethodInfo runMi = t.GetMethodInfo("Run");
    
    fireMi.Invoke(o, null);
    runMi.Invoke(o, null);
}

interface ITank
{
    void Fire();
    void Run();
}

class HeavyTank : ITank
{}
```



依赖注入。

Microsoft.Extensions.DependencyInjection

```c#
static void Main()
{
    var sc = new ServiceCollection();
    sc.AddScope(typeof(ITank), typeof(HeavyTank));
    // 依赖注入，自动将 Driver 的 IVehicle 初始化
    sc.AddScope(typeof(IVehicle), typeof(Car));
    sc.AddScope<Driver>();
    var sp = sc.BuildServiceProvider();
    
    ITank tank = sp.GetService<ITank>();
    tank.Fire();
    tank.Run();
    
    var driver = sp.GetService<Driver>();
    driver.Drive();
}

class Driver
{
    private IVehicle _vehicle;
    public Driver(IVehicle vehicle)
    {
        _vehicle = vehicle;
    }
    
    public void Drive()
    {
        _vehicle.Run();
    }
}

interface IVehicle
{
    void Run();
}
```

 

插件式编程。不和主体程序一起编译，和可以作为扩展和主体程序一起工作。

主体程序：BabyScroller

```c#
var folder = Path.Combine(Environment.CurrentDirectory, "Animals");
var files = Directory.GetFiles(folder);

var animalTypes = new List<Type>();
foreach (var file in files)
{ 
    var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(file);
    var types = assembly.GetTypes();
    foreach (var type in types)
    {
        if (type.GetInterfaces().Contains(typeof(IAnimals)))
        {
            var attri = type.GetCustomAttributes(false);
            var isUnfinished = type.GetCustomAttributes(false).Any(a => a.GetType() == typeof(UnfinishedAttribute));
            if (!isUnfinished)
            {
                animalTypes.Add(type);
            }
        }
    }
       
}

while (true)
{
    for (int i = 0; i < animalTypes.Count; i++)
    {
        Console.WriteLine($"{i+1}. {animalTypes[i].Name}");
    }

    Console.WriteLine();
    Console.WriteLine("Please choose animal.");
    int index = int.Parse(Console.ReadLine());
    if (index > animalTypes.Count || index < 1)
    {
        Console.WriteLine("No such animal,Try again!");
        continue;
    }

    Console.WriteLine("How many times?");
    int times = int.Parse(Console.ReadLine());
    var t = animalTypes[index - 1];
    var o = Activator.CreateInstance(t);
    var a = o as IAnimals;
    a.Voice(times);
}
```

SDK：BabyScroller.SDK，定义接口和属性，限制第三方的实现规格。

```c#
namespace BabyScoller.SDK
{
    public interface IAnimals
    {
        void Voice(int times);
    }
}
```

```c#
namespace BabyScoller.SDK
{
    public class UnfinishedAttribute : Attribute
    {
    }
}
```

扩展类库：Animals.Lib

```c#
namespace Animals.Lib
{
    public class Cat:IAnimals
    {
        public void Voice(int times)
        {
            for (int i = 0; i < times; i++)
            {
                Console.WriteLine("喵喵...");
            }
        }

    }
}
```

```c#
namespace Animals.Lib
{
    public class Dog:IAnimals
    {
        public void Voice(int times)
        {
            for (int i = 0; i < times; i++)
            {
                Console.WriteLine("汪汪...");
            }
        }
    }
}
```

```c#
namespace Animals.Lib
{
    [Unfinished]
    public class Sheep : IAnimals
    {
        public void Voice(int times)
        {
            throw new NotImplementedException();
        }
    }
}
```

## 泛型

为什么需要泛型，避免成员膨胀或者类型膨胀。

泛型类型、泛型成员。

泛型接口。

```c#
interface IUnique<T>
{
    T ID {get; set;}
}

class Student<T>:IUnique<T>
{
    public T ID {get; set;}
    public string Name {get; set;}
}

class Car:IUnique<ulong>
{
    public ulong ID {get; set;}
}

static void Main()
{
    Student<uint> stu = new Student<uint>();
    stu.ID = 1;
    stu.Name = "Alice";
}
```

泛型方法：

```c#
static T[] Merge<T>(T[] a, T[] b)
{
    // ....
}
```

泛型委托：

```c#
static void Main()
{
    // 没有返回值的委托
    Action<string> a = Say;
    a();
    
    Action<int> b = Mul();
    b();
    
    // 有返回值的委托
    Func<int,int,int> c = Add;
    c(1, 1);
    
    Func<double,double,double> d = Add;
    d(1.1, 1.1);
    
    Func<int,int,int> e = (double a, double b) => {return a + b};
    Func<int,int,int> f = (a, b) => a + b;
}

static void Say(string str)
{
    
}

static void Mul(int x)
{
    
}

static int Add(int a, int b)
{
    return a + b;
}

static double Add(double a, double b)
{
    return a + b;
}
```

## partial 类

同一名称空间下。

EntityModel

```c#
public partial class Book
{
    public int ID {get; set;}
}

// 同一名称空间下
public partial class Book
{
    public string Name {get; set;}
}
```

## 枚举

```c#
enum Level
{
    Employee, // 0 
    Manager = 100,  
    Boss,     // 101
    BigBoss,  // 102
}

enum Skill
{
    Drive = 1,
    Cook = 2,
    Program = 4,
    Swim = 8,
}

class Person
{
    public Skill Skill {get; set;}
}

static void Main()
{
    var person = new Person();
    // 枚举类型的比特位用法
    person.Skill = Skill.Drive | Skill.Cook | Skill.Program | Skill.Swim; // 15
    var canSwim = (person.Skill & Skill.Swim) == Skill.Swim;
}
```





## 结构体

值类型。



可实现接口，不能派生自类或结构体。

结构体不能有显式的无参构造器，允许有显式的有参构造器。

```c#
struct Student
{
    public int ID {get; set;}
}

static void Main()
{
    // stu 值在栈上
    Student stu = new Student();
    stu.ID = 1;
    
    // 装箱，obj 执行的对象的值在堆上
    object obj = stu;
    // 拆箱
    Student stu2 = (Student) obj;
    
    // 值传递，会拷贝产生副本
    stu = stu2;
}
```



