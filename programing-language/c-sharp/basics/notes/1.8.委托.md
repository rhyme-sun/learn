# 委托

委托（delegate）是函数指针的升级版。



函数指针。

```c
typeof int (* Calc)(int a, int b);


int Add(int a, int b)
{
   return a +b;
}

int main()
{
    int x = 100;
    int y = 200;
   	int z = 0;
    
    z = Add(x, y);
    
    Calc funcPoint = &Add;
    z = funcPoint(x, y);
}
```



一切皆地址。

变量（数据）是以某个地址为起点的一一段内存中存储的值。

函数（算法）是以某个地址为起点的一段内存中锁存储的一组机器语言指令。



直接调用：通过函数名调用，CPU 通过函数名获取函数所在地址执行并返回。

间接调用： 通过指针来调用函数，CPU 通过读取函数指针存储的值获得函数所在地址并开始执行。



委托。



```c#
class Calculator
{
    public void Report()
    {
        
    }
    
    public int Add(int a, int b)
    {
        return a + b;
    }
}

static void Main()
{
    Calculator calculator = new Calculator();
    // Action 委托，没有返回值
    Action action = new Action(calculator.Report);
    
    calculator.Report();
    action.Invoke();
    // 简便写法
    action();
 
    // Func 委托，有返回值，<返回值类型，参数 1 类型，参数 2 类型>
    Func<int,int,int> func = new Func<int,int,int>(calculator.Add);
    
    int x = 100;
    int y = 200;
    calculator.Add(x, y);
    func.Invoke(x, y);
    func(x, y);
}
```





## 委托的声明

自定义委托。



 委托是一种类，是一种数据类型。它的声明方式和一般的的类不相同。其也声明在名称空间里。

 委托所封装的方法必须类型兼容。返回值类型和参数列表委托声明和被委托的方法保持一致。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        Calculator calculator = new Calculator();
        Calc calc = new Calc(calculator.Add);
		calc += calculator.Sub;
        
        double x = 100;
        double y = 200;
        calculator.Add(x, y);

        calc.Invoke(x, y);
        calc(x, y);
    }
}

public delegate double Calc(double x, double y);

class Calculator
{
    public double Add(double x, double y)
    {
        return x + y;
    }

    public double Sub(double x, double y)
    {
        return x - y;
    }
}
```



## 委托的一般使用

把方法当做参数传递给另一个方法。

模板方法：结余外部指定的方法来产生结果。相当于填空题，位于代码中间位置，委托有返回值。

```c#
static void Main()
{
    ProductFactory productFactory = new ProductFactory();
    WrapFactory wrapFactory = new WrapFactory();
    
    Func<Product> func1 = new Func<Product>(productFactory.MakePizza);
    Func<Product> func2 = new Func<Product>(productFactory.MakeCar);
    
    Product product1 = wrapFactory.WrapProduct(func1);
    Product product2 = wrapFactory.WrapProduct(func2);
}

class Product
{
    public string Name(get; set);
}

class Box
{
    public Product Product(get; set);
}

class WrapFactory
{
    public Box WrapProcduct(Func<Product> getProduct)
    {
        Box box = new Box();
        Product product = getProduct.Invoke();
        box.Product = product;
       	return box;
    }
}

class ProductFactory
{
    public Product MakePizza()
    {
        Product pizza = new Product();
        pizza.Name = "pizza";
        return pizza;
    }
    
    public Product MakeCar()
    {
        Product car = new Product();
        car.Name = "car";
        return car;
    }
}
```

回调方法：调用指定外部方法。相当于流水线，常位于代码结尾，委托无返回值。

```c#
public Box WrapProcduct(Func<Product> getProduct, Action successCallback, Action failCallback)
{
}
```



委托难精通，容易使用，功能强大，一旦被滥用则后果严重。

缺点：

- **委托是方法级别的耦合**，现实工作中要慎之又慎；
- 可读性下降、增加 debug 难度；
- 把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读；
- 委托使用不当有可能造成内存泄漏和程序性能下降。





## 委托的高级使用

多播委托，一个委托封装多个方法。

```c#
static void Main()
{
    Hello hello = new Hello();
    
    Action action1 = new Action(hello.Report);
    Action action2 = new Action(hello.Report);
    
    // 单播委托
    action1.Invoke();
    action2.Invoke();
    
    // 多播委托
    action1 += action2;
    action1.Invoke();
}

class Hello
{
    public void Report()
    {
        Console.WriteLine("A");
    }
}
```



隐式异步调用。

```c#
static void Main()
{
    Hello hello = new Hello();
    
    Action action1 = new Action(hello.Report);
    Action action2 = new Action(hello.Report);
 	   
  	// 参数是执行成功和执行失败的回调方法
    action1.BeginInvoke(null, null);
    action2.BeginInvoke(null, null);
}

class Hello
{
    public void Report()
    {
        Console.WriteLine("A");
    }
}
```



显示异步调用

```c#
static void Main()
{
    Hello hello = new Hello();
 	
    Thread thread1 = new Thread(new ThreadStart(hello.Report));
    Thread thread2 = new Thread(new ThreadStart(hello.Report));
    
    thread1.Start();
    thread2.Start();
    
    Task task1 = new Task(new Action(hello.Report));
    Task task2 = new Task(new Action(hello.Report));
    task1.Start();
    task2.Start();
}

class Hello
{
    public void Report()
    {
        Console.WriteLine("A");
    }
}
```



有了委托为什么还要事件。



事件更加安全，事件成员是能用在 += 和 -= 操作符右侧。而委托成员可以通过 . 操作符访问 Invoke 方法，导致逻辑触发不受控制，会出现借刀杀人的情况。

为了解决 public 委托字段在类的外部被滥用的问题，所以推出了 event 字段，限制了事件成员在类外部被使用的操作符。



事件的的本质是委托字段的一个包装器。这个包装器对委托字段的访问其限制作用——对外界隐藏了委托实例的大部分功能，仅暴露添加/移除事件处理器的功能。



