# 事件

是对象或类具备通知能力的**成员**。

对象 O 拥有一个事件 E 表示：当 E 发生时，O 有能力通知别的对象。

事件用于对象或类间的动作协调和信息传递。



事件相关术语：

- **事件的订阅者**，也可以叫做事件消息的接受者、事件的响应者、事件的处理者、被事件通知的对象；
- **事件参数**，也可以叫做事件信息、事件数据

事件所用于客户端程序，这类程序经常是用户通过事件来驱动的。

事件模型的五个组成部分：

- 事件的拥有者（event source，对象）
- 事件成员（event，成员）
- 事件订阅者（响应者）（event subscriber，对象）
- 事件处理器（event handler，成员），本质上是一个回调函数
- 事件订阅，把事件和事件处理器关联一起，本质上是一种以委托类型为基础的**约定**。

一定是事件的拥有者的内部逻辑触发了拥有的事件。

## 事件的使用

示例

```c#
internal class Program
{
    static void Main(string[] args)
    {
        // 事件拥有者
        Timer timer = new Timer();
        timer.Interval = 1000;
        // 事件订阅者
        Boy boy = new Boy();
        // 事件订阅
        timer.Elapsed += boy.Handle;
        timer.Start();
        Console.ReadLine(); 
    }
}

class Boy
{
    internal void Handle(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine("Jump!");
    }
}
```



事件拥有者作为事件订阅者的一个成员（字段）。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        Form form = new Form();
        Controller controller = new Controller(form);
        form.ShowDialog();
    }
}

class Controller
{
    private Form form;

    public Controller(Form form)
    {
        this.form = form;
        form.Click += this.ClickForm;
    }

    private void ClickForm(object sender, EventArgs e)
    {
        this.form.Text = DateTime.Now.ToString();
    }
}
```

最常用 + 事件不同的挂接方式。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        MyForm1 form = new MyForm1();
        form.ShowDialog();
    }
}

class MyForm1 : Form
{
    private TextBox textBox;
    private Button button;

    public MyForm1()
    {
        this.textBox = new TextBox();
        this.button = new Button();
        this.Controls.Add(button);
        this.Controls.Add(textBox);

        // 方式一
        this.button.Click += Button_Click;
        // 方式二
        this.button.Click = new EventHandler(Button_Click);
        // 方式三
        this.button.Click = delegate(object sennder, EventArgs args)
        {
            this.textBox.Text = "Hello World!";
        }
        // 方式四
        this.button.Click = (object sennder, EventArgs args) => {
             this.textBox.Text = "Hello World!";
        }
        this.button.Click = (sennder, args) => {
             this.textBox.Text = "Hello World!";
        }
        
        this.button.Text = "Cilck Me";
        this.button.Top = 20;
    }

    private void Button_Click(object sender, EventArgs e)
    {
        this.textBox.Text = "Hello World!";
    }
}
```



事件拥有者同时也是事件响应者

```c#
internal class Program
{
    static void Main(string[] args)
    {
        MyForm form = new MyForm();
        form.Click += form.ClickForm;
        form.ShowDialog();
    }


}

class MyForm : Form
{
    public void ClickForm(object sender, EventArgs e)
    {
        this.Text = DateTime.Now.ToString();
    }
}
```



一个事件可以挂接多个事件处理器，一个事件处理器也可以被多个符合约定的事件挂接。

## 事件的声明

自定义事件，顾客点餐。

```c#
internal class Program
{
    static void Main(string[] args)
    {
        Customer customer = new Customer(); 
        Waiter waiter = new Waiter();
        customer.OrderEventHandler += waiter.Action;

        customer.Action();
        Console.ReadLine();
    }
}

public delegate void OrderEventHandler(Customer sender, OrderEventArgs e);

public class OrderEventArgs
{
    public string DishName { get; set; }
    public string Size { get; set; }
}
public class Customer
{
    public double Bill { get; set; }

    // 事件成员
    // 完整声明
    private OrderEventHandler orderEventHandler;
    public event OrderEventHandler OrderEventHandler
    {
        add
        { 
            this.orderEventHandler += value;
        }

        remove 
        {
            this.orderEventHandler -= value;
        }  
    }
    
    // 简化声明
    public event OrderEventHandler Order;
    // 委托字段，使用委托也可以正确执行这里的点餐逻辑
	// public OrderEventHandler Order;
    
    public void PayTheDish()
    {
        Console.WriteLine("I will pay ${0}", this.Bill);
    }

    public void WalkIn()
    {
        Console.WriteLine("Walk into the restaurant");
    }

    public void SitDown()
    {
        Console.WriteLine("Sit down");
    }

    public void Think()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine("Let me think.");
            Thread.Sleep(1000);
        }
        if (this.orderEventHandler != null)
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = "Kongpao Chicken";
            e.Size = "large";
            this.orderEventHandler.Invoke(this, e);
        }
    }

    public void Eat()
    {
        Console.WriteLine("Eating.");
        Thread.Sleep(1000 * 2);
    }

    public void Action()
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();

        this.Eat();
        this.PayTheDish();
    }
}
public class Waiter
{
    public void Action(Customer sender, OrderEventArgs e)
    {
        Console.WriteLine("I will serve you the dish = {0}", e.DishName);
        double price = 10;
        switch (e.Size)
        {
            case "small":
                price = price * 0.5;
                break;
            case "large":
                price *= 1.5;
                break;
            default:
                break;
        }
        sender.Bill += price;
    }
}
```



### 命名约定

- 用于声明 Foo 事件的委托，一般命名为 FooEventHandler
- FooEventHandler 委托的参数一般有两个，第一个为 object sender，实际上就是事件的拥有者； 
- 第二个参数为 FooEventArgs，从 EventArgs 派生，参数名为 e；
- 触发事件的方法一般命名为 OnFoo，访问级别设置为 protected。



### 事件和属性

属性不是字段，很多时候属性是字段的包装器，用来保证字段被正确的赋值和读取，不被外部滥用。

事件不是委托字段，它是委托字段的包装器，用来保护委托字段不被外部滥用。

包装器永远不会是被包装的东西。
