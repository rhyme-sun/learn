# 方法定义、调用和调试



函数以类的成员出现时就叫做方法。

方法永远是类或者结构体的成员，C# 语言中的方法不能独立于类之外。C++ 可以，叫做全局函数。



C++ 方法的声明和定义分开，声明在头文件，定义在 cpp 文件。



方法命名规范：首字母大写，动词或动词短语命名。



## 构造器

ctor + TAB（2 次）生成构造器快捷键。



## 方法的重载

 方法的签名由方法的名称、**类型形参（泛型）**的个数和它的下一个形参（从左往右的顺序）和类型的种类（值参数、引用参数、输出参数）组成。**方法签名不包括返回类型和形参名称**。



重载决策：用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳的函数来调用。



## 调试

设置断点（breakpoint）

观察方法调用时的堆栈

Step-in（F11，单步调试）, Step-over（F10，跳过）, Step-out（Shift + F11，回到调用该方法的方法）。

观察局部变量的值与变化



## 参数

传值参数、输出参数、引用参数、数组参数、具名参数、可选参数、扩展方法（this 参数）



### 值参数

声明时不带任何修饰符，作用域相当于方法的局部变量。

值参数创建变量的副本，对值参数的操作永远不影响变量的值。

```c#

int y = 100;
AddOne(y);
Console.WriteLine(y); // y = 100


public void AddOne(int x) 
{
    x++;
}
```

引用类型参数、为引用地址创建副本，存储同一个地址指向同一个对象。	

```c#
Student stu = new Student();

void SomeMethod(Student stu)
{
    
}
```

### 引用参数

ref 修饰的形参，引用参数在传入方法之前必须明确赋值，用于需要修改实际参数的场景。

引用参数不创建变量的副本，副作用是会改变实参的值。

```c#
class Test
{
    static void Swap(ref int x, ref int y)
    {
        int temp = x;
        x = y;
        y = temp;
    }
    
    static void Main()
    {
        int i = 1, j = 2;
        Swap(ref i, ref j);
        Console.WriteLine("i = {0}, j = {1}", i, j); // i = 2, j = 1
    }
}
```

### 输出参数

用 out 修饰的参数，用于返回值还需要输出的场景。

输出参数不创建新的副本。

在方法返回之前，输出参数必须明确赋值。

```c#
string str = "1";
double x = 0;
bool isNumber = double.TryParse(str, out x);

// or x 可以作为一个局部变量使用
bool isNumber = double.TryParse(str, out double x);
```

```c#
class DoubleParser
{
    public static bool TryParse(string input, out double result)
    {
        try
        {
            result = double.Parse(input);
            return true;
        }
        catch
        {
            result = 0;
            return false;
        }
    }
}
```

### 数组参数

使用 params 修饰，用于简化方法调用。

```c#
int x = 100;
int y = 200;
int z = x + y;

Console.WriteLine("{0}+{1}={2}", x, y, z);

string str = "A;B,C.D";
string[] result = str.Split(';', ',', '.');
```



```c#
static void Main()
{
    int[] arr = {1, 2, 3};
    int result = CalculateSum(arr);
    
    // or
    int result1 = CalculateSum(1, 2, 3);
}

static int CalculateSum(params int[] arr)
{
    int sum = 0;
    foreach (var item in arr) 
    {
        sum += item;
    }
    return sum;
}
```

### 具名参数

当在调用一个方法的时候，方法的参数是有名字的，提高可读性。



```c#
static void PrintInfo(string name, int age)
{
    Console.WriteLine("Hello {0}, you are {1}", name, age);
}

static void Main()
{
    // 具名调用
    PrintInfo(name: "Tim", age: 34);
    
    // 不具名调用
    PrintInfo("Tim", 34);
}
```

具名参数的两个优点：

- 提高代码的可读性；
- 具名调用参数顺序不在受参数列表顺序的约束。

### 可选参数

参数因为默认值而可写可不写。不推荐使用可选参数。



```c#
static void PrintInfo(string name = "Tim", int age = 34)
{
    Console.WriteLine("Hello {0}, you are {1}", name, age);
}

static void Main()
{
    PrintInfo();
    PrintInfo("Tim");
}
```



### 扩展方法

this 参数，为原有类型扩展方法。

扩展方法必须是共有，静态的，必须放到一个静态类里。类命名规范 SomeTypeExtension。

this 参数必须是方法列表的第一个，用 this 修饰。

比如 LINQ 方法。

```c#
static void Main
{
    double x = 3.14159;
    double y = Math.round(x, 4); // 3.1416
    
    x.Round(4); // 只接收第一个参数，x 作为 this 第一个参数
}

// 使用 DoubleExtension 扩展 double
static class DoubleExtension
{
 	public static double Round(this double input, int digits)
    {
        double result = Math.Round(input, digits);
        return result;
    }
}
```



LINQ

```c#
static void Main()
{
	List<int> myList = new List<int> {11, 2, 13, 15};
    // All 为扩展方法
    bool result = myList.All(i => i > 10);
}

static bool AllGreaterThanTen(List<int> intList)
{
    foreach(var item in intList)
    {
        if (item <= 10)
        {
            return false;
        }
    }
    return true;
}
```

