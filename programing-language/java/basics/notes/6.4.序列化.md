# 序列化和反序列化

序列化是指把一个 Java 对象变成二进制内容，本质上就是一个 `byte[]` 数组。

为什么要把 Java 对象序列化呢？因为序列化后可以把 `byte[]` 保存到文件中，或者把 `byte[]` 通过网络传输到远程，这样，就相当于把 Java 对象存储到文件或者通过网络传输出去了。

有序列化，就有反序列化，即把一个二进制内容（也就是 `byte[]` 数组）变回 Java 对象。有了反序列化，保存到文件中或者从网络上读取`byte[]` 数组可以重新转换为 Java 对象。

## Java 对象序列化和反序列化

一个 Java 对象要能序列化，必须实现一个特殊的 `java.io.Serializable` 接口，它的定义如下：

```java
public interface Serializable {
}
```

`Serializable` 接口没有定义任何方法，它是一个空接口，仅仅起到了标记作用，我们把这样的空接口称为“标记接口”（Marker Interface）。

### 序列化

把一个 Java 对象变为 `byte[]` 数组，需要使用 `ObjectOutputStream`，它负责把一个 Java 对象写入一个字节流：

```java
private static void example() {
    try (ByteArrayOutputStream buffer = new ByteArrayOutputStream();
         ObjectOutputStream output = new ObjectOutputStream(buffer)) {
        // 写入 int:
        output.writeInt(12345);
        // 写入 String:
        output.writeUTF("Hello");
        // 写入 Object:
        output.writeObject(Double.valueOf(123.456));
        log.info(Arrays.toString(buffer.toByteArray()));
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

上述代码实现了将对象序列化，并将序列化后的字节写入到 `ByteArrayOutputStream` 流中。

### 反序列化

和 `ObjectOutputStream` 相反，`ObjectInputStream` 负责从一个字节流读取 Java对象：

```java
private static void example2() {
    try (InputStream inputStream = serialize();
         ObjectInputStream input = new ObjectInputStream(inputStream)) {
        int n = input.readInt();
        String s = input.readUTF();
        Double d = (Double) input.readObject();
        log.info("{}", n);
        log.info("{}", s);
        log.info("{}", d);
    } catch (IOException | ClassNotFoundException e) {
        e.printStackTrace();
    }
}

private static InputStream serialize() {
    try (ByteArrayOutputStream buffer = new ByteArrayOutputStream();
         ObjectOutputStream output = new ObjectOutputStream(buffer)) {
        // 写入 int:
        output.writeInt(12345);
        // 写入 String:
        output.writeUTF("Hello");
        // 写入 Object:
        output.writeObject(Double.valueOf(123.456));
        return new ByteArrayInputStream(buffer.toByteArray());
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}
```

除了能读取基本类型和 `String` 类型外，调用 `readObject()` 可以直接返回一个 `Object` 对象，要把它变成一个特定类型，必须强制转型：

`readObject()` 可能抛出的异常有：

- `ClassNotFoundException`：没有找到对应的 Class；
- `InvalidClassException`：Class 不匹配。

对于 `ClassNotFoundException`，这种情况常见于一台电脑上的 Java 程序把一个 Java 对象，例如，`Person` 对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的 Java 程序并没有定义 `Person`类，所以无法反序列化。

对于 `InvalidClassException`，这种情况常见于序列化的 `Person` 对象定义了一个 `int` 类型的 `age` 字段，但是反序列化时，`Person` 类定义的 `age` 字段有变更，比如被改成了 `long` 类型，所以导致 class 在序列化前后不兼容。

为了避免这种 class 定义变动导致的不兼容，Java 的序列化允许 class 定义一个特殊的 `serialVersionUID` 静态变量，用于标识 Java 类的序列化“版本”，通常可以由 IDE 自动生成。如果增加或修改了字段，可以改变 `serialVersionUID` 的值，这样就能自动阻止不匹配的 class 版本：

```java
public class Person implements Serializable {
    private static final long serialVersionUID = 2709425275741743919L;
}
```

> 注意：反序列化时，由 JVM 直接通过字节数组构建出 Java 对象，不调用构造方法，因此构造方法内部的代码，在反序列化时根本不可能执行。

### 安全性

因为 Java 的序列化机制可以导致一个实例能直接从 `byte[]` 数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 `byte[]` 数组被反序列化后可以执行特定的 Java 代码，从而导致严重的安全漏洞。

实际上，Java 本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过 JSON 这样的通用数据结构来实现。

## 总结

以上笔记来自来自于：

- [序列化 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698)