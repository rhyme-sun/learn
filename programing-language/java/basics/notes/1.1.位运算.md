# 位运算

Java 中的位运算。

## 原码、反码、补码

整数（带符号）在计算机内存中是以二进制格式存储的，二进制有以下三种格式：

- 原码：一个带符号整数的符号位加上数值位的二进制表示叫做原码，其中整数的最高位符号位，为 **0 表示正数**，为 **1 表示负数**；
- 反码：正数的反码和原码相同，负数的反码符号位不变，数值位按位取反；
- 补码：正数的补码和原码相同，负数的补码为反码加 1。

1 和 -1 的二进制格式如下所示：

```
1(int) 的原码：00000000000000000000000000000001 
1(int) 的反码：00000000000000000000000000000001 
1(int) 的补码：00000000000000000000000000000001 


-1(int) 的原码：100000000000000000000000000000001
-1(int) 的反码：111111111111111111111111111111110
-1(int) 的补码：111111111111111111111111111111111
```

> 需要注意的是，**二进制数在内存中是以补码的形式来存储的**，位运算操作也是针对补码进行操作，比如使用 `Integer#toBinaryString` 打印整数的二进制格式时，其实是以补码形式输出的，如下代码所示：
>
> ```java
> @Slf4j
> public class BinaryExample {
> 
>     public static void main(String[] args) {
>         // 11111111111111111111111111111111
>         log.info("-1(int) 的补码：{}", Integer.toBinaryString(-1));
>     }
> }
> ```

## 位移运算

Java 中有三种位移运算符，分别为：

- `>>`（带符号右移）：表示带符号位右移，将整数二进制（补码）的低位抹去，高位用原来的符号位补充；
- `>>>`（无符号右移）：表示不带符号右移，将整数二进制（补码）的低位抹去，高位补 0；
- `<<`（左移）：表示带符号左移，将整数二进制（补码）的高位抹去，低位补 0。

如下述代码所示：

```java
@Slf4j
public class DisplacementOperatorExample {

    public static void main(String[] args) {
        // 1(int) 的二进制格式（补码）：  00000000000000000000000000000001   -> 1
        // 右移 1 位（1 >> 1）：        00000000000000000000000000000000   -> 0
        // 无符号右移 1 位（1 >>> 1）：  00000000000000000000000000000000   -> 0
        // 左移 1 位（1 << 1）：        00000000000000000000000000000010   -> 2
        log.info("  1 >> 1，补码：{}，十进制数：{}", Integer.toBinaryString(1 >> 1), (1 >> 1));
        log.info(" 1 >>> 1，补码：{}，十进制数：{}", Integer.toBinaryString(1 >>> 1), (1 >>> 1));
        log.info("  1 << 1，补码：{}，十进制数：{}", Integer.toBinaryString(1 << 1), (1 << 1));


        // -1(int) 的二进制格式（补码）：  11111111111111111111111111111111   -> -1
        // 右移 1 位（-1 >> 1）：        11111111111111111111111111111111   -> -1
        // 无符号右移 1 位（-1 >>> 1）：  01111111111111111111111111111111   -> 2^31 - 1
        // 左移 1 位（-1 << 1）：        11111111111111111111111111111110
        //                             11111111111111111111111111111101
        //                             10000000000000000000000000000010   -> -2
        log.info(" -1 >> 1，补码：{}，十进制数：{}", Integer.toBinaryString(-1 >> 1), (-1 >> 1));
        log.info("-1 >>> 1，补码：{}，十进制数：{}", Integer.toBinaryString(-1 >>> 1), (-1 >>> 1));
        log.info(" -1 << 1，补码：{}，十进制数：{}", Integer.toBinaryString(-1 << 1), (-1 << 1));
    }
}
```

> 位移运算有个常用的性质：
>
> 带符号整数右移 n（n 为正整数） 位，相当除以 `2^n` ；左移 n 位，相当于乘以 `2^n`，所以可以使用位移运算来替代乘 2 或除 2 操作（效率更高），比如：`N * 2 + 1` 就相当于 `(N >> 1) | 1`。

## 按位运算

Java 中有 4 中按位运算符：

- &（按位与）：将两个整数的补码对应的每一位做与运算（有 1 为 1，全 0 为 0）；
- |（按位或）：将两个整数的补码对应的每一位做或运算（有 0 为 0，全 1 为 1）；
- ~（按位取反）：将一个整数的补码对应的每一位做取反运算（1 变 0，0 变 1）；
- ^（按位异或）：将两个整数的补码对应的每一位做或运算（相异为 1，相同为 0）。

如下代码所示：

```java
@Slf4j
public class BitOperatorExample {

    public static void main(String[] args) {
        // -1(int) 的补码：  11111111111111111111111111111111
        // -2(int) 的补码：  11111111111111111111111111111110

        // -1(int) 按位取反：            00000000000000000000000000000000
        // -1(int) 和 -2(int) 按位与：   11111111111111111111111111111110
        // -1(int) 和 -2(int) 按位或：   11111111111111111111111111111111
        // -1(int) 和 -2(int) 按位异或或：00000000000000000000000000000001

        log.info("-1(int) 按位取反：{}", Integer.toBinaryString(~-1));
        log.info("-1(int) 和 -2(int) 按位与：{}", Integer.toBinaryString(-1 & -2));
        log.info("-1(int) 和 -2(int) 按位或：{}", Integer.toBinaryString(-1 | -2));
        log.info("-1(int) 和 -2(int) 按位异或：{}", Integer.toBinaryString(-1 ^ -2));
    }
}
```

## 总结

Java 中整数在内存中是以二进制的形式进行存储和运算，二进制有三种格式，分别为原码、反码、补码，**内存中使用的为补码格式**；

整数原码的最高位表示符号位，0 表示正数，1 表示负数；

正数的原码、反码、补码均相同，负数的反码为原码符号位不变，数值位按位取反，补码为反码加 1；

位移运算和按位运算基于补码进行操作。