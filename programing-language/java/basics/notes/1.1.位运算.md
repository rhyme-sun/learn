# 位运算

Java 中的位运算。

## 基础知识

### 原码，反码，补码

- 原码：一个带符号整数的符号位加上数值位的二进制表示叫做原码，其中整数的最高位符号位，为 0 表示负数，为 1 表示正数；
- 反码：正整数，反码与原码相同；负整数，反码为原码的符号为不变，数值位取反；
- 补码：正数，补码和源码相同；负数，补码为原码的符号位不变，数值位取反再加 1。

总的来说就是，正整数的原码、反码、补码均相同；负整数的反码和原码相比，符号位不变，数值位取反，补码和原码相比，符号位不变，数值位取反加一，即反码加一。

> 注：在 Java 中所有的数都已补码的形式来表示，位移操作和位操作也是针对补码进行操作，如下所示：
>
> ```java
> @Slf4j
> public class DisplacementOperator {
> 
>     public static void main(String[] args) {
>         // 1
>         log.info(" 1 的补码：{}", Integer.toBinaryString(1));
>         // 10000000000000000000000000000001 原码
>         // 11111111111111111111111111111111 补码，符号位不变，数值位取反加一
>         log.info("-1 的补码：{}", Integer.toBinaryString(-1));
>         // 针对补码取反
>         // 10000000000000000000000000000000
>         // 0
>         log.info("-1 取反：{}", Integer.toBinaryString(~-1));
> 
>         // 10000000000000000000000000000010 原码
>         // 11111111111111111111111111111110 补码
>         log.info("-2 的补码：{}", Integer.toBinaryString(-2));
>         // 11111111111111111111111111111101 原码取反
>         // 10000000000000000000000000000001 补码取反
>         log.info("-2 取反：{}", Integer.toBinaryString(~-2));
> 
>         // 11111111111111111111111111111111 -1 的补码
>         // 11111111111111111111111111111110 -2 的补码
>         // 11111111111111111111111111111110 按位与（-2）
>         log.info("-1 & -2： {}", Integer.toBinaryString(-1 & -2));
>         // 11111111111111111111111111111111 -1 的补码
>         // 11111111111111111111111111111110 -2 的补码
>         // 11111111111111111111111111111111 按位与（-1）
>         log.info("-1 | -2：{}", Integer.toBinaryString(-1 | -2));
> 
>         // 11111111111111111111111111111111 -1 的补码
>         // 11111111111111111111111111111110 -2 的补码
>         // 00000000000000000000000000000001 按位与（1）
>         log.info("-1 ^ -2：{}", Integer.toBinaryString(-1 ^ -2));
> 
>         // 0
>         log.info(" 1 >> 1：{}", Integer.toBinaryString(1 >> 1));
>         // 0
>         log.info(" 1 >>> 1：{}", Integer.toBinaryString(1 >>> 1));
>         // 2
>         log.info(" 1 << 1：{}", Integer.toBinaryString(1 << 1));
>         // 11111111111111111111111111111111 -> 11111111111111111111111111111111 -> 10000000000000000000000000000001
>         // -1
>         log.info("-1 >> 1：{}", Integer.toBinaryString(-1 >> 1));
>         // 11111111111111111111111111111111 -> 01111111111111111111111111111111 -> 01111111111111111111111111111111
>         // 2^31-1
>         log.info("-1 >>> 1：{}", Integer.toBinaryString(-1 >>> 1));
>         // - 2
>         log.info("-1 << 1：{}", Integer.toBinaryString(-1 << 1));
>     }
> }
> ```

### 位移运算

- `>>`（带符号右移）：表示带符号位右移，将原来数补码的低位抹去，高位用原来的符号位补充。
- `>>>`（无符号右移）：表示不带符号右移，将原来数补码的低位抹去，高位补 0。
- `<<`（左移）：表示左移，将原来数补码的高位抹去，低位补 0。

带符号整数右移 n（n 为正整数） 位，相当除以 `2^n` ；左移 n 位，相当于乘以 `2^n`。比如：`N * 2 + 1` 就相当于 `(N >> 1) | 1`。

### 位运算

- &（按位与）：将两个整数的补码对应的每一位做与运算；
- |（按位或）：将两个整数的补码对应的每一位做或运算；
- ~（按位取反）：将一个整数的补码对应的每一位做取反运算；
- ^（按位异或）：将一个整数的补码对应的每一位做异或运算。

## 异或运算

### 异或运算的性质

两个数的补码，对应位做无进位相加，也就是相异为 1，相同为 0。异或运算有以下性质：

- N ^ N = 0
- N ^ 0 = N
- 满足交换率和结合率，即若干整数做异或运算，最终结果和异或的顺序无关。

### 异或运算的应用

- 如何不用额外变量交换两个整数

  ```java
  @Slf4j
  public class Swap {
  
      /**
       * 交换数组 i 和 j 位置的值，注意不能是同一个位置
       */
      public static void swap(int[] arr, int i, int j) {
          arr[i] = arr[i] ^ arr[j];
          arr[j] = arr[i] ^ arr[j];
          arr[i] = arr[i] ^ arr[j];
      }
  
      public static void main(String[] args) {
          int a = 1;
          int b = 2;
          int[] array = {a, b};
  
          log.info("Before swap.");
          log.info("array[0]={}", array[0]);
          log.info("array[1]={}", array[1]);
          swap(array, 0, 1);
          log.info("After swap.");
          log.info("array[0]={}", array[0]);
          log.info("array[1]={}", array[1]);
      }
  }
  
  ```

  证明：

  ```
  a = a^b;
  b = a^b;
  a = a^b;
  
  a = a^b
  b = a^b = (a^b)^b = a^(b^b) = a^0 = a
  a = a^b = (a^b)^a = (a^a)^b = 0^b = b
  ```

- 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数。代码如下：

  ```java
  public class OddTimes {
  
      /**
       * 一个数组中，有一种数出现了奇数次，其余数均出现偶数次，找出这个数并打印。
       * 解法思路：将数组中的数做异或运算，根据异或运算的性质，出现偶数次的数异或结果为 0 ，奇数次异或结果为本身。
       */
      static void once(int[] array) {
          if (array == null || array.length == 0) {
              log.info("Array can't be empty!");
              return;
          }
          int eor = 0;
          for (int i : array) {
              eor ^= i;
          }
          log.info(eor + "");
      }
  
      public static void main(String[] args) {
          int[] array = {-1, -1, 0, 0, 0, 1, 1, 1, 1};
          once(array);
      }
  }
  ```

- 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数。

  找出一个整数 a 最右侧的 1，比如 10101000 -> 00001000，使用 `a & (~a + 1)` 即可以找到 a 最右侧的 1，过程如下：

  ```
  10101000 假设为 a 的二进制
  01010111 取反
  01011000 加一
  
  10101000
  01011000 与操作，高于最右侧的位，相反，低于最右侧的位为 0，最有侧位为 1
  
  00001000 获得结果
  ```

  代码实现：

  ```java
  /**
   * 找出一个数组中的奇数个数的一种数或两种数
   */
  @Slf4j
  public class OddTimes {
  
      /**
       * 一个数组中，有两种种数出现了奇数次，其余数均出现偶数次，找出这两种数并打印。
       * 解法思路：将数组中的元素做异或运算，假设这两种数分别为 a 和 b，那么根据异或运算性质，最终结果为 a^b；
       * 因为 a!=b，所以 a^b!=0, 就一定存在某位为 1，找到 a^b 右侧第一个为 1 的位置，假设为第 5 位，此时就可以将数组中的数分成两大类，
       * 即第 5 位为 0 和 第 5 位为 1；
       * a 和 b 一定分别存在这两大类中，因为异或运算，只有对应位值不相等是才能得到 1；
       * 在对其中一类的数做异或运算就能得到 a 或 b。
       */
      static void twice(int[] array) {
          if (array == null || array.length == 0) {
              log.info("Array can't be empty!");
              return;
          }
          int eor = 0;
          for (int i : array) {
              eor ^= i;
          }
          // 提取出最右的 1
          int rightOne = eor & (~eor + 1);
  
          int onlyOne = 0;
          for (int i : array) {
              if ((i & rightOne) == 0) {
                  onlyOne ^= i;
              }
          }
          log.info(onlyOne + "");
          log.info((onlyOne ^ eor) + "");
      }
  
      public static void main(String[] args) {
          int[] array2 = {-1, -1, 0, 0, 0, 1, 1, 1, 1, 2};
          twice(array2);
    }
  }
  ```
  
  > 注：使用 `a & (~a + 1)` 找出 a 最右侧的 1，这个公式比较常用。



