# Java 集合类

Java 的集合类可以分成两个大类，`Collection` 和 `Map`，类图如下所示：

![](../images/Java集合类.png)

我们可以看到 Java 的集合框架，Collection 接口是所有集合的根（不包括 Map），然后扩展开提供了三大类集合，分别是：

- List，也就是有序集合，它提供了方便的访问、插入、删除等操作；

- Set，Set 是不允许重复元素的，这是和 List 最明显的区别，我们在日常开发中有很多需要保证元素唯一性的场合，Set 有以下种类：

  - TreeSet 支持自然顺序访问，但是添加、删除、包含等操作要相对低效（log(n) 时间）；

  - HashSet 则是利用哈希算法，理想情况下，如果没有哈希冲突，可以提供常数时间的添加、删除、包含等操作，但是它不保证有序。

  - LinkedHashSet，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作性能略低于 HashSet，因为需要维护链表的开销；

    > 在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，遍历性能只和元素多少有关系。

- Queue/Deque，则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-In-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为，这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。

Map，是一种通过键值（key-value）查找的映射表集合，其顶层接口为 Map。



对于 Java 集合框架，至少有知晓以下几个方面：

- Java 集合框架的设计结构，至少要有一个整体印象；
- Java 提供的主要容器（集合和 Map）类型，了解或掌握对应的数据结构、算法，思考具体技术选择；
- 将问题扩展到性能、并发等领域；
- 集合框架的演进与发展。

## fail-fast

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 `ConcurrentModificationException`。如下：

```java
public class FailFastExample {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        for (String s : list) {
            // list.add("D");
            list.remove(s);
        }
    }
}
```

具体原理是，在容器内部维护了一个  `modCount` 变量，具体在 AbstractList 中，如下所示：

```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {

    protected AbstractList() {}
    
    protected transient int modCount = 0;
    
    public E next() {
        checkForComodification();
        try {
            int i = cursor;
            E next = get(i);
            lastRet = i;
            cursor = i + 1;
            return next;
        } catch (IndexOutOfBoundsException e) {
            checkForComodification();
            throw new NoSuchElementException();
        }
    }
    
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
    
    public void set(E e) {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.set(lastRet, e);
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            ArrayList.this.add(i, e);
            cursor = i + 1;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}
```

每当我们调用修改列表的方法时，`modCount` 就会执行加一操作，并且在迭代器（`Itr`，是 `AbstractList` 的一个内部类）内部维护了一个 `expectedModCount` 变量，初始值和当前的 `modCount` 值一致，代码如下所示：

```java
 private class Itr implements Iterator<E> {
     int expectedModCount = modCount;
 }
```

如果我们在使用迭代器遍历列表的过程中，调用了列表的修改方法，会导致 `modCount` 的值执行了加一操作，但 Itr 里的 `expectedModCount` 不会改变，这样遍历途（调用上述代码的 next 方法）中通过调用 `checkForComodification` 方法就会抛出异常。

fail-fast 是一种让错误今早暴露初来的思想，以避免后续不可预计的行为，Java 中的集合都符合迭代时 fail-fast 行为。

此外列表的迭代器还为我们提供了 remove 和 add 方法，调用此方法时会在修改增加或删除元素时刷新  `expectedModCount` 的值，这样在迭代时就不会抛出 `ConcurrentModificationException`异常，如：

```java
public class FailFastExample {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        final Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            iterator.remove();
        }
    }
}
```

## 默认排序算法

我们一般会使用 `Collections.sort()` 或者 `Arrays.sort()` 对列表或者数组进行排序，使用的排序算法正对数据类型，和数据量大小使用的算法有所不同。

- 对于数据量，如果数据量很小，复杂排序是没必要的，不管是什么数据类型，Java 会直接进行二分插入排序；
- 对于数据类型：
  - 对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序，你可以阅读 [DualPivotQuicksort.java](http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/DualPivotQuicksort.java)；
  - 而对于对象数据类型，目前则是使用 [TimSort.java](http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/TimSort.java)，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。

此外 Java 8 引入了并行排序算法（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。

## 工厂方法

在 Java 9 中，Java 标准类库提供了一系列的静态工厂方法，比如，`List.of()`、`Set.of()`，大大简化了构建小的容器实例的代码量。根据业界实践经验，我们发现相当一部分集合实例都是容量非常有限的，而且在生命周期中并不会进行修改。但是，在原有的 Java 类库中，我们可能不得不写成：

```java
ArrayList<String>  list = new ArrayList<>();
list.add("Hello");
list.add("World");
```

而利用新的容器静态工厂方法，一句代码就够了，**并且保证了不可变性**：

```java
List<String> simpleList = List.of("Hello","world");
```

## 总结

以上笔记总结自极客时间《Java核心技术面试精讲》专栏：

- [第8讲 | 对比Vector、ArrayList、LinkedList有何区别？ (geekbang.org)](https://time.geekbang.org/column/article/7810)

