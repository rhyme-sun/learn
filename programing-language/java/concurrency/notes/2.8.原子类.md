# 原子类

我们可以使用互斥锁来实现保保障对临界资源的互斥访问，即原子性。其实对于简单的原子性问题，还有一种无锁方案。比如我们想让 `count += 1`  具有原子性，使用原子类，我们可以这么做：

```java
public class AtomicTutorial {

    static AtomicLong count = new AtomicLong(0);

    public static void main(String[] args) {
        for (int i = 0; i < 10000; i++) {
            count.getAndIncrement();
        }
        System.out.println(count);
    }
}
```

互斥锁方案为了保证互斥性，需要执行加锁、解锁操作，而加锁、解锁操作本身就消耗性能，同时拿不到锁的线程还会进入阻塞状态，进而触发线程切换，线程切换对性能的消耗也很大； 相比之下，无锁方案则完全没有加锁、解锁的性能消耗，同时还能保证数据正确写入。

## CAS

无锁的实现原理是 CAS，全称是 Compare And Swap，即“比较并交换”。

CAS 是 CPU 提供的**原子指令**，包含三个参数，分别是共享变量内存地址 A，用于比较的值 B（共享变量更新前的值），和共享变量的更新值 C，只有当地址 A 上的值和比较值 B 相等时，才能将值更新为 C，最后返回共享地址 A 处当前的值。

“比较并交换”逻辑用 Java 模拟实现为：

```java
public class CASTutorial {

    /**
     * 模拟 CAS
     *
     * @param offset   内存地址，用 long 表示是 64 位操作系统
     * @param expected 预期的值，即更新前的值
     * @param newValue 更新后的值
     * @return CAS 操作后，内存地址的值
     */
    synchronized int cas(long offset, int expected, int newValue) {
        int currentValue = getCurrentValue(offset);
        if (expected == currentValue) {
            setCurrentValue(offset, newValue);
        }
        return currentValue;
    }

    private int getCurrentValue(long offset) {
        return 0;
    }

    private void setCurrentValue(long offset, int newValue) {
    }
}
```

使用 CAS 来解决并发问题，一般都会伴随着自旋，而所谓自旋，其实就是循环尝试，所以 CAS 有时也被称为自旋锁。自旋就是为了保证某个线程最终能够成功的将值写入到内存。

比如，我们用自旋来实现 count += 1 的操作：

```java
public class CASTutorial {

    volatile int count;

    void addOne() {
        int oldValue;
        int newValue;
        // 自旋
        do {
            oldValue = count;
            newValue = oldValue + 1;
        } while (oldValue != cas(0, oldValue, newValue));
    }

    /**
     * 模拟 CAS
     *
     * @param offset   内存地址，用 long 表示是 64 位操作系统
     * @param expected 预期的值，即更新前的值
     * @param newValue 更新后的值
     * @return CAS 操作后，内存地址的值
     */
    synchronized int cas(long offset, int expected, int newValue) {
        int currentValue = getCurrentValue(offset);
        if (expected == currentValue) {
            setCurrentValue(offset, newValue);
        }
        return currentValue;
    }

    private int getCurrentValue(long offset) {
        // 读取 offset 处的值
        return 0;
    }

    private void setCurrentValue(long offset, int newValue) {
        // 将新的值设置到 offset 处，并返回设置的值
    }
}
```

## 原子类概览

Java SDK 并发包里提供的原子类内容很丰富，我们可以将它们分为五个类别：原子化的基本数据类型、原子化的对象引用类型、原子化数组、原子化对象属性更新器和原子化的累加器。

### 原子化的基本数据类型

```java
getAndIncrement() //原子化i++
getAndDecrement() //原子化的i--
incrementAndGet() //原子化的++i
decrementAndGet() //原子化的--i
//当前值+=delta，返回+=前的值
getAndAdd(delta) 
//当前值+=delta，返回+=后的值
addAndGet(delta)
//CAS操作，返回是否成功
compareAndSet(expect, update)
//以下四个方法
//新值可以通过传入func函数来计算
getAndUpdate(func)
updateAndGet(func)
getAndAccumulate(x,func)
accumulateAndGet(x,func)
```

### 原子化的对象引用类型

相关实现有 AtomicReference、AtomicStampedReference 和 AtomicMarkableReference，利用它们可以实现对象引用的原子化更新。不过需要注意的是，对象引用的更新需要重点关注 ABA 问题，AtomicStampedReference 和 AtomicMarkableReference 这两个原子类可以解决 ABA 问题。

解决 ABA 问题的思路其实很简单，增加一个版本号维度就可以了，每次执行 CAS 操作，附加再更新一个版本号，只要保证版本号是递增的，那么即便 A 变成 B 之后再变回 A，版本号也不会变回来（版本号递增的）。AtomicStampedReference 实现的 CAS 方法就增加了版本号参数，方法签名如下：

```java
boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) 
```

AtomicMarkableReference 的实现机制则更简单，将版本号简化成了一个 Boolean 值，方法签名如下：

```java
boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark)
```

### 原子化数组

相关实现有 AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray，利用这些原子类，我们可以原子化地更新数组里面的每一个元素。这些类提供的方法和原子化的基本数据类型的区别仅仅是：每个方法多了一个数组的索引参数。

### 原子化对象属性更新器

相关实现有 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater，利用它们可以原子化地更新对象的属性，这三个方法都是利用反射机制实现的，创建更新器的方法如下：

```java
public static <U> AtomicXXXFieldUpdater<U> newUpdater(Class<U> tclass, String fieldName)
```

需要注意的是，对象属性必须是 volatile 类型的，只有这样才能保证可见性；如果对象属性不是 volatile 类型的，newUpdater 方法会抛出 IllegalArgumentException 这个运行时异常。

### 原子化的累加器

DoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持 compareAndSet() 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好。