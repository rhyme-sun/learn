# CompletableFuture

CompletableFuture  是 Java 在 1.8 版本提供的用来支持异步编程的工具类。

## 创建 CompletableFuture 

CompletableFuture 提供了四个静态方法来创建 CompletableFuture 对象，方法如下所示：

```java
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
    return asyncSupplyStage(ASYNC_POOL, supplier);
}

public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor) {
    return asyncSupplyStage(screenExecutor(executor), supplier);
}

public static CompletableFuture<Void> runAsync(Runnable runnable) {
    return asyncRunStage(ASYNC_POOL, runnable);
}

public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {
    return asyncRunStage(screenExecutor(executor), runnable);
}
```

> 注意：默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池，这个线程池默认创建的线程数是 CPU 的核数，可以通过 `- Djava.util.concurrent.ForkJoinPool.common.parallelism` 来设置 ForkJoinPool 线程池的线程数。
>
> 如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I/O 操作，就会导致线程池中所有线程都阻塞在 I/O 操作上，从而造成**线程饥饿**，进而影响整个系统的性能。所以，强烈建议你要根据不同的业务类型创建不同的线程池，以避免互相干扰，即使用上述四个方法的后两个方法。

## CompletionStage

CompletionStage 对异步任务执行的每个阶段进行了抽象，其定义了多个接口，我们可以从接口的返回值、接口名称和入参三个方面来理解 CompletionStage：

- 从返回值来讲，每个接口都返回 CompletionStage 对象本身，这意味着 CompletionStage 中的方法可以链式调用；
- 从接口方法名称来讲，不同方法名称描述了任务间的时序关系和执行计算任务的形式；
- 从接口方法的入参来讲，入参描述了当前任务阶段需要执行的计算逻辑，参数的形式（fn、consumer、action）取决于当前任务是否会产生结果或是否需要传入参数。

任务分工的时序关系有：串行关系，并行关系，AND 汇聚关系（等待所有任务成功执行后执行），OR 汇聚关系（等待任何一个任务成功执行后执行）。

### 描述串行关系

描述串行关系的方法都以 then 开头，表示上个任务结束后接着执行参数表示的计算任务。

```java
CompletionStage<R> thenApply(fn);
CompletionStage<R> thenApplyAsync(fn);
CompletionStage<Void> thenAccept(consumer);
CompletionStage<Void> thenAcceptAsync(consumer);
CompletionStage<Void> thenRun(action);
CompletionStage<Void> thenRunAsync(action);
CompletionStage<R> thenCompose(fn);
CompletionStage<R> thenComposeAsync(fn);
```

例子：

```java
static void example1() {
    CompletableFuture<String> f0 = CompletableFuture.supplyAsync(() -> "Hello ")
        .thenApply(s -> s + "simon")
        .thenApply(String::toUpperCase);
    log.info(f0.join());
}
```

### 描述 AND 汇聚关系

AND 汇聚关系表示所有异步任务都完成后再执行后面的计算任务。

```java
CompletionStage<R> thenCombine(other, fn);
CompletionStage<R> thenCombineAsync(other, fn);
CompletionStage<Void> thenAcceptBoth(other, consumer);
CompletionStage<Void> thenAcceptBothAsync(other, consumer);
CompletionStage<Void> runAfterBoth(other, action);
CompletionStage<Void> runAfterBothAsync(other, action);
```

例子：

```java
static void example2() {
    final CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
        sleep(2, TimeUnit.SECONDS);
        return "Hello";
    });

    final CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {
        sleep(3, TimeUnit.SECONDS);
        return "Simon";
    });

    final CompletableFuture<String> f3 = f1.thenCombine(f2, (result1, result2) -> {
        String result =  result1 + " " + result2;
        return result.toUpperCase(Locale.ROOT);
    });
    log.info(f3.join());
}

static void sleep(int t, TimeUnit u) {
    try {
        u.sleep(t);
    } catch (InterruptedException e) {
    }
}
```

### 描述 OR 汇聚关系

OR 汇聚关系表示任何一个异步任务完成后再执行后面的计算任务。

```java
CompletionStage applyToEither(other, fn);
CompletionStage applyToEitherAsync(other, fn);
CompletionStage acceptEither(other, consumer);
CompletionStage acceptEitherAsync(other, consumer);
CompletionStage runAfterEither(other, action);
CompletionStage runAfterEitherAsync(other, action);
```

例子：

```java
static void example3() {
    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {
        int t = (int) (Math.random() * 5) + 1;
        sleep(t, TimeUnit.SECONDS);
        return "f1-" + t;
    });
    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {
        int t = (int) (Math.random() * 5) + 1;
        sleep(t, TimeUnit.SECONDS);
        return "f2-" + t;
    });
    CompletableFuture<String> f3 = f1.applyToEither(f2, s -> s);
    log.info(f3.join());
}
```

### 异常处理

非异步编程里面，我们可以使用 try-catch 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？CompletionStage 接口给我们提供一些处理异常的方法：

```java
CompletionStage exceptionally(fn);
CompletionStage<R> whenComplete(consumer);
CompletionStage<R> whenCompleteAsync(consumer);
CompletionStage<R> handle(fn);
CompletionStage<R> handleAsync(fn);
```

例子：

```java
static void example4() {
    CompletableFuture<Integer> f = CompletableFuture
        .supplyAsync(() -> (7 / 0))
        .thenApply(r -> r * 10)
        .exceptionally(e -> {
            log.error("Exception", e);
            return 0;
        });
    log.info(f.join() + "");
}
```

