# 任务模型

线程池、Future、CompletableFuture 和 CompletionService，仔细观察你会发现这些工具类都是在帮助我们站在任务的视角来解决并发问题，而不是让我们纠缠在线程之间如何协作的细节上（比如线程之间如何实现等待、通知等）。

从现实任务模型的角度来讲，任务模型包括：

- 并行任务模型；
- 聚合（AND 聚合或者 OR 聚合）任务模型；
- 批量并行任务模型；
- 分治任务模型。

对于上述四种任务模型，从使用的角度来讲：

- 对于简单的并行任务，你可以通过“线程池 + Future”的方案来解决；

- 如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；

- 批量的并行任务，则可以通过 CompletionService 来解决，它内部维护了一个阻塞对队列，可以实现先完成的任务先执行，避免无谓等待；

- 对于分治的任务模型，我们可以使用 ForkJoinPool 来解决。

  分治任务模型可分为两个阶段：一个阶段是任务分解，也就是将任务迭代地分解为子任务，直至子任务可以直接计算出结果；另一个阶段是结果合并，即逐层合并子任务的执行结果，直至获得最终结果。

  其中可以分治处理的任务有一个特点，任务和分解后的子任务具有相似性，这种相似性往往体现在任务和子任务的算法是相同的，但是计算的数据规模是不同的，具备这种相似性的问题，我们往往都采用递归算法。

## 总结

以上内容总结自极客时间《Java并发编程实践》：

-  [26 | Fork/Join：单机版的MapReduce (geekbang.org)](https://time.geekbang.org/column/article/92524)