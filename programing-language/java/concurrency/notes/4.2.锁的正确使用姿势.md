# 锁的正确使用姿势

并发大师 Doug Lea《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：

1. 永远只在更新对象的成员变量时加锁；
2. 永远只在访问可变的成员变量时加锁；
3. 永远不在调用其他对象的方法时加锁。

除此之外，我们知道锁可以保护临界区的共享资源，实现并发条件下，对临界区代码的串行执行。从保护共享资源的角度来讲，使用锁的时候有以下几点需要注意：

- 锁的过度使用可能导致串行化的范围过大，进而影响程序效率，这样就不能够发挥多线程的优势了，因此在使用锁时我们需要对于保护的资源进行精细化管理，使用不同的锁来分别保护相关的资源，降低锁的粒度，减少锁的持有时间；

- 减少锁的持有时间，除了降低锁的粒度外，对于超时的操作，尽量不要放到锁中执行；

- 对于锁保护的资源要能全部覆盖，如下面这个例子：

  ```java
  // 账户
  class Account {
    private int balance;
    // 转账
    synchronized void transfer(Account target, int amt){
      if (this.balance > amt) {
        this.balance -= amt;
        target.balance += amt;
      }
    } 
  }
  ```

  如上述代码，转账方法只能保护到本对象实例的 balance，对于 target.balance 是保护不上的。这是因为每个账户转账方法使用本身对象实例（this）作为锁，这意味着不可能存在同时有多个线程都会操作到同一个 target.balance，如果 target 这个账户是被多个线程共享的，就存在线程安全问题。这时候让不同线程能够用到同一把锁，就可以解决上述问题，如下：

  ```java
  // 账户
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      synchronized(Account.class) {
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    } 
  }
  ```

  这时候，所有的线程都已 `Account.class` 作为锁，实现了对 this.balance 和 target.balance 的同步访问。

  > 注：但就转账业务来将，将整个转账串行化处理是不合理的。

  更好的优化方式如下所示：

  ```java
  // 账户
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      // 锁定转出账户
      synchronized(this) {              
        // 锁定转入账户
        synchronized(target) {           
          if (this.balance > amt) {
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } 
  }
  ```

  相对于 `Account.class` 对象，以实例对象作为锁粒度更小，但上述优化有死锁风险。

## 死锁

死锁是一种典型的线程活跃性问题，所谓活跃性问题是指线程在执行某个操作时因为某种原因而无法继续执行下去。

只有以下这四个条件都发生时才会出现死锁：

1. **互斥**，共享资源 X 和 Y 只能被一个线程占用；
2. **占有且等待**，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. **不可抢占**，其他线程不能强行抢占线程 T1 占有的资源；
4. **循环等待**，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

预防死锁也是从这四个条件入手：

**破坏占有且等待**：从理论上来讲，只要一次性申请完所有的资源，就可以破坏这个条件，那上面的例子举例，可以增加一个账本管理员，负责给转账业务分配转账和入账资源：

```java
// 账本管理员
class Allocator {
  private List<Object> als = new ArrayList<>();
  // 一次性申请所有资源
  synchronized boolean apply (
    Object from, Object to){
    if(als.contains(from) || als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt) {
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target));
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance > amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  } 
}
```

**破坏不可抢占条件**：就是让资源持有者主动释放资源，这一点 synchronized 做不到，JUC 下的 Lock 可以做到。

**破坏循环等待条件**：破坏这个条件，需要对资源进行排序，然后按序申请资源。

```java
// 账户
class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt) {
    Account left = this        
    Account right = target;    
    if (this.id > target.id) { 
      left = target;           
      right = this;            
    }                          
    // 锁定序号小的账户
    synchronized(left) {
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance > amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```

## 活跃性问题

线程的活跃性除了死锁以外，还有活锁和饥饿这两类问题。

### 活锁

活锁和死锁不同的时，死锁会有两个或以上的线程等待锁的释放而处于阻塞状态，而活锁下的线程没有发生阻塞，但任然存在执行不下去的情况。举个例子，现实生活中路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边如此往复，这样路人甲进不了门，而路人乙也出不了门。现实生活中解决这种问题，很简单，只要有一个人谦让以下不动就行，可是如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。

解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。

### 饥饿

所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。

解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。

## 总结

在并发编程过程中，正确的使用锁十分重要，因为编码不当会导致线程相互持有对方的锁并等待导致死锁。死锁是一种很严重的线程活跃性问题，我们更加死锁的产生条件并可以通过破坏这些条件来解决死锁问题。

除了死锁外，活锁和饥饿这两种线程活跃性问题同样需要我们关注。活锁时，线程虽然不会像死锁一样处于阻塞状态，但是会因为相互“谦让”导致程序也无法继续执行，解决活锁的方法的办法很简单，就是线程在”谦让“时等待一个随机时间就好；线程饥饿往往是因为线程优先级不同导致高优先级的线程一直获取的执行机会，而低优先级的线程却迟迟等不到机会执行，这也是有的地方建议我们除非必要情况下不要给线程设置优先级，此外线程饥饿是因为低优先级的线程得不到可执行的资源，如果我们能够保证资源是充足的，也可以有效的避免线程饥饿问题。

以上内容总结于极客时间《Java并发编程实践》：

- [03 | 互斥锁（上）：解决原子性问题 (geekbang.org)](https://time.geekbang.org/column/article/84344)
- [04 | 互斥锁（下）：如何用一把锁保护多个资源？ (geekbang.org)](https://time.geekbang.org/column/article/84601)
- [05 | 一不小心就死锁了，怎么办？ (geekbang.org)](https://time.geekbang.org/column/article/85001)
