# 锁的正确使用姿势

并发大师 Doug Lea《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：

1. 永远只在更新对象的成员变量时加锁；
2. 永远只在访问可变的成员变量时加锁；
3. 永远不在调用其他对象的方法时加锁。

除此之外，我们知道锁可以保护临界区的共享资源，实现并发条件下，对临界区代码的串行执行。从保护共享资源的角度来讲，使用锁的时候有以下几点需要注意：

- 锁的过度使用可能导致串行化的范围过大，进而影响程序效率，这样就不能够发挥多线程的优势了，因此在使用锁时我们需要对于保护的资源进行精细化管理，使用不同的锁来分别保护相关的资源，降低锁的粒度，减少锁的持有时间；

- 减少锁的持有时间，除了降低锁的粒度外，对于超时的操作，尽量不要放到锁中执行；

- 对于锁保护的资源要能全部覆盖，如下面这个例子：

  ```java
  // 账户
  class Account {
    private int balance;
    // 转账
    synchronized void transfer(Account target, int amt){
      if (this.balance > amt) {
        this.balance -= amt;
        target.balance += amt;
      }
    } 
  }
  ```

  如上述代码，转账方法只能保护到本对象实例的 balance，对于 target.balance 是保护不上的。这是因为每个账户转账方法使用本身对象实例（this）作为锁，这意味着不可能存在同时有多个线程都会操作到同一个 target.balance，如果 target 这个账户是被多个线程共享的，就存在线程安全问题。这时候让不同线程能够用到同一把锁，就可以解决上述问题，如下：

  ```java
  // 账户
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      synchronized(Account.class) {
        if (this.balance > amt) {
          this.balance -= amt;
          target.balance += amt;
        }
      }
    } 
  }
  ```

  这时候，所有的线程都已 `Account.class` 作为锁，实现了对 this.balance 和 target.balance 的同步访问。

  > 注：但就转账业务来将，将整个转账串行化处理是不合理的。

  更好的优化方式如下所示：

  ```java
  // 账户
  class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt){
      // 锁定转出账户
      synchronized(this) {              
        // 锁定转入账户
        synchronized(target) {           
          if (this.balance > amt) {
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } 
  }
  ```

  相对于 `Account.class` 对象，以实例对象作为锁粒度更小，但上述优化有死锁风险。

## 死锁的解决办法

只有以下这四个条件都发生时才会出现死锁：

1. **互斥**，共享资源 X 和 Y 只能被一个线程占用；
2. **占有且等待**，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. **不可抢占**，其他线程不能强行抢占线程 T1 占有的资源；
4. **循环等待**，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

预防死锁也是从这四个条件入手：

**破坏占有且等待**：从理论上来讲，只要一次性申请完所有的资源，就可以破坏这个条件，那上面的例子举例，可以增加一个账本管理员，负责给转账业务分配转账和入账资源：

```java
// 账本管理员
class Allocator {
  private List<Object> als = new ArrayList<>();
  // 一次性申请所有资源
  synchronized boolean apply(
    Object from, Object to){
    if(als.contains(from) || als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target));
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance > amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  } 
}
```

**破坏不可抢占条件**：就是让资源持有者主动释放资源，这一点 synchronized 做不到，JUC 下的 Lock 可以做到。

**破坏循环等待条件**：破坏这个条件，需要对资源进行排序，然后按序申请资源。

```java
// 账户
class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        
    Account right = target;    
    if (this.id > target.id) { 
      left = target;           
      right = this;            
    }                          
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance > amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```

## 总结

以上内容总结于极客时间《Java并发编程实践》：

- [03 | 互斥锁（上）：解决原子性问题 (geekbang.org)](https://time.geekbang.org/column/article/84344)
- [04 | 互斥锁（下）：如何用一把锁保护多个资源？ (geekbang.org)](https://time.geekbang.org/column/article/84601)
- [05 | 一不小心就死锁了，怎么办？ (geekbang.org)](https://time.geekbang.org/column/article/85001)

更多可参考原文。