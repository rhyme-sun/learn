

# 类加载器

class 文件的加载是由类加载器完成的，JVM 中的类是按需加载，采用双亲委派机制，同时我们还能自定义加载器来满足我们特定场景下的加载需求。

## 类加载器的结构层次

**Java 8** 及之前的类加载结构层次如下所示：

```java
BootstrapClassLoader
    
ExtClassLoader
    
AppClassLoader
    
CustomClassLoader
```

前三种是 JVM 自带的类加载器：

- 启动类加载器（`BootstrapClassLoader`） ：负责加载 `jre/lib/rt.jar` `charset.jar` 等核心类；

- 扩展类加载器（`ExtClassLoader`） ：负责加载 JRE 扩展目录，即 `jre/lib/ext/*.jar`，或使用 `-Djava.ext.dirs` 指定扩展包加载路径；

- 应用类加载器（`AppClassLoader`）：加载 classpath 里的内容，一般来讲，用户编写的类都是由该类加载器加载。

在代码实现上，启动类加载器由 JVM 内部 C++ 代码实现的，使用 Java API 无法获取到；**扩展类加载器**和**应用类加载器**都是在 `sun.misc.Launcher` 中定义的，并且都继承 `URLClassLoader` 类，这个类默认实现了从各种不同来源加载 class 字节码转换成 Class 对象的方法。

而最后一种类加载器就是自定义加载器，其本身和其他在 classpath 中的类一样是由 `AppClassLoader` 加载的，其父类加载器为 `AppClassLoader` 。

我们通过以下代码也可以看出类加载器的结构层次：

```java
@Slf4j
public class ClassLoaderLevel {

    public static void main(String[] args) {
        CustomClassLoader customClassLoader = new CustomClassLoader();
        // AppClassLoader：自定义类加载其本身是由 AppClassLoader 加载的
        log.info("CustomClassLoader's classLoader: {}", customClassLoader.getClass().getClassLoader());
        // AppClassLoader：自定义类加载的父加载器是 AppClassLoader
        log.info("CustomClassLoader's parent loader: {}", customClassLoader.getParent());
        // AppClassLoader：定义在 classpath 里的类是由 AppClassLoader 加载的
        ClassLoader appClassLoader = ClassLoaderLevel.class.getClassLoader();
        log.info("ClassLoaderLevel's classLoader: {}", appClassLoader);

        // ExtClassLoader：AppClassLoader 的父加载器是 ExtClassLoader
        // JDK 9 之后，AppClassLoader 的父加载器是 PlatformClassLoader
        ClassLoader extClassLoader = appClassLoader.getParent();
        log.info("AppClassLoader's parent loader: {}", extClassLoader);

        // BootstrapClassLoader(null)：ExtClassLoader 的父加载器为 BootstrapClassLoader，但使用 Java API 获取不到
        log.info("ExtClassLoader's parent loader: {}", extClassLoader.getParent());
        // NullPointerException
        //System.out.println(extClassLoader.getParent().getParent());

        // BootstrapClassLoader(null)：AppClassLoader 加载器类的加载器为 BootstrapClassLoader
        log.info("AppClassLoader's classLoader: {}", appClassLoader.getClass().getClassLoader());

        // BootstrapClassLoader(null)：ExtClassLoader 加载器类的加载器为 BootstrapClassLoader
        log.info("ExtClassLoader's classLoader: {}", extClassLoader.getClass().getClassLoader());

        // AppClassLoader：可使用 ClassLoader#getSystemClassLoader 方法获取到 AppClassLoader
        log.info("ClassLoader.getSystemClassLoader: {}", ClassLoader.getSystemClassLoader());
    }
}

class CustomClassLoader extends ClassLoader {
}
```

> Java 8 到 Java 9 ClassLoader 相关变化:
>
> Java 8 的 ClassLoader 加载范围：
>
> - bootstrap classloader 加载 rt.jar，`jre/lib/` 下特定的 jar；
> - ext classloader 加载 jre/lib/ext/*.jar；
> - app classloader 加载 -cp 指定的类；
> - 可使用 `ClassLoader#getSystemClassLoader` 方法获取到 `AppClassLoader`。
>
> java 9 及之后的 ClassLoader 加载范围：
>
> - bootstrap classloader 加载 lib/modules；
> - ext classloader 更名为 platform classloader，加载 lib/modules；
> - app classloader 加载 -cp，-mp 指定的类；
> - 可使用 `ClassLoader#getPlatformClassLoader` 方法获取到 `PlatformClassLoader`。

## 双亲委派

ClassLoader 类中关于加载类的代码如下所示（JDK 11）：

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}
```

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

如上述代码所示，`loadClass` 这个方法是有 **JVM 来触发加载**，加载类有以下几个步骤：

1. 通过 `findLoadedClass` 方法检查该类是否已经被加载过，如果加载过直接返回；
2. 调用父类加载器上的 `loadClass` 方法，如果父级为空，则使用内置到虚拟机中的类加载器（`BootstrapClassLoader`）；
3. 如果父类加载器或者 `BootstrapClassLoader` 没有加载到类，则调用 `findClass `方法去加载类。

如果上述步骤加载到了类，接下来调用 `resolveClass` 方法解析类。



此外我们可以看到，当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器，只有在父类加载器在自己的**搜索范围**内找不到指定类时，子类加载器才会尝试自己去加载，这就是我们所说的双亲委派。

双亲委派有一个明显的好处是避免类重复加载，并且还起到了安全加载作用，比如 Java 的核心类库由 `BootstrapClassLoader` 去加载，即使我们强制使用自定义类加载器去加载，加载过程中发现加载过了就不会加载，从而起到了安全的作用。

> 注意：**我们在定义自定义加载器时，一般都会重写 `findClass` 方法而不是重写 `loadClass` 方法，这样就不会破坏双亲委派机制**。

## 自定义类加载器

编写自定义加载器一般需要以下几个步骤：

- 继承 `ClassLoader`；
- 重新 `findClass` 方法；
- 在 `findClass` 方法中调用 `defineClass` 方法。

我们在实际编码过程中可能会遇到自定义加载器的需求，比如我们有一个加密后的 class 文件，我们需要编写自定义加载器去加载，代码如下所示：

```java
/**
 * Hello.xlass 类加载器，加载 Hello.xlass。
 * Hello.xlasss，Hello.class 每个字节用 255 相减得到的文件。
 */
public class HelloXlassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] encryption = loadClassData(name);
        if (encryption != null) {
            byte[] decryption = new byte[encryption.length];
            for (int i = 0; i < encryption.length; i++) {
                decryption[i] = (byte) (255 - encryption[i]);
            }
            return defineClass(name, decryption, 0, decryption.length);
        }
        return super.findClass(name);
    }

    private byte[] loadClassData(String className) {
        try {
            return Files.readAllBytes(Paths.get("xar/Hello.xlass"));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) throws Exception {
        String className = "Hello";
        String methodName = "hello";

        HelloXlassLoader loader = new HelloXlassLoader();
        Class<?> loaderClass = loader.findClass(className);
        final Constructor<?> declaredConstructor = loaderClass.getDeclaredConstructor();
        final Object hello = declaredConstructor.newInstance();
        Method method = loaderClass.getMethod(methodName);
        method.invoke(hello);
    }
}
```

此外我们还能加载 jar 文件，如：

```java
public class HelloXarLoader extends ClassLoader {

   private final URLClassLoader urlClassLoader;

    public HelloXarLoader(String path) {
        try {
            URL xarUrl = new URL("file:\\" + path);
            urlClassLoader = new URLClassLoader(new URL[]{xarUrl});
        } catch (Exception e) {
            throw new RuntimeException("hello.xar 类加载器初始化失败!", e);
        }
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = name.replace('.', '/').concat(".xlass");
        try (InputStream in = urlClassLoader.getResourceAsStream(path)) {
            if (Objects.nonNull(in)) {
                byte[] encryption = new byte[in.available()];
                in.read(encryption);

                byte[] decryption = new byte[encryption.length];
                for (int i = 0; i < encryption.length; i++) {
                    decryption[i] = (byte) (255 - encryption[i]);
                }
                return defineClass(name, decryption, 0, decryption.length);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return super.findClass(name);
    }

    public static void main(String[] args) throws Exception {
        String path = "F:\\LearnProjects\\learn\\programing-language\\java\\jvm\\examples\\xar\\hello.xar";
        String className = "Hello";
        String methodName = "hello";

        HelloXarLoader loader = new HelloXarLoader(path);
        Class<?> loaderClass = loader.findClass(className);

        Object hello = loaderClass.newInstance();
        Method method = loaderClass.getMethod(methodName);
        method.invoke(hello);
    }
}
```

## 破坏双亲委派

有时候我们也会遇到破坏双亲委派的场景。

### 线程上下文类加载器

每个线程都有一个类加载器（JDK 1.2后引入），称之为 Thread Context ClassLoader，如果线程创建时没有设置，则默认从父线程中继承一个，如果在应用全局内都没有设置，则所有 Thread Context ClassLoader 为 `AppClassLoader`，换句话说，在默认情况下，我们可以通过线程对象来获取到 `AppClassLoader`。

> 具体来讲，我们可以可通过 `Thread.setContextClassLoader` 方法来设置类加载器，通过 `Thread.getContextClassLoader` 方法来获取设置的加载器，没有设置过获取到的类加载器就为 `AppClassLoader`，如下代码所示：
>
> ```java
> static void example() {
>     final Thread thread = Thread.currentThread();
>     // thread.setContextClassLoader(new CustomClassLoader());
>     final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
>     // default is AppClassLoader
>     log.info("Thread context class loader: {}", contextClassLoader);
> }
> ```

线程上下文加载器有什么用?

该类加载器容许父类加载器通过子类加载器加载所需要的类库，也就是打破了我们下文所说的双亲委派模型，这有什么好处呢？

我们先看一个 JDBC SPI 扩展的例子，首先 JDBC 是 Java 对外提供的一种 SPI，定义关系型数据库的访问 API，要接入的数据库供应商必须按照此标准来编写实现类，一般来讲我们在使用 JDBC 访问某种数据库时，首先我们要引入外部数据库对 JDBC 的实现依赖，也就是我们说的 JDBC 驱动包，然后我们通过 JDBC 编程来访问数据库，访问数据库的代码如下所示：

```java
private static void example() {
    String url = "jdbc:mysql://localhost:3306/test?useSSL=false&useUnicode=true&characterEncoding=UTF-8";
    String user = "root";
    String password = "";
    try (Connection conn = java.sql.DriverManager.getConnection(url, user, password)) {
        try (Statement stmt = conn.createStatement()) {
            try (ResultSet rs = stmt.executeQuery("select * from foo where id = 1")) {
                while (rs.next()) {
                    // 注意：索引从 1 开始
                    long id = rs.getLong(1);
                    String bar = rs.getString(2);
                    log.info("id: {}, bar: {}", id, bar);
                }
            }
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```

上述代码可以简单总结为：

- 我们通过 `java.sql.DriverManager.getConnection` 方法获取数据库连接；
- 通过获取到连接得到 `Statement` 对象；
- 通过 `Statement` 对象来执行 SQL 语句，返回 `ResultSet` 对象；
- 通过 `ResultSet` 对象我们就可以获取到表中的记录，进行一些其他的业务操作。

关于 JDBC SPI 扩展的机制，其扩展实现逻辑主要在通过 `java.sql.DriverManager.getConnection` 方法内实现，其实现代码如下所示：

```java
@CallerSensitive
public static Connection getConnection(String url, String user, String password) throws SQLException {
    java.util.Properties info = new java.util.Properties();

    if (user != null) {
        info.put("user", user);
    }
    if (password != null) {
        info.put("password", password);
    }

    return (getConnection(url, info, Reflection.getCallerClass()));
}

//  Worker method called by the public getConnection() methods.
private static Connection getConnection(String url, java.util.Properties info, Class<?> caller) throws SQLException {
    /*
     * When callerCl is null, we should check the application's (which is invoking this class indirectly)
     * classloader, so that the JDBC driver class outside rt.jar can be loaded from here.
     */
    ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
    if (callerCL == null || callerCL == ClassLoader.getPlatformClassLoader()) {
        callerCL = Thread.currentThread().getContextClassLoader();
    }

    if (url == null) {
        throw new SQLException("The url cannot be null", "08001");
    }

    println("DriverManager.getConnection(\"" + url + "\")");

    ensureDriversInitialized();

    // Walk through the loaded registeredDrivers attempting to make a connection.
    // Remember the first exception that gets raised so we can reraise it.
    SQLException reason = null;

    for (DriverInfo aDriver : registeredDrivers) {
        // If the caller does not have permission to load the driver then
        // skip it.
        if (isDriverAllowed(aDriver.driver, callerCL)) {
            try {
                println("    trying " + aDriver.driver.getClass().getName());
                Connection con = aDriver.driver.connect(url, info);
                if (con != null) {
                    // Success!
                    println("getConnection returning " + aDriver.driver.getClass().getName());
                    return (con);
                }
            } catch (SQLException ex) {
                if (reason == null) {
                    reason = ex;
                }
            }

        } else {
            println("    skipping: " + aDriver.getClass().getName());
        }
    }

    // if we got here nobody could connect.
    if (reason != null)    {
        println("getConnection failed: " + reason);
        throw reason;
    }

    println("getConnection: no suitable driver found for "+ url);
    throw new SQLException("No suitable driver found for "+ url, "08001");
}


```

关于这块代码，我们主要关注外部的驱动类时如何被加载的，比较特殊的是这段代码：

```java
/*
 * When callerCl is null, we should check the application's (which is invoking this class indirectly)
 * classloader, so that the JDBC driver class outside rt.jar can be loaded from here.
 */
ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
if (callerCL == null || callerCL == ClassLoader.getPlatformClassLoader()) {
    callerCL = Thread.currentThread().getContextClassLoader();
}
```

这段代码主要为了确定后续加载驱动类的类加载器，主要逻辑是，如果类加载器为空或者为 `PlatformClassLoader`，调用 `Thread.getContextClassLoader()`

替代，而这个方法默认会返回 `AppClassLoader` 。这样就能保证，外部驱动类也可以在这里被加载。

也就是说，这里如果是 `PlatformClassLoader` 的话会替换成 `AppClassLoader` 去加载（因为外部 jar 不在 `PlatformClassLoader` 的加载范围内），可以说这是对双亲委派类加载机制的一种破坏。

### 重写 loadClass 方法

我们知道 `ClassLoader` 双亲委派的逻辑是在 `loadClass` 方法中实现的，如果我们有自定义的类加载需求，可以重写 `loadClass` 去实现。

### 加载隔离

自定义类加载器有一个机制，就是不同类加载器加载的类在 JVM 看来是两个不同的类，不同类加载器加载的类之间不会相互影响或访问。

**类加载传导原则**，JVM 会选择当前类的类加载器来加载该类依赖的所有类，利用类加载的传导原则和自定义类加载器的隔离性，我们就可以实现不同模块的类由不同的类加载器去加载，不同模块可以去加载不同版本的类，并且之间不会相互影响。

比如我们可以先看一个依赖冲突的例子，A 和 B 分别依赖了 C 的 v1 和 v2 版本，v2 版本的比 v1 版本新增了一个方法，现在工程里面同时引入了 A、B 两个 jar 包，以及 C 的 v1、v2 版本，到了运行的时候，默认情况下一个项目的所有类都是用同一个类加载器加载的，所以不管你依赖了多少个版本的 C，最终只会有一个版本的 C 被加载到 JVM 中。当 B 要去访问 Log.error，就会发现 Log 压根就没有 error 方法，然后就抛异常`java.lang.NoSuchMethodError`。这就是类冲突的一个典型案例。

// TODO ...







## 总结

### 参考连接

- [Java-ThreadContextLoader（线程上线文类加载器） (daimajiaoliu.com)](https://www.daimajiaoliu.com/daima/4ed5b25271003f8)
- [AbstractMethodError in Java | Baeldung](https://www.baeldung.com/java-abstractmethoderror)

