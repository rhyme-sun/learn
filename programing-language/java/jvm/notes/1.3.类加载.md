# 类加载

我们编写的代码被编译成 class 文件后，Java 虚拟机负责 class 文件加载到内存，并对数据进行校验、准备、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型（Class 对象），这一过程被称作虚拟机的类加载机制。

## 类加载过程

类加载过程可以简单的使用下图来表示：

![](../images/类加载过程.png)

如上图所示，类加载过程可以简要的分为三个阶段：

- 加载
- 连接
  - 验证
  - 准备
  - 解析
- 初始化

### 加载

加载这一过程由类加载器（ClassLoader）来完成，类加载器将字节码以流的形式加载进内存，在元空间（方法区）生成类模板，并且在堆中生成其 Class 对象，做为访问元空间（方法区）中类模板信息的入口。

总结一句话就是，将 class 文件加载到方法区，并在堆内存中生成一个 class 对象，作为访问方法区类信息的入口。

### 连接

连接又可以分为三个步骤，验证、准备、解析：

#### 验证

验证主要为了确保被加载的类的正确性，包括文件格式验证、元数据验证、字节码验证、符号引用验证。

> 注：验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

#### 准备

准备阶段主要为了给类的静态变量分配内存，并将其初始化为默认零值（0，0L，null，false 等），这些变量使用的内存将在方法区中分配。

>注意：
>
>- 对于实例变量初始化零值这个过程不在类加载的准备阶段；
>- 准备阶段只是给静态变量赋零值，其赋我们编写代码声明值是在**初始化阶段**的 clinit 指令中进行，当然了，如果没有静态变量显式赋值，或者静态常量显式赋值（非字面量） ，则编译器不会生成 clinit 指令；
>- 对于使用 `static final` 修饰的静态常量，并且使用字面量（存放在常量池中，可以是基本类型和字符串字面量）给其显示赋值，那么在准备阶段变量就会被初始化为常量池属性所指定的值。

比如下面这个例子：

```java
@Slf4j
public class ClassLoadingProcedure {

    public static void main(String[] args) {
        // 2
        log.info("{}", Foo.count);
        // 3
        log.info("{}", Bar.count);
    }
}

class Foo {

    public static Foo foo = new Foo();
    /**
     * count 的值由 0 -> 1 -> 2
     */
    public static int count = 2;

    private Foo() {
        count++;
    }
}

class Bar {
    /**
     * count 的值由 0 -> 2 -> 3
     */
    public static int count = 2;
    public static Bar bar = new Bar();

    private Bar() {
        count++;
    }
}
```

如上述代码所示，由于有准备阶段的存在，类 Foo 的属性 count 值的变化过程为 0 -> 1 -> 2；类 Bar 的 count 值的变化过程为 0 -> 2 -> 3，详细来讲：

- 我们知道类再加载到内存后，先后由准备和初始化阶段，准备阶段会给静态变量赋默认值，初始化阶段会给静态变量赋初始值，所以 Foo 和 Bar 的 count 的值首先都为默认值 0；
- 初始化的过程中会给静态属性赋初始值，静态属性的赋值顺序和代码编写顺序一致，即从上到下依次赋值，对于 Foo 来讲，先执行构造方法，进行了加一操作，count 的值由 0 变成 1，然后给 count 赋值为 2，count 的值最终为 2；对于 Bar 来讲，先给 count 值赋值为 2，count 的值由 0 变成 2，再执行构造方法，进行加一操作，count 的值最终为 3。

#### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

初始化过程中会对静态变量、非字面量赋值的静态常量进行赋值。

#### 初始化的时机（主动引用）

初始化发生再类加载阶段的最后一个步骤，我们也可以近似理解为类加载的时机。而实际上，什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。

- 遇到 `new`、`getstatic`、`putstatic` 或 `invokestatic` 这四条字节码指令时，如果类没有进行初始化，则需要先对其进行初始化，生成这四条指令的最常见的场景是：
  - 使用 new 关键字实例化对象的时候；
  - 读取或设置一个静态字段（静态常量，并用字面量显示赋值的除外）的时候；

  - 调用一个类型的静态方法的时候；

- 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候；

- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；

- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main  方法的那个类），虚拟机会先初始化这个主类。

#### 不会触发初始化（被动引用）

- **通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化**；

- **定义对象数组，不会触发该类的初始化**；

- 调用静态常量，且该常量使用字面量进行赋值，其本质上并没有直接引用定义常量的类，不会触发初始化；

- 通过类名获取 Class 对象（字面常量方式），不会触发类的初始化；

  > 通过 `Class.forName(String className)`  会触发类的初始化。
  >
  > 我们也可以再调用该方法时指定是否需要初始化，方法如下所示：
  >
  > ```
  > public static Class<?> forName(String name, boolean initialize, ClassLoader loader) {
  > 	// ...
  > }
  > ```

- 外部类在加载时不会加载内部类，自然也不会初始化。

#### 初始化顺序

关于初始化顺序：

- 没有调用构造方法时（静态变量初始化），初始化顺序如下：

  父类静态变量->子类静态变量->父类静态代码块->子类静态代码，且每部分的初始化顺序和代码编写顺序保持一致。

- 若调用构造方法加载类时，初始化顺序如下：

  父类静态变量->子类静态变量->父类静态代码块->子类静态代码->父类变量->父类代码块->父类构造器->子类变量->子类代码块->子类构造器，且每部分的初始化顺序和代码编写顺序保持一致。

比如以下代码：

```java
public class ClassInitializingSequence {

    public static void main(String[] args) {
        /**
         * 调用了子类构造方法，输出结果：
         *
         * 1.1.Parent's static attribute1.
         * 1.2.Parent's static attribute2.
         * 2.Parent's static code block.
         * 3.1.Child's static attribute1.
         * 3.2.Child's static attribute2.
         * 4.Child's static code block.
         * 5.Parent's attribute.
         * 6.Parent's code block.
         * 7.Parent's constructor.
         * 8.Child's attribute.
         * 9.Child's code block.
         * 10.Child's constructor.
         */
        Child child = new Child();

        /**
         * 调用了子类的静态属性，输出结果：
         *
         * 1.1.Parent's static attribute1.
         * 1.2.Parent's static attribute2.
         * 2.Parent's static code block.
         * 3.1.Child's static attribute1.
         * 3.2.Child's static attribute2.
         * 4.Child's static code block.
         */
        // Consumer childConsumer = Child.staticConsumer2;

        /**
         * 调用了父类的静态属性，输出结果：
         *
         * 1.1.Parent's static attribute1.
         * 1.2.Parent's static attribute2.
         * 2.Parent's static code block.
         */
        // Consumer parentConsumer = Parent.staticConsumer1;

        /**
         * 调用了外部类的静态属性，输出结果：
         *
         * Outer class's static attribute.
         */
        // Consumer outerConsumer = Outer.outerConsumer;

        /**
         * 调用了外部了的静态属性，输出结果：
         *
         * Inner class's static attribute.
         */
        // Consumer innerConsumer = Outer.Inner.innerConsumer;
    }
}

class Parent {

    static Consumer staticConsumer1 = new Consumer("1.1.Parent's static attribute1.");
    static Consumer staticConsumer2 = new Consumer("1.2.Parent's static attribute2.");
    Consumer consumer = new Consumer("5.Parent's attribute.");

    static {
        System.out.println("2.Parent's static code block.");
    }

    {
        System.out.println("6.Parent's code block.");
    }

    Parent() {
        System.out.println("7.Parent's constructor.");
    }
}

class Child extends Parent {

    static Consumer staticConsumer1 = new Consumer("3.1.Child's static attribute1.");
    static Consumer staticConsumer2 = new Consumer("3.2.Child's static attribute2.");
    Consumer consumer = new Consumer("8.Child's attribute.");

    static {
        System.out.println("4.Child's static code block.");
    }

    {
        System.out.println("9.Child's code block.");
    }

    Child() {
        System.out.println("10.Child's constructor.");
    }
}

class Outer {

    static Consumer outerConsumer = new Consumer("Outer class's static attribute.");

    static class Inner {

        static Consumer innerConsumer = new Consumer("Inner class's static attribute.");
    }
}

class Consumer {

    Consumer(String s) {
        System.out.println(s);
    }
}
```

从上述代码的打印结果可知，类的初始化有以下特征：

- 对于静态和非静态，先进行静态部分初始化，且只有当调用了构造方法后才会对非静态的属性进行初始化；

- 对于静态代属性和静态代码块，先初始化静态属性；

- 对于成员属性，类代码块，构造函数，先初始化成员属性，再初始化类代码块，最后才是构造函数；

- 对于同一级别的初始化顺序和代码编写一致，即从上到下依次执行，如对于类的多个静态属性，先对最上方的属性进行初始化；

- 对于父类和子类

  - 调用了子类的静态变量，加载子类前会加载父类，先进行父类的静态初始化，再进行子类的静态部分初始化；若调用了构造方法，先对父类的非静态部分进行初始化，再对子类的非静态部分进行初始化；
  - 调用了父类的静态变量，不会去加载子类；

- 对于外部类和内部类

  - 调用了内部类的静态属性，不会去加载外部类；

  - 调用了外部类的静态属性，不会去加载内部类，利用这一特性，可以实现单例的延迟初始化，如下所示：

    ```java
    /**
     * 使用静态内部类延迟初始化单例
     *
     * 静态内部类，外部类被加载时，不会加载{@link SingletonHolder}，只有{@link StaticInnerClassSingleton#getInstance()}
     * 被调用时，才会被加载并创建instance，这样便做到了延迟加载
     */
    public class StaticInnerClassSingleton {
    
        private StaticInnerClassSingleton() {
        }
    
        public static StaticInnerClassSingleton getInstance() {
            return SingletonHolder.instance;
        }
    
        /**
         * 当 StaticInnerClassSingleton 被加载时，SingletonHolder不会被加载
         */
        public static class SingletonHolder {
            private static StaticInnerClassSingleton instance = new StaticInnerClassSingleton();
        }
    }
    ```

#### 指令重排对象初始化的影响

对象初始化（new 一个对象）的过程中也分为两步，先分配空间并给成员变量赋值默认值，再赋初始值。

一个双重检测的单例模式代码如下所示：

```java
/**
  * 双重检测的单例模式。
  */
public class DoubleCheckSingleton {

    /**
     * 因为指令重排序，可能会导致对象被 new 出来，然后赋值给 instance ，还没来得及执行构造函数中的代码逻辑，就被另一个线程使用
     * 了，这时候另外的线程就会使用到类半初始化的属性值，这显然是不符合我们预期的，使用 volatile 关键字是为了禁止指令重排。
     */
    private volatile static DoubleCheckSingleton instance;

    private DoubleCheckSingleton() {
    }

    public static DoubleCheckSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```

new 一个对象所执行的操作码如下所示：

```
// Object o = new Object();

0 new #2 <java/lang/Object>
3 dup
4 invokespecial #1 <java/lang/Object.<init>>
7 astore_1
8 return
```

分析指令重排对 `DoubleCheckSingleton` 带来的影响：

new 一个对象会经过以上几个步骤，其中 4 为开辟一块内存，先分配空间并给成员变量赋值默认值；7 为给成员变量赋初始值。那么对于上述单例代码而言，若不使用 volatile，指令重排可能导致 7 比 4 先执行，那么可能在并发条件下，有的线程拿到了创建好但还未来得及初始化的对象。

## 总结

Java 中的类加载就是将 class 文件加载到方法区，并且在堆内存中生成 class 对象，期间也会对 class 文件信息进行验证，准备、解析和初始化工作，以保证后续我们能够正确的使用该类。

熟悉类的加载过程很有必要，比如我们可以知道 Java 中的静态变量不是直接初始化成我们编码时声明的值，而是有一个在方法区分配内存，初始化零值的过程。此外我们还讨论了类的初始化时机和顺序，熟悉了这些也有助于降低我们在编写代码时的心智负担。

### 参考连接

- [JVM类生命周期概述-CSDN博客](https://blog.csdn.net/justloveyou_/article/details/72466105)

- [关于JVM类加载机制，看这一篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/6865572557329072141)