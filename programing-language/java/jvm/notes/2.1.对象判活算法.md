# 对象判活算法

对象判活算法通过标记存活对象来和垃圾对象进行区分，这样垃圾收集器就可以对未标记的对象进行自动回收，常见的有引用计数法和引用追踪法。

## 引用计数法（`ReferenceCount`）

使用引用计数法判断对象是否存活的逻辑大概是这样的：给每个对象实例维护一个引用计数器，每当一个地方引用了这个对象后计数器加 1，当引用失效时（别的对象不在引用它），计数器减一。在任何时候引用计数器为 0 的对象就可以回收。

引用计数法的缺点是无法解决循环引用问题，比如对象 A 引用了对象 B，同时对象 B 也引用了对象 A，A 回收需要等 B 对它的引用失效，B 回收需要等 A 对它的引用失效，这样就形成了一个环，导致两个对象引用计数一直至少为 1，无法回收，如下图所示：

![](../images/循环引用.png)

> 图片来自于：[垃圾收集简介 - GC参考手册_铁锚的CSDN博客](https://blog.csdn.net/renfufei/article/details/53432995)

## 引用追踪法

引用追踪法（`RootSearching`）或者叫根可达算法，通过一系列的称为 `GC Roots` 的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 `GC Roots` 没有任何引用链相连时，则证明此对象是不可用的，根可达算法最大的优势是不会再因为循环引用造成内存泄漏，如下图所示：

![](../images/根可达算法.png)

> 图片来自于：[垃圾收集简介 - GC参考手册_铁锚的CSDN博客](https://blog.csdn.net/renfufei/article/details/53432995)

> JVM 中 GC Roots 可能是哪些对象？
> 线程栈变量，静态变量，运行时常量池，JNI 指针，Class 对象。

## 总结

### 参考链接

- [垃圾收集简介 - GC参考手册_铁锚的CSDN博客](https://blog.csdn.net/renfufei/article/details/53432995)