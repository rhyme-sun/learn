# Java 引用类型



无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。

在 JDK 1.2 版之前，Java里面的引用是很传统的定义：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用。

这种定义导致对象的引用只有引用和被引用两种状态。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应用场景。

为此 JDK 1.2 版本后，对 Java 引用类型进行了扩充。将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。

引用关系决定了垃圾回收时对这些对象的回收行为。



强引用是传统意义上的引用关系，代码中的引用赋值就是这种关系，比如 `Object obj = new Object()`。无论任何情况下，只要强引用关系还 GC Roots 链上，垃圾收集器就永远不会回收掉被引用的对象。



软引用是用来描述一些还有用，但非必须的对象。**只**被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 `SoftReference` 类来实现软引用。



弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 `WeakReference` 类来实现弱引用。



虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 `PhantomReference` 类来实现虚引用。



关于引用的应用可看：

[Java的强引用，软引用，弱引用，虚引用及其使用场景 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1354351)