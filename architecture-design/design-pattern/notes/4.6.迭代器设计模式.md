# 迭代器设计模式

迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern），迭代器用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。



一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。容器中需要定义 iterator() 方法，用来创建迭代器。迭代器接口中需要定义 `hasNext()`、`currentItem()`、`next()` 三个最基本的方法。容器对象通过依赖注入传递到迭代器类中。



## 迭代器的意义

为什么要给容器设计迭代器呢？

迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。

迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。

迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。



总的来说，**迭代器将容器（数据结构）的迭代行为解耦出来**。



遍历集合的同时，为什么不能增删集合元素？

在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。



解决方案

- 遍历的时候不允许增删元素。

- 增删元素之后让遍历报错（fail-fast）。这也是 Java 中的做法。

  在 `ArrayList` 中定义一个成员变量 `modCount`，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 `modCount` 加 1。
  当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 `modCount` 值传递给迭代器的 `expectedModCount` 成员变量。
  之后每次调用迭代器上的 `hasNext()`、`next()`、`currentItem()` 函数，我们都会检查集合上的 `modCount` 是否等于 `expectedModCount`。
  如果两个值不相同，那就说明集合存储的元素已经改变了，表明之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果。
  这时候选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员知道在迭代过程中出现了容器修改行为。

