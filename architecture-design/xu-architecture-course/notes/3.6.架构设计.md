# 架构设计

原文链接：[45 | 架构：怎么做详细设计？ (geekbang.org)](https://time.geekbang.org/column/article/142032)

关于架构，有以几个阶段：

- **需求分析**并不是纯技术的东西，和编程这件事情无关。它关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。

  需求分析的目标和最终结果，都是要最终形成清晰的**产品定义**。产品定义将明确产品的元素，明确产品的边界，与产业上下游、合作伙伴的分工。

  在需求分析阶段，我们关注用户需求的精确表述。我们会引入角色，也就是系统的各类参与方，以及角色间的交互方式，也就是**用户故事**。

  

  用户故事在软件开发过程中被作为描述需求的一种表达形式；为了规范用户故事的表达，便于沟通；包含角色、活动、价值三个要素。

  - 角色（who）：谁要使用这个；
  - 活动（what）：要完成什么活动；
  - 价值（value）：为什么要这么做，这么做能带来什么价值。

  用户需求的描述格式：作为<用户角色>，我想要<完成活动>，以便于<实现价值>。

  关于用户故事更多可参考：[用户故事（一）：什么是用户故事？ | 人人都是产品经理 (woshipm.com)](http://www.woshipm.com/user-research/1725827.html)

- 在**概要设计**阶段，我们一般以**子系统**为维度来阐述系统各个角色之间的关系。对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。

  这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是**串联子系统**。如果某个子系统不做进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。

  为了降低风险，概要设计阶段也应该有代码产出。

  这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。

  代码即文档。代码是理解一致性更强的文档。

- **详细设计**阶段，是需要各个子系统或模块的负责人，对他负责的部分进行进一步的细化。

  详细设计关注的是子系统或模块的全貌。

  详细设计并不是只谈实现就完事，更不是一个架构图。它包括以下这些内容：

  - **现状与需求**：现在在哪里，遇到了什么问题，要做何改进。
  - **需求满足方式**：要做成啥样？交付物的规格，或者说使用界面（接口）；怎么做到？交付物的实现原理。

## 现状与需求

从逻辑自洽的角度，我们任何一篇文档，首先关注的都应该是要解决的问题与目标。

现状与需求的陈述，要简明扼要。

现状大家都知道，所以不要长篇累牍。更多的是陈述与我们要做的改变相关的重要事实，侧重点在于强调这些事实的存在性和重要性。

需求陈述是对痛点和改进方向的一次共识确认。痛点只要够痛，大家都知道，所以同样不需要长篇累牍。

每个子系统或模块，都有自己的角色分工与用户故事。我们不用重新做一遍需求分析，但对需求分析的核心结论，在详细设计开始之前需要明确。

## 使用界面（接口）

规格，或者说使用界面，体现的是别人要怎么使用我。

我们前面一直在强调，**使用界面（接口）应该自然体现业务需求**，就是强调程序是为用户需求服务的。而我们的架构设计，在需求分析与后续的概要设计、详细设计等过程之间也要有自然的延续性。

使用界面这一部分要详细写，它是团队共识确认的关键。

需要强调的是，使用界面需要有明确的书写规范。它也是团队共识管理的重要组成，是团队效率、团队默契形成的象征。

更需要强调的是，使用界面的稳定是至关重要的。接口的变更需谨慎！

对使用界面的不兼容调整，可能出现严重的后果。技术上，可能会导致客户异常，出现编译失败需要重写代码，或者更严重的是，可能导致他们的系统崩溃。商业上，则可能导致大量的客户流失。

## 实现（数据结构 + 算法）

数据结构从大的层面分，可分为基于内存的数据结构，和基于外存（比如 SSD 盘）的数据结构。

对于桌面程序，大部分情况下我们打交道的都是基于内存的数据结构。外存数据结构也会有所涉及，但往往局限于 IO 子系统。

但对于服务端程序，数据结构不完全是我们自己能够做主的。数据结构大部分情况下都是基于外存的，而且有极高的质量要求。

**存储即数据结构**。所以，服务端程序在数据结构这一点上，最为重要的一件事是选择合适的存储中间件。然后我们再在该存储中间件之上组织我们的数据。

这是数据库这样的存储中间件流行起来的原因。无论是关系型数据库，还是文档型数据库，他们都被设计为一种泛业务场景的数据结构，有很好的业务适应性。所以在服务端我们谈数据结构，谈的不是内存数据结构，往往谈的是数据库的表结构设计。

描述表结构，核心需要包含以下内容：

- 字段名；
- 类型；
- 字段含义，以及是否指向另一个表的字段；
- 索引。

你会发现，其实定义表结构和定义内存数据结构本质是完全一致的。定义内存中的一个类（或结构体），我们也关心字段名（成员变量名）和类型，也关心字段的含义，以及它是否指向另一个类（或结构体）的某个字段（成员变量），但表结构比内存数据结构多了一个概念：索引。



在架构过程中，需求分析阶段，我们关注用户需求的精确表述，我们会引入角色，也就是系统的各类参与方，以及角色间的交互方式，也就是用户故事。

到了详细设计阶段，角色和用户故事就变成了子系统、模块、类或者函数的使用界面（接口）。我们前面一直在强调，使用界面（接口）应该自然体现业务需求，就是强调程序是为用户需求服务的。而我们的架构设计，在需求分析与后续的概要设计、详细设计等过程之间也有自然的延续性。

所以算法，最直白的含义，指的是用户故事背后的实现机制。数据结构 + 算法，是为了满足最初的角色与用户故事定义，这是架构的详细设计阶段核心关注点。

怎么描述一个用户故事对应的算法？

- 一种方式是基于 UML 时序图（Sequence Diagram），在线时序图制作：[WebSequenceDiagrams](https://www.websequencediagrams.com/)

- 另一种方式是基于伪代码（Pseudo Code）。

