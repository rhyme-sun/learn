# 	总结

软件工程的瀑布模型：

![](../images/软件工程瀑布模型.png)

## 基础架构

“基础平台” 是我们所依赖的环境，是我们应用的业务架构的一部分。越了解我们所处的环境，我们就越能够运用自如。对基础架构了解的越全面，做业务架构就会越从容，并且从基础架构到业务架构过度也会更加紧密自然。

这个基础架构包含哪些内容？

- 其一，基础平台。包括：冯·诺依曼体系、编程语言、操作系统。
- 其二，桌面开发平台。包括：窗口系统、GDI 系统、浏览器与小程序。当然我们也要理解桌面开发背后的架构逻辑，MVC 架构。
- 其三，服务端开发平台。包括：负载均衡、各类存储中间件。服务端业务开发的业务逻辑比桌面要简单得多。服务端难在如何形成有效的基础架构，其中大部分是存储中间件。
- 其四，服务治理平台。主要是以容器技术为核心的 DCOS（数据中心操作系统），以及围绕它形成的整个服务治理生态。这一块还在高速发展过程中，最终它将让服务端开发变得极其简单。

## 需求分析

### 为什么需要需求分析？

软件存在的本身就是为了满足用户的需求，那么，用户的需求为何，我们需要明确定义。

### 如何做需求分析？

首先，心态第一，心里得装着客户，除了需要有在心里反复推敲需求得严谨态度外，还需要对客户得反馈有尊重之心。

然后，抓住根源需求。

最后，对需求进行归纳整理，将需求分别归类到不同的子系统中，形成需求得变化点和稳定点判断。稳定点往往系统得核心能力，而变化点则需要对应地去考虑扩展性上的设计。

### 需求分析的产出

产品定义和用户故事。

**需求分析**并不是纯技术的东西，和编程这件事情无关。它关乎的是用户需求的梳理、产品的清晰定义、可能的演变方向。

需求分析的目标和最终结果，都是要最终形成清晰的**产品定义**。产品定义将明确产品的元素，明确产品的边界，与产业上下游、合作伙伴的分工。



需求分析阶段，我们关注用户需求的精确表述。我们会引入角色，也就是系统的各类参与方，以及角色间的交互方式，也就是会产出**用户故事**。

用户故事在软件开发过程中被作为描述需求的一种表达形式；为了规范用户故事的表达，便于沟通；包含角色、活动、价值三个要素。

- 角色（who）：谁要使用这个；
- 活动（what）：要完成什么活动；
- 价值（value）：为什么要这么做，这么做能带来什么价值。

用户需求的描述格式：作为<用户角色>，我想要<完成活动>，以便于<实现价值>。

## 概要设计

概要设计，或者叫系统设计。简单来说就是 “对系统进行分解” 的能力。这个阶段核心要干的事情，就是明确子系统的职责边界和接口协议，把整个系统的大框架搭起来。系统分解是领域性的问题，依赖于你对用户需求的理解，你对需求分析理解的也深刻，越熟悉，做出的分解便越合理。

架构就是业务的正交分解，作为架构师，我们需要坚持对业务进行正交分解的信念，要坚持不断地探索各类需求的架构分解方法。

### 分解系统优劣的评判标准

分解系统前，首先我们需要明确的是**分解系统优劣的评判标准**。也就是说，我们需要知道什么样的系统分解方式是好的，什么样的分解方式是糟糕的。

最朴素的评判依据，是这样两个核心的点：

- 功能的使用界面（或者叫接口），应尽可能符合业务需求对它的自然预期；

- 功能的实现要高内聚，功能与功能之间的耦合尽可能低。

在软件系统中有多个层次的组织单元：子系统、模块、类、方法 / 函数。子系统如何分解模块？模块如何分解到更具体的类或函数？每一层的分解方式，都遵循相同的套路。也就是分解系统的方法论。

###  如何分解系统

首先，系统分解是领域性的问题，依赖于你对用户需求的理解，比如在桌面程序开发领域，我们习惯使用 MVC 架构去分解子系统。

然后，从**需求归纳**出发。用户需求分析清楚很重要。把需求功能点涉及的数据（对象）、操作接口理清楚，并归纳整理，把每个功能都归于某一类。然后把类与类的关系理清楚，做到逻辑上自洽，那么一个基本的系统框架就形成了。

在系统的概要设计阶段，我们一般以子系统为维度来阐述系统各个角色之间的关系。

对于关键的子系统，我们还会进一步分解它，甚至详细到把该子系统的所有模块的职责和接口都确定下来。但**这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来**。如果某个子系统不作进一步的分解也不会在项目上有什么风险，那么我们并不需要在这个阶段对其细化。

### 概要设计的产出

子系统和其之间的关系。

在系统的概要设计阶段，我们一般以子系统为维度来阐述系统各个角色之间的关系。**这个阶段我们的核心意图并不是确定系统完整的模块列表，我们的焦点是整个系统如何被有效地串联起来**

为了降低风险，系统的概要设计阶段也应该有代码产出。

- 这个阶段的代码，其一，系统的初始框架代码。也就是说，系统的大体架子已经搭建起来了。其二，原型性的代码来验证。一些核心子系统在这个阶段提供了 mock 的系统。

- 这样做的好处是，一上来我们就关注了全局系统性风险的消除，并且给了每个子系统或模块的负责人一个更具象且确定性的认知。

代码即文档。代码是理解一致性更强的文档。

## 详细设计

### 详细设计的产出

详细设计关注的是**子系统或模块的全貌**。

详细设计并不是只谈实现就完事，更不是一个架构图。它包括以下这些内容：

- **现状与需求**：现在在哪里，遇到了什么问题，要做何改进。
- **需求满足方式**：要做成啥样？交付物的规格，或者说使用界面（接口）；怎么做到？交付物的实现原理。

### 现状与需求

现状与需求的陈述，要简明扼要。更多的是陈述与我们要做的改变相关的重要事实，侧重点在于强调这些事实的存在性和重要性。

需求陈述是对痛点和改进方向的一次共识确认。痛点只要够痛，大家都知道，所以同样不需要长篇累牍。

### 使用界面（接口）

在架构过程中，需求分析阶段，我们关注用户需求的精确表述，我们会引入角色，也就是系统的各类参与方，以及角色间的交互方式，也就是用户故事。

到了详细设计阶段，角色和用户故事就变成了子系统、模块、类或者函数的使用界面（接口）。我们前面一直在强调，使用界面（接口）应该自然体现业务需求，就是强调程序是为用户需求服务的。而我们的架构设计，在需求分析与后续的概要设计、详细设计等过程之间也有自然的延续性。



规格，或者说使用界面，体现的是别人要怎么使用我。

我们前面一直在强调，**使用界面（接口）应该自然体现业务需求**，就是强调程序是为用户需求服务的。而我们的架构设计，在需求分析与后续的概要设计、详细设计等过程之间也要有自然的延续性。

使用界面这一部分要详细写，它是团队共识确认的关键。需要强调的是，使用界面需要有明确的书写规范。更需要强调的是，使用界面的稳定是至关重要的。

### 实现（数据结构 + 算法）

基于内存的数据结构，对象。

基于存储器的数据结构，表，存储即数据结构。



算法，最直白的含义，指的是用户故事背后的实现机制。数据结构 + 算法，是为了满足最初的角色与用户故事定义，这是架构的详细设计阶段核心关注点。

怎么描述一个用户故事对应的算法？

- 一种方式是基于 UML 时序图（Sequence Diagram），在线时序图制作：[WebSequenceDiagrams](https://www.websequencediagrams.com/)

- 另一种方式是基于伪代码（Pseudo Code）。

## 代码测试与管理

我们把软件或软件的某项功能生命周期分成两个大的阶段，一个阶段是开发期，一个阶段是维护期。开发期与维护期是相对而言的，只是在表征上，开发期有更强的设计属性。维护期虽然也持续会有设计工作，但是工作量会小一个数量级以上。

- 虽然功能开发阶段的成本是非常显性的，但是功能维护期，包括了功能迭代和售后维保，它的隐性成本往往更高。

- 产品的功能开发期虽然有可能很短，但是它是起点，是源头。它每一分每一秒时间是怎么花的，很大程度上决定了这个产品或功能的最终维护代价。

因为开发期的时间跨度虽然可能不长，但是它的影响太大了，基本决定了后期维护期的成本有多高。这也意味着软件工程是需要有极强预见性的工程。我们在开发期恰如其分地多投入一分精力，后面在维护期就有十倍甚至百倍以上的回报。设计工作的质量至关重要。但是它执行上又不太有复制性，可复制的只是设计范式和设计思维。我们只能在这种执行的不确定性中找工程上的确定性。

### 单元测试

相比于自动化测试，手工测试，有以下缺点：

- 其一，一般常规测试是基于手工的，**不具备可回归性**。因此，常规测试的效率不高，一次完整的测试集跑下来可能需要几天甚至一周之久。
- 其二，易于缺乏效率，所以往往为了赶工会导致测试仅仅针对典型数据，测试的覆盖率往往也很低。

软件工程的生命周期往往几年甚至几十年之久，我们必然关注单次测试的效率。所以**自动化测试的核心价值就在于可回归性与提高测试的覆盖率**。

从分类来说，一般自动化测试我们分两个层次：一个是模块级的单元测试，一个是系统级的集成测试。



对于单元测试和集成测试，从测试成本上来看：

- 其一，单元测试的实施成本低，最容易去做。不少高级语言比如 Go 语言甚至在语言内建的工具链上就直接支持。而集成测试虽然也有自动化的方法和支持工具，但是往往需要更高额的代价。
- 其二，减少问题发现的周期，进而降低问题的修复成本。单元测试将问题发现周期缩短，基本上在问题现场就发现问题，这降低了 Bug 的修复成本。如果问题在系统的集成测试阶段发现，那么从问题定位，到回忆当初实现这段代码时候的思路，到最终去解决掉它，必然需要多花费几倍甚至几十倍的时间。

因此，我们鼓励更严格的单元测试要求，更高的单元测试覆盖率，以尽可能把发现问题做到前头。

### CI&CD

其次，我们降低软件工程不确定性的方法是：持续构建，持续发布。

我们鼓励更小的发布。我们鼓励更短的发布周期，更高的发布频率。这能够让每次发布的负担降低到最低。

这种极度高频交付的机制与传统工程的质量管理机制迥异。但是它被证明是应对软件工程不确定性的最佳方式。为什么会这样？

- 其一，交付的功能越少，因为错误而发生回滚的代价越低，影响面越小。如果我们同时发布了数十个功能，却因为某一个功能不达标而影响整体交付，这其实是降低了软件的功能交付效率。更好的方式显然是把这个出问题的功能回滚，把其他所有功能都放行

- 其二，交付频率越高，我们对交付过程的训练越频繁，过程的熟练度越高，执行效率也越高。当交付成为一个自然习惯后，我们会把交付看作功能开发的一部分，而不是以前大家对研发的理解，认为做完功能就完事，后续上不上线与我无关。我们会鼓励更多把研发的绩效与功能线上的表现关联起来，面向客户价值，而非仅仅面向功能开发。

## 产品发布管理

版本只读设计。

只读设计提升了软件工程的确定性，所以只读思想被广泛运用。前面我们说开闭原则背后的架构治理哲学，也是模块，或者说软件实体，其业务范畴只读。在业务只读，接口稳定的预期下，模块与模块之间就可以自由组合，构建越来越复杂的系统。

### 版本兼容性问题

本管理的最后一个问题是兼容性。让一个模块依赖另一个模块（严谨来说是发布单元）的特定版本，这解决了版本的确定性问题。

但是，在某个特定的时刻，我们总是会希望将依赖的模块升级到新版本。无论是基于我们需要使用该模块的新功能，又或者是为了修复的 Bug，或者纯粹是心理上想要更好的东西。更换到新版本多多少少冒了一些风险。这里面最大风险是所依赖的模块完成了一次重构

兼容一个模块的主体功能并不复杂，既然我们重构了，这部分肯定是得到了解决。但兼容的难度全在细节上。错误码、低频的分支行为等等，这些都需要兼容。如果这种分支兼容太麻烦，我们干脆就放弃兼容，连软件实体（如函数）的名字都改了。这倒是干脆，客户升级版本后一看，编译不过了，老老实实用新的接口进行重写，重新测试。

有时候我们无法放弃兼容。这发生在我们在做一个互联网服务时。一旦我们发布了一个 api，它就很难收回，因为使用这个 api 的客户端可能有很多。如果我们放弃这个 api 就意味着我们放弃了很多用户，这是不可接受的。为了应对这个问题，比较常见的做法是为所有 api 引入版本号，如 “/v2/foo/bar”。当我们对 api 发生不兼容的修改时，就升级版本号，比如 “/v3/foo/bar”。

这样做有一个额外的好处。如果我们对某个复杂模块进行了全局重构，并且兼容老版本的行为细节非常困难时，我们可以直接升级所有 api 的版本号。这样在线上我们可以保留两个版本的服务同时存在。这通过前面放 nginx 作为 api 分派的网关来做到。这样两个版本服务并行，就不需要重构时做太细节的行为兼容。但应当注意，这也是不得已的办法，如果能够兼容，还是鼓励尽可能去兼容。毕竟客户端在升级版本之后，不兼容的地方越多，修改的心智负担就越大

## 线上服务管理



## 重要认知

### 核心系统与周边系统

架构的本质是业务的正交分解，我们可以将业务分解未不同模块。对于任何一个业务，它总可以分解出一个核心系统，和多个周边系统。

对于核心系统：

- 一定要稳定，需求要收敛。若一个需求是发散了，那么它就不适合放到核心系统。
- 不论后续模块怎么演化，保持核心系统的纯洁性比什么都重要。

对于周边系统：

- 不同的周边系统应该相互正交，自己做的足够内聚。即使他们可能会发生关联，也是通过与核心系统打交道来建立彼此的间接联系。
- 周边系统依赖核心系统，但对核心系统的依赖要是稳定的，伤害值要是小的。

### 开闭原则

总结来说，开闭原则包含以下两层含义：

- 第一，模块的业务要稳定。模块的业务遵循 “只读” 设计，如果需要变化不如把它归档，放弃掉。这种模块业务只读的思想，是很好的架构治理的基础哲学。

  这告诉我们，软件是可以以 “搭积木” 的方式搭出来的。核心的一点是，我们如何形成更多的 “积木”，即一个个业务只读、接口稳定、易于组合的模块。

- 第二，模块的业务变化点，简单一点的，通过回调函数或者接口开放出去，交给其他的业务模块。复杂一点的，通过引入插件机制把系统分解为 “最小化的核心系统 + 多个彼此正交的周边系统”。回调函数或者接口本质上就是一种事件监听机制，所以它是插件机制的特例。

### 架构武器库

作为架构师，我们需要坚持对业务进行正交分解的信念，要坚持不断地探索各类需求的架构分解方法。这样的思考多了，我们就逐步形成了各种各样的架构范式，从而形成我们架构的武器库。

架构师的武器库不是一个一个的设计原则，尽管它们很重要；架构师应该沉淀出一个一个问题域下的设计场景作为自己的武器库，当你需要面对一个新的业务场景（领域）时能够把自己所要解决的业务场景分解为多个 “通用的设计场景” 的组合。

这些架构范式，并不仅仅是一些架构思维，而是 “一个个业务只读、接口稳定、易于组合的模块 + 组合的方法论”，它们才是架构师真正的武器库。这个武器库包含哪些内容？

- 首先，它应该包括信息科技形成的基础架构。努力把前辈们的心血，变成我们自己真正的积累。光会用还不够，以深刻理解它们背后的架构逻辑，确保自己与基础架构最大程度上的 “同频共振”。只有让基础架构完全融入自己的思维体系，同频共振，我们才有可能在架构设计需要的时候 “想到它们”。

  基础架构最开始也是由业务架构开始的，随着业务架构不断深入理解的过程，越来越多的共性需求从业务架构抽离出来，成为信息科技的基础设施。**我们要了解它的来龙去脉，体会它的迭代方式和设计意图，将基础架构收敛到一个具体的架构场景，当作一次架构实战案例去学习**，而不是单单会使用它，这样基础架构才能成为我们的武器库的一员。

  从体系结构来说，这个基础架构包含哪些内容？

  - 其一，基础平台。包括：冯·诺依曼体系、编程语言、操作系统。
  - 其二，桌面开发平台。包括：窗口系统、GDI 系统、浏览器与小程序。当然我们也要理解桌面开发背后的架构逻辑，MVC 架构。
  - 其三，服务端开发平台。包括：负载均衡、各类存储中间件。服务端业务开发的业务逻辑比桌面要简单得多。服务端难在如何形成有效的基础架构，其中大部分是存储中间件。
  - 其四，服务治理平台。主要是以容器技术为核心的 DCOS（数据中心操作系统），以及围绕它形成的整个服务治理生态。这一块还在高速发展过程中，最终它将让服务端开发变得极其简单。

  消化基础架构成为架构师自身的本领，远比消化架构设计原则，架构思维逻辑要难得多。但从深入了解基础架构做起，是成为一个优秀架构师的必经之路。

- 然后，理解了这些基础架构，再加上你自己所处行业的领域知识，便能设计出一个好的业务系统。

### 团队协同共识

从共识来讲，架构这个活动也是一次团队协同共识形成的过程。

软件工程是一项团体活动，大家有分工更有协同。不同的个体因为能力差别，可以形成十倍以上的生产力差距。而不同团体更是如此，他们的差距往往可以用天壤之别来形容。这差距背后的原因，关乎的是协同的科学。

团队的共识分很多层次。

- 其一，团队是不是有共同的目标。
- 其二，团队是不是有共同的行事做人的准则。
- 其三，对产品与市场的要与不要，以及为什么要或为什么不要，是否已达成一致。
- 其四，对执行路径有没有共同的认知。
- 其五，有没有团队默契，是否日常沟通交流很多地方不必赘述，沟通上一点即透。

对于一个工程团队来说，没有精确的共识很可怕。它可能导致不同模块的工作牛头不对马嘴，完全无法连接起来，但是这个风险没有被暴露，直到最后一刻里程碑时间要到了，要出版本了，大家才匆匆忙忙联调，临时解决因为架构不到位产生的 “锅”。这时候人们的动作通常会走形。追求的不再是架构设计的好坏，而是打补丁，怎么把里程碑的目标实现了，别影响了团队绩效。如何阅读源码



怎么达成共识？

团队建立共同的使命、愿景与价值观，一致的远期目标。

团队仅有远期的目标是不够的，还要有中短期的目标。企业的使命和愿景需要由一个个的战略行动来落地。

**让更多人参与到决策形成的过程现场，是更好的共识达成的方式。通过同步足够充分的信息，通过共创而非传达决策的方式让结论自然产生**。这个共创过程不必团队所有人都参与，但要确保所有影响落地的关键角色都在，并确保参与这个过程的人都能够产生思想的碰撞，而非做个吃西瓜群众。



形成契约。

**目标与执行路径达成了共识，这还不够。我们还需要把共识表达出来，形成文字。**

因为共识之所以为共识，是因为它不是空中楼阁，不是口号，而是指导我们做战略选择的依据，指导我们平常行为的依据。所以，共识就是团队协作的契约。契约的表达越是精确而无歧义，团队协作中主观能动性就越高，执行的效率也就越高。

积累白皮书，公司团队的技术博客，有利于建立团队的影响力，有利于帮助新员工快速熟悉业务，融入开发。

契约的形成是一个随着公司发展不断完善的过程，所以形成纸质的文档，才能有迹可循，不断的更正完善。

### 外包方式的选择

怎么选择跨组织的协同方式？

我们尽可能不要做太多事情。非核心竞争力相关的，能够外包的我们尽可能外包。在外包选择上，我们优先选择云服务，次选开源，最后才考虑传统的外包。

什么是核心竞争？

一些程序员对此理解可能会比较 “技术化”，认为业务系统的核心模块就是核心竞争力。与它相关的东西就是核心竞争力相关。但更合理的视角不是技术视角，而是业务视角。**我们每一家企业都是因为服务客户而存在。所以，与服务客户的业务流越相关，越不能外包，而是要自己迭代优化，建立服务质量与效率的竞争优势**。



另外，外包的选择需要非常谨慎。很多开发人员都有随意引用开源项目的习惯，这一定程度上给项目带来了不确定的风险。我一直认为，开源项目的引入需要严格把关。严谨来说，开源项目引入大部分情况下是属于我说的 “基础架构” 选择的范畴，这同样是架构师团队需要承担的重要职责，一定要有正规的评估流程。

### 开源

从分工角度，开源的核心思想是让全社会的程序员共同来完成一个业务系统。开源的优势非常明显。对于一个热门的开源项目，它的迭代进度是非常惊人的，因为它撬动的资源太大了。

开源对信息科技的影响极其巨大，它极大地加速了信息科技前进的进程，是全球共同精诚协作的典范。没有参与过开源的程序员是需要心有遗憾的。开源沉淀下来的协同方法与工作流，今天被无数公司所借鉴。没有开源，我们无法想象这件事情：那么多形形色色的企业，今天其中绝大部分，它们的软件工程协同方法与业务流竟然如此相似。这是开源带来的另一种无形资产。



开源可以推动信息世界的进步，这一点毋庸置疑。一个好的开源项目，带动的力量是巨大的，带来的进步是巨大的。但是有一点我们也需要认识到，虽然成功的开源项目风风火火，但是我们也应该意识到，对于那些并没有得到关注的开源项目，它们的迭代速度完全无法保障。最终，你可能还是只能靠自己的团队来完成它的演进。

从这个意义上看，开源是一种商业选择。你得持续经营它。没有经营的开源项目不会成功。你需要宣传它，你自己也得持续迭代它，你还要为它拉客户。有客户的开源项目自然就有了生命力。

另外，开源这种形态，注定了它只能做大众市场。如果一个业务系统它的受众很少，就比较难通过开源获得足够的外部支持。所以绝大部分成功的开源项目，都属于基础设施性质的业务系统，有极其广泛适用的场景。例如，语言、操作系统、基础库、编程框架、浏览器、应用网关、各类中间件等等。我们这个架构课重点介绍的内容，大部分都有相应的开源实现。



