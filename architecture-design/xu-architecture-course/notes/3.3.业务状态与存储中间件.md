# 业务状态与存储中间件

## 存储中间件

原文链接：[36 | 业务状态与存储中间件 (geekbang.org)](https://time.geekbang.org/column/article/127490)

### 业务状态

桌面程序和服务端程序都可以看作一个有限状态机，客户端程序通过用户交互事件改变状态，服务端通过网络 API 请求改变状态。不同的是，状态的表现形式不同，桌面程序的状态是大多数是内存中的数据结构，不需要持久化；而服务端程序的状态往往在存储中间件中，需要具有可恢复的能力。

### 存储中间件与容灾级别

服务端程序的业务状态并不简单。这是一个多租户的持久化状态。就算一个用户的业务状态数据只有 100K，有个 100 万用户，那么需要持久化的数据也有 100G。这显然不能用“常规桌面程序每次完全重新生成一个新文件”的持久化思路做到，它需要被设计为一种增量式的存储系统。

对服务端开发来说，数据库的出现是革命性的，它大大提升了开发效率。但在容灾级别这个事情上，随着互联网的普及，我们对它的要求越来越高。

首先，单机数据库是不够的，需要多机相互热备，这就是数据库主从结构的来由。这样我们就不需要担心数据库单机故障会导致服务临时不可访问，甚至出现更严重的数据丢失。

其次，单机存储量终归有上限，这样我们服务的用户数就有上限。在**分布式数据库**出现之前，人们的解决方案是手工的分库分表。总之，业务上我们需要做到规模可伸缩，不必担心单机物理存储容量的限制。

最后，单机房的可靠性也是不够的，机房可能会出现网络中断，极端情况下还可能因为自然灾害，比如地震，导致整个机房的数据丢失。于是就出现了“两地三中心”，跨机房容灾的数据灾备方案。

### 存储即数据结构

数据库能够解决所有服务端程序的业务状态持久化需求吗？

不能，对比桌面程序我们能够知道，业务状态其实就是数据结构。虽然数据库这个数据结构的确通用性很强，但是它不是银弹，在很多场合下它并不适用。

**存储即数据结构**。

存储中间件是什么？**存储中间件就是 “元数据结构”**。

这里说的 “元数据结构”，表达的含义是，数据结构的种类是非常有限的，并且最好理论可被证明，有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。这些基本的数据结构，就是我说的 “元数据结构”。

今天我们接触的存储中间件有哪些？不完整的列表如下：

- 键值存储（KV-Storage）；
- 对象存储（Object Storage）；
- 数据库（Database）；
- 消息队列（MQ）；
- 倒排索引（SearchEngine）；
- 等等。

## 键值存储与数据库

### 数据库的种类

关系型数据库，以 MySQL、Oracle、SQLSever 为代表。

这类数据库把数据每个条目（row）的数据分成多个项目（column），如果某个项目比较复杂，从数据结构角度来说是一个结构体，那么就搞一个新的表（table）来存储它，在主表只存储一个 ID 来引用。

这类数据库的特点是强 schema，每个项目（column）有明确的数据类型。从业务状态的角度看，可以把一个表（table）理解为一个结构体，当遇到结构体里面套结构体，那么就定义一个子表。



文档型数据库，以 MongoDB 为代表。

这类数据库把数据每个条目（row）称为文档（document），每个文档用 JSON 或其他文档描述格式表示。当前文档型数据库大部分是无 schema 的，也就是在插入文档时并不对文档的数据格式的有效性进行检查。



键值数据库，以 Cassandra 为代表。

键值存储从使用的角度来说，可以认为是数据库的特例。数据库往往是允许设定多个索引字段的，而键值存储明确只有唯一索引。

### 事务

无论是何种数据库，都面临一个重大选择：是否支持事务。这是一个艰难选择。从需求角度来说，事务功能非常强大，没道理不去支持。从实现角度来说，事务支持带来极大的负担，尤其是在分布式数据库的场景。

### 主从结构

主从结构采用的是一主多从模式，所有写操作都发往主（Master），所有从（Slave）都从主这边同步数据修改的操作。

这样，从（Slave）的数据版本只可能因为同步还没有完成，导致版本会比较旧，而不会出现比主（Master）还新的情况。

从（Slave）可以帮主（Master）分担一定的读压力，但是不是所有的读操作都可以被分担。大部分场景的读操作必须要读到最新的数据，否则就可能会出现逻辑错乱。只有那些纯粹用于界面呈现用途，而不是用于逻辑计算的场景，非敏感场景（比如财务场景是敏感场景）下能够接受读的旧版本数据，可以从从节点读。



从（Slave）最重要的是和主（Master）形成了互备关系。在主挂掉的时候，某个从节点可以替代成为新的主节点。这会发生一次选举行为，系统中超过一半的节点需要同意某个节点成为主，那么选举就会通过。考虑选举的话，意味着集群的节点数为奇数比较好。

### 分布式

CAP 理论

## 文件系统与对象存储

原文链接：[38 | 文件系统与对象存储 (geekbang.org)](https://time.geekbang.org/column/article/131310)

### 异常处理是存储的业务逻辑

存储中间件用来保存服务的状态，状态保证了服务宕机重启后能够恢复到原本的状态继续正常工作。这样，自然就有了对状态可靠性的要求，但实现这种可靠性并不容易。

为了保证可靠性，存储系统你需要花费绝大部分精力在各种异常情况的处理上，甚至你应该认为，这些庞杂的、多样的错误分支处理，才是存储系统的 “正常业务逻辑”。

### 文件系统

尽管数据库很通用，它决不会是唯一的存储中间件。比如，在服务端开发中，我们业务用到的多媒体（图片、音视频、Office 文档等），我们很少会去存储到数据库中，更多的时候我们会把它们放在文件系统里。

但是单机时代诞生的文件系统，不是最适合存储这些多媒体数据的。

- 第一，伸缩性问题。单机文件系统的第一个问题是单机容量有限，在存储规模超过一台机器可管理的时候，应该怎么办的问题。
- 第二，性能瓶颈。单机文件系统通常在文件数目达到临界点后，性能快速下降。在 10TB 的大容量磁盘越来越普及的今天，这个临界点相当容易到达。
- 第三，可靠性，更严谨来说是持久性（Durability）问题。单机文件系统通常只是单副本的方案。但是，今天单副本的存储早已经无法满足业务的持久性要求。

### 对象存储

非结构化数据的存储方式，最理想的绝对不是分布式文件系统。

文件系统只是桌面操作系统为了方便用户手工管理数据而设计的产物。服务端操作系统发展的初期，人们简单沿用了桌面操作系统的整套体系框架。

非结构化数据最佳的存储方式，还是键值存储（KV Storage）。用于存储非结构化数据的键值存储，有一个特殊的名字，叫对象存储（Object Storage）。它和结构化数据的键值存储，实现机制上往往有极大的差异。

对象存储的 Key，看起来也像一个文件系统的路径（Path），但仅仅是像而已。对于对象存储来说，Key 中出现的 “/” 字符，只是一个普通字符。在对象存储中，并不存在目录（Directory）这样的概念。

既然对象存储是一个键值存储，就意味着我们可以通过对 Key 做 Hash，或者对 Key 按 Key Range 做分区，都能够让请求快速定位到特定某一台存储机器上，从而转化为单机问题。

### 存储成本与持久性

存储成本最大的关联因素是以下两个方面：

- 存储密度。存储密度越高，单台机器的存储量越大，单位成本越低。存储密度取决于：单台机器能够插的硬盘数量、单块磁盘的容量。
- 冗余度。GFS 采用的是 3 副本，也就是冗余度为 3。当前降低冗余度，通常采用的是**纠删码（EC）**这样的算术冗余方案。

## 存储与缓存

原文链接：[39 | 存储与缓存 (geekbang.org)](https://time.geekbang.org/column/article/132656)

