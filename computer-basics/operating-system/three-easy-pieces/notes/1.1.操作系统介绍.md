# 操作系统介绍

不管是什么程序，其在运行过程中只会做一件事情——执行指令。过程如下：

- 处理器从内存中获取（fetch）一条指令；
- 对其进行解码（decode）（弄清楚这是哪条指令）；
- 执行（execute）指令（做指令应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）；
- 处理器继续执行下一条指令，依此类推，直到程序最终完成。

事实上，一个程序在运行的同时，还有许多其他事情在同步进行——主要是为了让系统易于使用，保障程序能够正确高效的运行。有一类软件实现了这一目的，这类软件就是**操作系统**（Operating System, OS）。

从不同的角度去看，操作系统扮演了不同的角色：

- 虚拟机（virtual machine）：操作系统使用了一种虚拟化的技术，将物理资源抽象为更通用、更强大且更易于使用的方式；
- 标准库（standard library）：操作系统提供了系统调用来让应用程序来运行程序、访问硬件，并进行其他相关操作；
- 资源管理器（resource manager）：每个 CPU、内存和磁盘都是系统的资源，操作系统管理这些资源，让应用程序使用。

## 虚拟化

对于虚拟化，我们需要明白操作系统如何将资源虚拟化？

操作系统将物理资源抽象为更通用、更强大且更易于使用的方式，这种抽象就是虚拟化。物理资源包括 CPU、内存和其他的输入输出设备。

### 虚拟化 CPU

将单个 CPU 抽象为看似无限数量的 CPU，从而多个程序看似同时运行，这就是所谓的虚拟化 CPU。

### 虚拟化内存

对于一个正在运行的程序来讲，看似其好像独占了整个内存，但实际上物理内存是由操作系统管理的共享资源，这便是虚拟化内存。其让每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。

## 并发

学习目标：**对于并发，需要明白操作系统是如何构建正确的并发程序**。

代码中的单个操作在实际程序运行时会对应多个指令，且不是以原子的方式执行的，这样多个程序同时对于共享变量进行操作就可能会出现问题。如：

```c
int counter = 0;
counter++;
```

上述的 `counter++` 操作的目的是让 `counter` 的值累加 1，程序运行时需要三条指令：

- 将计数器的值从内存加载到寄存器；
- 将其递增；
- 将其保存回内存。

因为这 3 条指令并不是以原子方式（atomically）执行（所有的指令一次性执行）的，所以意向不到的事情可能会发生，这就是并发问题。

## 持久化

学习目标：**对于持久化，需要明白操作系统如何持久的存储数据**。

文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？



在系统内存中，如果断电或系统崩溃，那么内存中的所有数据都会丢失。因此，我们需要硬件和软件来持久地（persistently）存储数据。这样的持久化存储对于所有系统都很重要，因为用户非常关心他们的数据。

硬件以某种**输入/输出设备**（Input/Output，I/O）的形式出现。

操作系统中管理磁盘的软件通常称为**文件系统**（file system），负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。

## 机制和策略

后面操作系统的学习中，会经常涉及到这两个概念。

Unix/Linux 的接口设计有一句通用的格言——**提供机制而不是策略**。机制和策略分离，也是 Unix 系统设计的一大亮点。

大部分的编程问题都可以被切割成两个部分：需要提供什么功能（机制）和怎样实现这些功能（策略）。如果程序可以由独立的部分分别完成机制与策略的实现，那么开发软件就更加容易，也更加容易适应不同的需求。

机制往往是稳定的，而策略在不同的场景下会被其他的策略替代。所以将机制和策略分离设计，可以让系统更加稳定，扩展性更强。

## 总结

现在你已经明白操作系统做了什么：

- **虚拟化**：管理 CPU、内存或磁盘等物理资源，并对它们进行虚拟化；
- **并发**：提供某些机制，处理与并发有关的麻烦且棘手的问题；
- **持久化**：以文件的形式持久的存储数据，使得它们长期安全。

鉴于我们希望建立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现：

- **建立抽象**

  这是最基本的一个目标，建立一些抽象，让系统更易于使用。

  > 抽象对我们在计算机科学中做的每件事都很有帮助。抽象使得编写一个大型程序成为可能，将其划分为小而且容易理解的部分，比如用 C 这样的高级语言编写这样的程序不用考虑汇编，用汇编写代码不用考虑逻辑门，用逻辑门来构建处理器不用太多考虑晶体管。抽象是如此重要，有时我们会忘记它的重要性。

- **提高性能**

  我们的目标是最小化操作系统的开销（minimize the overhead），虚拟化和让系统易于使用是非常值得的，但不会不计成本；这些开销会以多种形式出现：额外时间（更多指令）和额外空间（内存或磁盘上）。如果有可能，我们会寻求解决方案，尽量减少一种或两种开销。

- **保护机制**

  在应用程序之间以及在 OS 和应用程序之间提供保护机制，因为我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序，尤其是不要影响操作系统。保护的核心就是**隔离**（isolation），让进程彼此隔离是保护的关键。

本文是《[操作系统导论](https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180)》（英文名：《Operating Systems: three easy pieces》）第 2 章学习笔记。