# 分布式系统

分布式系统改变了世界的面貌。当你的 Web 浏览器连接到地球上其他地方的 Web 服务器时，它就会参与似乎是简单形式的客户端/服务器分布式系统。

构建分布式系统时会出现许多新的挑战，我们关注的主要是**故障**（failure）。机器、磁盘、网络和软件都会不时故障，我们不知道故障发生的时间，而且这些故障往往是不可避免的？

那么关键问题就是如何构建在组件故障时仍能工作的系统？

有趣的是，虽然故障是构建分布式系统的核心挑战，但它也代表着一个机遇。是的，机器会故障，但是机器故障这一事实并不意味着整个系统必须失败。通过聚集一组机器，我们可以构建一个看起来很少失败的系统，尽管它的组件经常出现故障。这种现实是分布式系统的核心优点和价值。

分布式系统又很多需要考虑的地方，比如系统性能、系统安全等，这里我们仅仅介绍分布式系统中最基本的新方面：**通信**，即分布式系统中的机器应该如何相互通信？

## 通信基础

现代网络的核心原则是，通信基本上是不可靠的。

在网络上传输的数据包会因为各种原因损坏或丢失。那么怎么处理网络包的丢失？

### 不可靠的通信层

第一个解决方法就是我们不去处理这种丢失，由于某些应用程序知道如何处理数据包丢失，因此让它们用基本的不可靠消息传递层进行通信有时很有用，这是端到端的论点的一个例子。

UDP 是不可靠通信层的一个很好的例子。如果你使用它，就会遇到数据包丢失（丢弃），从而无法到达目的地的情况。但是，这并不意味着 UDP 根本不能防止任何故障。例如，UDP 包含校验和（checksum），以检测某些形式的数据包损坏。

### 可靠的通信层

为了构建可靠的通信层，我们需要一些新的机制和技术来处理数据包丢失。

我们第一个要做的就是，接收方在收到消息后要进行**确认**（ack）。当发送方收到该消息的确认时，它可以认为接收方确实收到了原始消息。但是，如果没有收到确认，发送方应该怎么办？

为了处理这种情况，我们需要一种额外的机制，称为**超时**（timeout）。

当发送方发送消息时，发送方现在将计时器设置为在一段时间后关闭。如果在此时间内未收到确认，则发送方断定该消息已丢失。发送方然后就重试（retry）发送，再次发送相同的消息，希望这次它能送达。要让这种方法起作用，发送方必须保留一份消息副本，以防它需要再次发送。超时和重试的组合导致一些人称这种方法为**超时/重试**（timeout/retry）。

遗憾的是，这种形式的超时/重试还不够。试想下，如果是只是确认包丢失，发送方在没有收到确认包一段时间后会超时重试，这样接收方会接收的重复的包，那么解决包重复这种问题？

为了解决包重复，可以使用**顺序计数器**来解决。利用顺序计数器，发送方和接收方就每一方将维护的计数器的起始值达成一致。

发送方将当前计数器的值（假设为 N）最为消息的 ID 和消息一起发送，然后增加计数器的值为 N+1，最为下个消息的 ID；

接收方在收到消息后，如果接收的消息的 ID 和计数器的值是一致的，它将确认该消息，将其传递给上层的应用程序，然后增加计数器的值为 N+1。

如果确认丢失，则发送方将超时，并重新发送消息 N。这次，接收器的计数器更高（N+1），因此接收器知道它已经接收到该消息。因此它会确认该消息，但不会将其传递给应用程序。以这种简单的方式，顺序计数器可以避免重复。

最常用的可靠通信层称为 TCP/IP，或简称为 TCP。TCP 比上面描述的要复杂得多，包括处理网络拥塞的机制，多个未完成的请求，以及数百个其他的小调整和优化。

## 通信抽象

有了基本的消息传递层，现在遇到了本章的下一个问题：构建分布式系统时，应该使用什么抽象通信？

人们的一个尝试是抽象操作系统，将其扩展到在分布式环境中运行。

比如，分布式共享内存（Distributed Shared Memory，DSM）系统使不同机器上的进程能够共享一个大的虚拟地址空间。这种抽象将分布式计算变成貌似多线程应用程序。唯一的区别是这些线程在不同的机器上运行，而不是在同一台机器上的不同处理器上。

由于许多原因，这种方法今天并未广泛使用。DSM 最大的问题是它如何处理故障。另一个问题是性能。

### 远程过程调用（RPC）

虽然最终结果表明，操作系统抽象对于构建分布式系统来说是一个糟糕的选择。

但基于编程语言（PL）的通信抽象要有意义得多，最主要的抽象是基于远程过程调用（Remote Procedure Call），简称 RPC。

远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接。

因此，我们在使用 RPC 进行通信时，对于客户端来说，进行一个过程调用，并在一段时间后返回结果。服务器只是定义了一些它希望对外暴露的方法。其余的由RPC 系统处理，RPC 系统通常有两部分：**存根生成器**（stub generator，有时称为协议编译器，protocol compiler）和**运行时库**（run-time library）。

#### 存根生成器

存根生成器的工作很简单：通过自动化，消除将函数参数和结果打包成消息的一些痛苦。这有许多好处：通过设计避免了手工编写此类代码时出现的简单错误。此外，存根生成器也许可以优化此类代码，从而提高性能。

这里我们需要一个中间文件，来描述我们想要实现的远程调用，文件的内容可能很简单，比如：

```
interface {
	int func1(int arg1);
	int func2(int arg1, int arg2);
}
```

然后存根生成器根据上述文件生成服务端存根和客户端存根。

客户端存根和服务端存根首先在代码层面提供了和本地函数调用一样的方法，方法调用的网络传输过程都被封装在了代码底层。

对于客户端存根来讲，封装的操作包括：

- 创建消息缓冲区；

- 将所需信息打包到消息缓冲区中，该信息包括要调用的函数的某种标识符，以及函数所需的所有参数；

  将所有这些信息放入单个连续缓冲区的过程，有时被称为**参数的封送处理**（marshaling）或**消息的序列化（**serialization）；

- 将消息发送到目标 RPC 服务器，与 RPC 服务器的通信，以及使其正常运行所需的所有细节，都由 RPC 运行时库处理，这个下面会说；

- 等待回复；

- 解包返回代码和其他参数，将从服务端返回的消息进行解包，此步骤也称为解封送处理（unmarshaling）或反序列化（deserialization）；

- 返回调用者，最后，只需从客户端存根返回到客户端代码。

对于服务端存根来讲，封装的操作包括：

- 解包消息。此步骤称为解封送处理（unmarshaling）或反序列化（deserialization），将信息从传入消息中取出，提取函数标识符和参数；
- 调用实际函数，终于，我们到了实际执行远程函数的地方，RPC 运行时调用 ID 指定的函数，并传入所需的参数；
-  打包结果，返回参数被封送处理，放入一个回复缓冲区；
- 发送回复，回复最终被发送给调用者。

存根编译器还有一些重要的问题需要考虑，第一个是复杂的参数，即一个包如何发送复杂的数据结构？

另一个重要问题是关于并发性的服务器组织方式，即服务端处理消息的网络模型该如何设计。

#### 运行时库

运行时库处理 RPC 系统中的大部分繁重工作。这里处理大多数性能和可靠性问题。接下来讨论构建此类运行时层的一些主要挑战。

我们必须克服的首要挑战之一，是如何找到远程服务。这个命名（naming）问题在分布式系统中很常见。

下一个问题是应该构建 RPC 的传输级协议，具体来说，RPC 系统应该使用可靠的协议（如 TCP/IP），还是建立在不可靠的通信层（如 UDP/IP）上？实际上，许多 RPC 软件包都建立在不可靠的通信层之上，这样做可以实现更高效的 RPC 层，那可靠性则需要 RPC 系统自己来实现。

最后一个问题是：是否向客户端暴露通信的异步性质，从而实现一些性能优化。具体来说，典型的 RPC 是同步（synchronously）的，即当客户端发出过程调用时，它必须等待过程调用返回，然后再继续。

因为这种等待可能很长，而且因为客户端可能正在执行其他工作，所以某些 RPC 包让你能够异步（asynchronously）地调用 RPC。



## 总结

正如人们在 Google 内部所说的那样，当你只有自己的台式机时，故障很少见。当你拥有数千台机器的数据中心时，故障一直在发生。**所有分布式系统的关键是如何处理故障**。

我们还看到，通信是所有分布式系统的核心。在远程过程调用（RPC）中可以看到这种通信的常见抽象，它使客户端能够在服务器上进行远程调用。RPC 系统处理所有细节，包括超时/重试和确认，以便提供一种服务，很像本地过程调用。







