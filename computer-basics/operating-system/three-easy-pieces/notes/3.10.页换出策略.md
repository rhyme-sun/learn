# 页换出策略

物理内存空间时有限的，在某些情况下由于内存压力迫使操作系统换出（paging out）一些页，为常用的页腾出空间。确定要换出哪个页（或哪些页）封装在操作系统的替换策略中。历史上，这是早期的虚拟内存系统要做的最重要的决定之一，因为旧系统的物理内存非常小。至少，有一些策略是非常值得了解的。

## 缓存管理

在深入研究策略之前，先详细描述一下我们要解决的问题。由于内存只包含系统中所有页的子集，因此可以将内存中的页视为系统中虚拟内存页的缓存。因此，在为这个缓存选择替换策略时，我们的目标是让缓存未命中（cache miss）最少，即使得从磁盘获取页的次数最少。

知道了缓存命中率和缓存未命中率，我们就可以使用下面公式计算出内存访问效率（AMAT, Average Memory Access Time）：

```
AMAT=(Phit*Tm) + (Pmiss*Td)
```

其中 `Phit` 表示缓存命中的概率，`Tm` 表示访问内存用的时间，`Pmiss` 表示缓存未命中的概率，`Pd` 表示访问磁盘的时间，且 `Phit+Pmiss=1`。

## 最优替换策略

为了理解一个替换策略时如何工作的，将它于最好的替换策略进行比较是很好的方法。

实时上最优的替换策略的原理为：替换内存中在最远将来才会被访问到的页，可以达到缓存未命中率最低。

比如我现在有 0，1，2，3 这 4 个页，物理内存同时最多能存放三个页，如果访问页的序列为 0、1、2、0、1、3、0、3、1、2、1，下面表格将展示在最优替换策略下，页被换出的情况：

| 访问 | 命中/未命中 | 换出页        | 缓存状态 |
| ---- | ----------- | ------------- | -------- |
| 0    | 未命中      | -             | 0        |
| 1    | 未命中      | -             | 0、1     |
| 2    | 未命中      | -             | 0、1、2  |
| 0    | 命中        | -             | 0、1、2  |
| 1    | 命中        | -             | 0、1、2  |
| 3    | 未命中      | 2             | 0、1、3  |
| 0    | 命中        | -             | 0、1、3  |
| 3    | 命中        | -             | 0、1、3  |
| 1    | 命中        | -             | 0、1、3  |
| 2    | 未命中      | 3（0 页可以） | 0、1、2  |
| 1    | 命中        | -             | 0、1、2  |

我们可以计算缓存命中率：有6次命中和5次未命中，那么缓存命中率为 54.5%。也可以计算命中率中除去强制未命中（即忽略页的第一次未命中），那么命中率为81.8%。

遗憾的是，最优替换策略难以实现，因为我们不知道后面页被访问的情况，无法为通用操作系统实现最优策略。因此，在开发一个真正的、可实现的策略时，我们将聚焦于寻找其他决定把哪个页面踢出的方法。因此，最优策略只能作为比较，知道我们的策略有多接近“完美”。

## FIFO

FIFO 即先入先出，其原理为：页在进入系统时，会被简单放入到一个队列中，当发生页的替换时，将队列尾部的页交换出去。

FIFO 有一个最大的有点就是实现简单。

同样地，我们来看 FIFO 在上述内存页访问序列下，表现如何：

| 访问 | 命中/未命中 | 换出页 | 缓存状态 |
| ---- | ----------- | ------ | -------- |
| 0    | 未命中      | -      | 0        |
| 1    | 未命中      | -      | 0、1     |
| 2    | 未命中      | -      | 0、1、2  |
| 0    | 命中        | -      | 0、1、2  |
| 1    | 命中        | -      | 0、1、2  |
| 3    | 未命中      | 0      | 1、2、3  |
| 0    | 未命中      | 1      | 2、3、0  |
| 3    | 命中        | -      | 2、3、0  |
| 1    | 未命中      | 2      | 3、0、1  |
| 2    | 未命中      | 3      | 0、1、2  |
| 1    | 命中        | -      | 0、1、2  |

FIFO 的命中率未 36.4%、强制命中率为 57.1%。

先进先出替换策略无法确定页的重要性，即使页 0 会被多次访问（尤其在一个循环程序中），FIFO 仍然会将其提出，因为它是第一个进入内存的。

## 随机

另一个类似的替换策略是随机，在内存满的时候它随机选择一个页进行替换。随机具有类似于 FIFO 的属性。实现起来很简单，但是它在挑选替换哪个页时不够智能。下面随机策略在上述内存访问序列下的表现：

| 访问 | 命中/未命中 | 换出页 | 缓存状态 |
| ---- | ----------- | ------ | -------- |
| 0    | 未命中      | -      | 0        |
| 1    | 未命中      | -      | 0、1     |
| 2    | 未命中      | -      | 0、1、2  |
| 0    | 命中        | -      | 0、1、2  |
| 1    | 命中        | -      | 0、1、2  |
| 3    | 未命中      | 0      | 1、2、3  |
| 0    | 未命中      | 1      | 2、3、0  |
| 3    | 命中        | -      | 2、3、0  |
| 1    | 未命中      | 3      | 2、0、1  |
| 2    | 未命中      | -      | 2、0、1  |
| 1    | 命中        | -      | 2、0、1  |

## LRU

遗憾的是，任何像 FIFO 或随机这样简单的策略都可能会有一个共同的问题：它可能会踢出一个重要的页，而这个页马上要被引用。因此需要更智能的策略。

正如在调度策略所做的那样，为了提高后续的命中率，我们再次通过历史的访问情况作为参考。例如，如果某个程序在过去访问过某个页，则很有可能在不久的将来会再次访问该页。

页替换策略可以使用的一个历史信息是频率。如果一个页被访问了很多次，也许它不应该被替换，因为它显然更有价值。页更常用的属性是访问的近期性，越近被访问过的页，也许再次访问的可能性也就越大。这一系列的策略是基于人们所说的局部性原则。

因此，一系列简单的基于历史的算法诞生了。“最不经常使用”（Least-Frequently-Used，LFU）策略会替换最不经常使用的页。同样，“最少最近使用”（Least-Recently-Used，LRU）策略替换最近最少使用的页面。这些算法很容易记住：一旦知道这个名字，就能确切知道它是什么，这种名字就非常好。

为了更好的理解 LRU，下面将展示 LRU 替换策略在上述访问序列下的表现：

| 访问 | 命中/未命中 | 换出页 | 缓存状态 |
| ---- | ----------- | ------ | -------- |
| 0    | 未命中      | -      | 0        |
| 1    | 未命中      | -      | 0、1     |
| 2    | 未命中      | -      | 0、1、2  |
| 0    | 命中        | -      | 1、2、0  |
| 1    | 命中        | -      | 2、0、1  |
| 3    | 未命中      | 2      | 0、1、3  |
| 0    | 命中        | -      | 1、3、0  |
| 3    | 命中        | -      | 1、0、3  |
| 1    | 命中        | -      | 0、3、1  |
| 2    | 未命中      | 0      | 3、1、2  |
| 1    | 命中        | -      | 3、2、1  |

在这个例子中 LRU 替换策略的命中率赶上了最优替换策略的命中率。

存在一种极端情况（按照某个序列循环访问），会使得 LRU 算法的命中率变得很差。比如有 0、1、2、3 这 4 个页，内存中至多放三个页，页的访问序列为 0、1、2、3、0、1、2、3、.... 

这时候 LRU 的表现如下：

| 访问 | 命中/未命中 | 换出页 | 缓存状态 |
| ---- | ----------- | ------ | -------- |
| 0    | 未命中      | -      | 0        |
| 1    | 未命中      | -      | 0、1     |
| 2    | 未命中      | -      | 0、1、2  |
| 3    | 未命中      | 0      | 1、2、3  |
| 0    | 未命中      | 1      | 2、3、0  |
| 1    | 未命中      | 2      | 3、0、1  |
| 2    | 未命中      | 3      | 0、1、2  |
| 3    | 未命中      | 0      | 1、2、3  |
| 0    | 未命中      | 1      | 2、3、0  |
| 1    | 未命中      | 2      | 3、0、1  |
| 2    | 未命中      | 3      | 0、1、2  |

可以看出，在这种访问序列下，LRU 命中率为 0%。

## 近似 LRU

LRU 这个算法优于 FIFO 和随机替换策略，它不会剔除一些需要经常访问的页。遗憾的是，基于历史信息的策略带来了一个新的挑战：应该如何实现呢？我们应该如何记录或访问这些历史信息呢？

以 LRU 为例，为了实现它，我们需要做很多工作。具体来说，我们用一个列表的数据结构来存放缓存中的页，每次访问页时，修改数据结构，将访问的页放置列表的最右侧，这样一来，列表的最左侧就是下次未命中被替换的页。

为了记录哪些页是最少和最近被使用，系统必须对每次内存引用做一些记录工作。

有一种方法有助于加快速度，就是增加一点硬件支持。例如，硬件可以在每个页访问时更新内存中的时间字段（时间字段可以在每个进程的页表中，或者在内存的某个单独的数组中，每个物理页有一个）。因此，当页被访问时，时间字段将被硬件设置为当前时间。然后，在需要替换页时，操作系统可以简单地扫描系统中所有页的时间字段以找到最近最少使用的页。

遗憾的是，随着系统中页数量的增长，扫描所有页的时间字段只是为了找到最精确最少使用的页，这个代价太昂贵。

由于实现完美的 LRU 代价非常昂贵，我们能否实现一个近似的 LRU 算法，并且依然能够获得预期的效果？

事实上是有的。

近似 LRU 算法需要硬件增加一个使用位（use bit，有时称为引用位，reference bit）。系统的每个页有一个使用位，然后这些使用位存储在某个地方（例如，它们可能在每个进程的页表中，或者只在某个数组中）。每当页被引用（即读或写）时，硬件将使用位设置为 1。利用这个使用位，操作系统就可以实现类似于 LRU 的算法。

其中一种方法为**时钟算法**，想象一下，系统中的所有页都放在一个循环列表中。时钟指针（clock hand）开始时指向某个特定的页（哪个页不重要）。当必须进行页替换时，操作系统检查当前指向的页P的使用位是 1 还是 0。如果是 1，则意味着页面 P 最近被使用，因此不适合被替换。然后，P 的使用位设置为 0，时钟指针递增到下一页（P + 1）。该算法一直持续到找到一个使用位为 0 的页然后替换，使用位为 0 意味着这个页最近没有被使用过（在最坏的情况下，所有的页都已经被使用了，那么就将所有页的使用位都设置为 0）。

## 抖动

抖动是指系统在频繁的进行换页。

一些早期的操作系统有一组相当复杂的机制，以便在抖动发生时检测并应对。例如，给定一组进程，系统可以决定不运行部分进程，希望减少的进程工作集（它们活跃使用的页面）能放入内存，从而能够取得进展。这种方法通常被称为准入控制（admission control），它表明，少做工作有时比尝试一下子做好所有事情更好，这是我们在现实生活中以及在现代计算机系统中经常遇到的情况（令人遗憾）。

## 总结

我们已经看到了许多页替换（和其他）策略的介绍，这些策略是所有现代操作系统中虚拟内存子系统的一部分。

现代系统增加了对时钟等简单 LRU 近似值的一些调整。例如，扫描抗性（scan resistance）是许多现代算法的重要组成部分，如 ARC。扫描抗性算法通常是类似LRU 的，但也试图避免 LRU 的最坏情况行为（按照某个固定的序列循环访问）。因此，页替换算法的发展仍在继续。然而，在许多情况下，由于内存访问和磁盘访问时间之间的差异增加，这些算法的重要性降低了。由于分页到硬盘非常昂贵，因此频繁分页的成本太高。所以，过度分页的最佳解决方案往往很简单：购买更多的内存。

本文是《[操作系统导论](https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180)》（英文名：《Operating Systems: three easy pieces》）第 22 章学习笔记。