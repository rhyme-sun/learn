# 受限制直接执行

操作系统需要以某种方式让许多任务共享物理 CPU，让它们看起来像是同时运行，即虚拟化 CPU。虚拟化 CPU 的基本思路很简单，运行一个进程一段时间，然后运行另一个进程，如此轮换，这种方式叫做**时分共享**（time sharing）CPU。

然而构建这样的虚拟化机制存在一些些挑战。第一个是如何在不增加系统开销的情况下实现虚拟化？第二个是如何在有效的运行进程时，同时保留对 CPU 的控制？

接下来我们就看操作系统是**如何高效、可控地虚拟化 CPU**。

## 控制权转移

操作系统在高效运行进程的同时需要保证对 CPU 的控制权。控制权对操作系统尤为重要，如果没有控制权，一个进程可以简单地无限制运行并接管机器。首先这是不安全的，系统容易受到恶意程序的破坏。其次如果对运行程序没有限制，操作系统将无法控制任何事情，因此会成为“仅仅是一个访问硬件资源的库”，这是操作系统不愿意看到的。

**所以一个进程在访问一些核心的硬件资源是要受到限制的，不能让进程完全控制系统，操作系统和硬件如何协作实现这一点？**

硬件通过提供了两种执行模式来协助操作系统：

- 用户模式（user mode）：在用户模式下，运行的代码会受到限制，应用程序不能完全访问硬件资源；
- 内核模式（kernel mode）：在内核模式下运行的代码可以执行受限的指令，访问机器的全部资源。

这样只要让用户程序在用户模式下运行，运行的代码如果试图执行受限操作，就会引起异常，操作系统可能会终止程序，这样硬件资源就得到了保护。



**但是用户程序的确需要执行受限的操作，这时候该怎么做呢？**

为了实现这一点，几乎所有的现代硬件都提供了用户程序执行**系统调用**的能力。

程序在执行系统调用时，通过 `trap` 指令陷入内核，并切换到内核模式。这样程序就可以访问受限的硬件资源，执行受限的代码。完成后，就从内核返回，切换回用户模式。

需要注意的是，在用户模式切换到内核模式时，硬件需要小心，因为它必须确保用户模式进程上下文被记录了下来，以便在返回用户模式时程序能接着执行。

这里还有一个细节，切换到内核模式时，程序怎么找到执行受限代码的位置？

这个是通过 `trap table` 来实现的，它在系统启动的时候提前初始化好，里面维护了系统调用号和对应代码的执行位置。这样在内核模式下，根据这个系统调用号就可以找到受限代码的执行位置。

## 调度方式

一个进程在 CPU 上运行，意味着操作系统没有在使用 CPU，我们知道进程的切换是要通过操作系统的，所以在切换进程时，操作系统需要重新获取到 CPU 的控制权。

**那么问题来了，操作系统是如何在用户进程执行时重新获取 CPU 的控制权的？**

这里有协作和非协作两种方式，来帮助操作系统重新获取到 CPU 的控制权，然后执行进程切换操作。

### 协作方式（主动调度）

在协作方式下，操作系统持乐观态度，相信进程在运行一段时间后会自己主动让出 CPU 的控制权，比如进程在发起某些 I/O 操作时，会先让出 CPU 去处理其他事情。

**那么一个友好的进程如何放弃 CPU？**

大多数进程通过进行系统调用（比如显式调用 `yield`），将 CPU 的控制权转移给操作系统。

此外如果应用程序执行了某些非法操作（比如，如果应用程序以 0 为除数，尝试访问应该无法访问的内存），也会将控制转移给操作系统。

所以在协作模式下，OS 通过等待系统调用，或某种非法操作发生，从而重新获得 CPU 的控制权。

### 非协作方式（抢占式调度）

在协作模式下，如果一个进程不发起系统调用，并且也不会有非法的操作，那么是不是意味着操作系统将永远获取不到 CPU 的控制权。比如程序进入了死循环，操作系统又获取不到 CPU 的执行权限去切换或停止这个进程，其他进程就永远得不到执行，这时候解决问题的唯一办法就是重启计算机了。

**所以，CPU 还需要不在协作模式下获得 CPU 的控制权，如何做到？**

答案就是**时钟中断**。

时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事，比如停止当前进程，并启动另一个进程。

时钟中断这个硬件功能对保证操作系统维持机器控制权至关重要。

## 上下文切换

既然操作系统已经重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。这个决定是由调度程序（scheduler）做出的，它是操作系统的一部分。

**上下文切换**概念很简单：操作系统要做的就是保存当前进程的上下文（寄存器里的值），并为即将运行的进程恢复一些寄存器的值。这样就保证了切换后，能继续从切换进程上次执行的位置继续执行，被切换的进程的上下文也被安全的记录下来，供下次切换回来时恢复使用。	

下面将说明一个正在运行进程 A（**用户模式下**）被中断时钟中断切换到进程 B 的过程：

- 进程 A 在用户模式下运行，然后被中断时钟中断；
- 硬件保存进程 A 的寄存器到 A 的内核栈中，并进入内核模式；
- 在时钟中断处理程序中，操作系统决定从正在运行的进程 A 切换到进程 B；
- 开始调用 switch，在 switch 里会进行以下操作：
  - 保存当前寄存器的值（保存到进程 A 的结构里）；
  - 恢复寄存器（从进程 B 的结构里）；
  - 切换上下文（switch context），具体来说是切换栈顶指针到进程 B 的内核栈；
- 操作系统从内核返回，恢复 B 的寄存器（从 B 的内核栈恢复），转向用户模式，开始运行它。

> 注意：上述上下文切换过程中涉及到两种类型的寄存器保存/恢复。
>
> 第一种是发生时钟中断的时候。在这种情况下，**运行进程的用户寄存器由硬件隐式保存到进程的内核栈中**，这一过程和系统调用时寄存器保存/恢复类似。
>
> 第二种是当操作系统决定从 A 切换到 B。在这种情况下，**内核寄存器被软件（即 OS）明确地保存，但这次被存储在该进程的内存结构中**。



为了更好地了解如何实现这种切换，下面给出 `xv6` 操作系统上下文切换代码：

```c
# Context switch
#
#   void swtch(struct context **old, struct context *new);
# 
# Save the current registers on the stack, creating
# a struct context, and save its address in *old.
# Switch stacks to new and pop previously-saved registers.

.globl swtch
swtch:
  movl 4(%esp), %eax
  movl 8(%esp), %edx

  # Save old callee-saved registers
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi

  # Switch stacks
  movl %esp, (%eax)
  movl %edx, %esp

  # Load new callee-saved registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret
```

## 总结

实现 CPU 虚拟化时，我们遵循的一般准则被称为受限直接访问（Limited Direct Execution，LDE）。
LDE 背后的想法很简单：**直接执行**是指让程序运行的大部分指令直接访问硬件，**受限**则指在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确的时间，正确的地点，做正确的事”。

为了实现高效的虚拟化，操作系统应该尽量让程序自己运行，同时通过在关键点的及时介入，来保持对硬件的控制，以此来实现高效和控制这两个现代操作系统的主要目标。

受限制直接访问这一原则在现实生活中也被采用，比如你会提前收拾好房间里的危险物品（受限制），然后才放心让宝宝单独在房间里单独行动（直接执行）。

本文是《[操作系统导论](https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180)》（英文名：《Operating Systems: three easy pieces》）第 6 章学习笔记。