# 内存操作 API

这里将介绍 UNIX 操作系统提供的内存分配接口。

在 UNIX/C 程序中，理解如何分配和管理内存是构建健壮和可靠软件的重要基础。通常使用哪些接口？哪些错误需要避免？

## 内存类型

在运行一个 C 程序时，会动态分配两种类型的内存。

第一种是栈内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动内存。

C 中申请栈内存很容易，你只需要编写一个函数就行：

```c
void func() {
    int x;
    // ....
}
```

编译器完成剩下的事情，确保在你进入 `func` 函数的时候，在栈上开辟空间。当你从该函数退出时，编译器释放内存。

因此，如果你希望某些信息存在于函数调用之外，建议不要将它们放在栈上。



第二种是堆内存，它的申请和释放都有程序员显示的去完成。

下面的例子展示了如何在堆上分配一个整数，得到指向它的指针：

```c
void func() {
    int *x = (int *) malloc(sizeof(int));
    // ...
}
```

如上述代码所示：

- 首先编译器看到指针的声明（`int * x`）时，知道为一个整型指针分配空间；

- 接着，程序调用 `malloc` 函数，它会在堆上请求整数的空间，返回这样一个整数的地址（成功时，失败时则返回 NULL）；

- 然后将其存储在栈中以供程序使用。

## `malloc` 

`malloc` 函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败就返回 NULL，其规格如下：

```c
#include <stdlib.h>

void *malloc(size_t size);
```

`malloc` 只需要一个 `size_t` 类型参数，该参数表示你需要申请多少个字节的内存。然而大多数的时候我们并不会直接传入一个具体的数值，而是用函数和宏来实现。比如为了给双精度浮点数分配空间，只要这样：

```c
double *d = (double *) malloc(sizeof(double));
```

通过 `sizeof` **操作符**可以获取某种类型的长度，关于 `sizeof` 操作符有下面几点需要注意：

- `sizeof` 是一个被认为是一个操作符，而不是一个函数调用，因为 `sizeof` 在编译时就得到结果了，而函数调用时在运行时发生；

- 也可以传入一个变量名，来获取这个变量占用的空间，但需要注意下面这种写法：

  ```c
  int *x = (int *) malloc(10*sizeof(int));
  printf("%d\n", sizeof(x));
  ```

  上述代码会申请 10 倍 int 长度的空间，并用指针变量 x 指向它。当我试图获取指针变量 x 占用空间的大小时，它返回的是单个 int 长度，而不是 10 倍长度。原因是这时候 `sizeof` 认为我们只是问一个整数的指针有多大，而不是我们动态分配了多少内存。

  如果我们希望 `sizeof` 返回我们期望的结果，可以这么做：

  ```c
  int x[10];
  printf("%d\n", sizeof(x));
  ```

- 在为字符串声明空间时，请使用以下习惯用法 `malloc(strlen(s) + 1)`，它使用函数 `strlen` 获取字符串的长度，并加上 1，以便为字符串结束符留出空间。
- `malloc` 返回的是一个 void 类型的指针，这样做只是 C 中传回地址的方式，使用时可强转成需要的类型。

## free

要释放不再使用的堆内存，程序员只需调用 `free`：

```c
int *x = (int *) malloc(sizeof(int));
...
free(x);
```

该函数接受一个参数，即一个由 `malloc` 返回的指针，去释放指针指向的内存空间。

## 常见错误

内存的分配和释放并不是一件容易保证正确的事情，尤其是释放。对于 C 语言来说，代码通过编译是必要的，但远远不够，因为很多问题只有在运行时才能体现出来。正确的内存管理的代码就存在这样的问题，很多时候关于内存分配和释放的错误，在编译的时候是不知道的。

对于这种错误，往往只能要求程序员编写代码时需要小心谨慎，但人难免会犯错，对吧。

所以许多新语言都支持自动内存管理（automatic memory management）。在这样的语言中，当你调用类似 `malloc` 的机制来分配内存时（通常用 new 或类似的东西来分配一个新对象），你永远不需要调用某些东西来释放空间，空间的释放由垃圾收集器（garbage collector）完成。=

在使用 `malloc` 和 `free` 时会出现一些常见的错误。

### 忘记分配内存

很多函数在使用前，都需要你为它们分配内存。比如 `strcpy(dst, src)` 源字符串中的字符串复制到目标指针。但是，如果不小心，你可能会这样做：

```c
char *src = "hello";
char *dst;          // oops! unallocated
strcpy(dst, src);   // segfault and die
```

在这个例子中，正确的代码可能像这样：

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); 
```

### 没有分配足够的内存

另一个相关的错误是没有分配足够的内存，有时称为缓冲区溢出（buffer overflow）。在上面的例子中，一个常见的错误是为目标缓冲区留出几乎足够的空间。

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); 
```

在某些情况下，当字符串拷贝执行时，它会在超过分配空间的末尾处写入一个字节，但在某些情况下，这是无害的，虽然可能会覆盖不再使用的变量。但如果覆盖了正在使用的变量，就有可能导致程序崩溃停止，而且问题是难以定位的。

所以对于溢出问题，我们必须小心再小心，应为它出现问题具有偶然性，这类问题是不容易定位的。

我们也因此学到了另一个宝贵的教训：即使一个程序正确运行过一次，也不意味着它是正确的。

### 忘记初始化分配的内存

在这个错误中，你正确地调用 `malloc`，但忘记在新分配的数据类型中填写一些值。

不要这样做！如果你忘记了，你的程序最终会遇到未初始化的读取，它从堆中读取了一些未知值的数据。谁知道那里可能会有什么？

### 忘记释放内存

另一个常见错误称为内存泄露（memory leak），如果忘记释放不需要再使用的内存，就会发生。

在长时间运行的应用程序或系统中，这是一个巨大的问题，因为缓慢泄露的内存会导致内存不足，此时需要重新启动。因此，一般来说，当你用完一段内存时，应该确保释放它。

> 注意，有垃圾收集器的编程语言同样存在内存泄漏问题：如果你仍然拥有对某块内存的引用，那么垃圾收集器就不会释放它。

在某些情况下，不手动调用 `free` 似乎不会出现内存泄漏问题。

例如，你的程序运行时间很短，很快就会退出。在这种情况下，当进程死亡时，操作系统将清理其分配的所有页面，因此不会发生内存泄露。

但这是一个坏习惯，所以还是要显示的去释放申请的内存，即使你知道不这样做也可以逃脱惩罚。

> 为什么在你的进程退出时没有内存泄露？
>
> 当你编写一个短时间运行的程序时，可能会使用 `malloc` 分配一些空间。程序运行并即将完成：是否需要在退出前调用 `free` ？
>
> 虽然不释放似乎不对，但在真正的意义上，没有任何内存会泄漏。原因很简单：系统中实际存在两级内存管理。
>
> - 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出时负责将其回收；
> - 第二级管理在每个进程运行时调用 `malloc` 在堆内申请的内存，即使你没有调用 `free`，操作系统也会在程序结束运行时，收回进程的所有内存（包括堆）。
>
> 无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。

### 重复释放内存

程序有时还会不止一次地释放内存，这被称为重复释放。这样做的结果是未定义的。正如你所能想象的那样，内存分配库可能会感到困惑，并且会做各种奇怪的事情，崩溃是常见的结果。

### 错误地调用 free

`free` 期望你只传入之前从 `malloc` 得到的一个指针。如果传入一些其他的值，坏事就可能发生。因此，这种无效的释放是危险的，当然也应该避免。

## 系统调用

在讨论 `malloc` 和 `free` 时，我们没有讨论系统调用。原因很简单：它们不是系统调用，而是库调用。

`malloc` 是建立在一些系统调用之上的，这些系统调用会进入操作系统，来请求更多内存或者将一些内容释放回系统。

其中一个系统调用叫做 `brk`，它被用来改变程序分断（break）的位置——堆结束的位置。它需要一个参数（新分断的地址），从而根据新分断是大于还是小于当前分断，来增加或减小堆的大小。另一个调用 `sbrk` 要求传入一个增量，但目的是类似的。

还有一个系统调用是 `mmap`，它用来申请一块大内存，通过传入正确的参数，`mmap` 可以在程序中创建一个匿名（anonymous）内存区域——这个区域不与任何特定文件相关联，而是与交换空间（swap space）相关联。

## 总结

本文是《[操作系统导论](https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180)》（英文名：《Operating Systems: three easy pieces》）第 14 章学习笔记。



