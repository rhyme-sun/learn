# 文件和目录

到目前为止，我们看到了两项关键操作系统技术的发展：进程，它是虚拟化的 CPU；地址空间，它是虚拟化的内存。在这两种抽象共同作用下，程序运行时就好像它在自己的私有独立世界中一样，好像它有自己的处理器（或多处理器），好像它有自己的内存。这种假象使得对系统编程变得更容易，因此现在不仅在台式机和服务器上盛行，而且在所有可编程平台上越来越普遍，包括手机等在内。

这里，我们加上虚拟化拼图中更关键的一块：持久存储（persistent storage）。持久存储是指永久地（或至少长时间地）存储信息，使用传统硬盘驱动器或更现代的固态存储设备。持久存储设备与内存不同，内存在断电时，其内容会丢失，而持久存储设备会保持这些数据不变。

## 文件和目录

随着时间的推移，存储虚拟化形成了两个关键的抽象。

第一个是文件（file）。文件就是一个线性字节数组，每个字节都可以读取或写入。每个文件都有某种低级名称，通常是某种数字，这个数字一般用户是不知道的，通常称为 **inode 号**。

第二个抽象是目录（directory）。

一个目录和一个文件一样，也有一个低级名字（即 **inode 号**）。但目录的 inode 号不在是一个单纯的数字，而是由若干个条目组成，每个条目由用户可读的名称和低级名字对组成。假设存在一个低级别名称为 10 的文件，它的用户可读的名称为 foo。foo 文件所在的目录因此会有条目（foo，10），用来将用户可读名称映射到低级名称。

目录里的条目可以指向其他文件和目录，通过将目录放入其他目录中，用户可以构建任意的目录树（或者叫做目录层次结构）。

目录层次结构从根目录开始（在基于 UNIX 的系统中，根目录就记为“/”），并使用某种分隔符来命名后续子目录，这样从根目录到某个具体的文件或目录，就形成了文件或目录的路径，来表示文件或目录的位置。

## 文件系统接口

现在让我们更详细地讨论文件系统接口。我们将从创建、访问和删除文件的基础开始。

### 创建文件

创建文件可以通过 open 这个系统调用完成。

通过调用 `open` 并传入 `O_CREAT` 标志，程序可以创建一个新文件，比如：

```c
int fd = open("foo", O_CREAT|O_WRONLY|O_TRUNC,
S_IRUSR|S_IWUSR);
```

上述系统调用创建了一个 foo 文件，并且返回一个**文件描述符**。文件描述符只是一个整s数，是每个进程私有的，在 UNIX 系统中用于访问文件。

### 读写文件

> 使用 `strace`
>
> `strace` 工具提供了一种非常棒的方式，来查看程序在做什么。通过运行它，你可以跟踪程序生成的系统调用，查看参数和返回代码，通常可以很好地了解正在发生的事情。

比如我们可以使用 `strace` 来查看 `cat` 命令（读取一个文件的内容）在做什么：

```
prompt> strace cat foo
...
open("foo", O_RDONLY|O_LARGEFILE) = 3
read(3, "hello\n", 4096) = 6
write(1, "hello\n", 6) = 6
hello
read(3, "", 4096) = 0
close(3) = 0
...
prompt>
```

从上面系统调用可以看出：

- `cat` 做的第一件事是使用 `open` 打开文件准备读取，然后返回打开文件的描述符；

- 打开成功后，`cat` 使用 `read` 系统调用重复读取文件中的一些字节，返回读取的字节数；
  - 第一个参数表示要读取文件的描述符；
  - 第二个参数表示读取文件数据的缓冲区，这里 `strace` 将缓冲区里的内存显示了出来；
  - 第三个参数表示缓冲区的大小，这里为 4KB。

- 然后使用 `write`，将读取到的内容写入到标准输出流中，即上述的 1，返回成功写入的字节数；
  - 第一个参数表示要写入的文件描述符号；
  - 第二个参数表示写入数据缓冲区，这里 `strace` 将缓冲区里的内存显示了出来；
  - 第三个参数表示写入数据的字节长度。

- 然后 "hello" 被输出到了终端上；
- 接着 `cat` 试图从文件中读取更多的内容，但由于文件中没有剩余字节，`read` 返回 0，程序知道这意味着它已经读取了整个文件；
- 最后调用 `close`，关闭对应的文件描述符。

### 文件重命名

有了一个文件后，有时需要给一个文件一个不同的名字。在命令行键入时，这是通过 `mv` 命令完成的。在下面的例子中，文件 foo 被重命名为 bar。

```bash
mv foo bar
```

利用 `strace`，我们可以看到mv使用了系统调用 `rename(char * old, char * new)`。

`rename` 提供了原子性的保证，如果系统在重命名期间崩溃，文件将被命名为旧名称或新名称，不会出现奇怪的中间状态。

### 获取文件信息

除了文件访问之外，我们还希望文件系统能够保存关于它正在存储的每个文件的大量信息。我们通常将这些数据称为文件元数据（metadata）。

我们可以通过 `stat` 来查看文件的元数据，比如：

```
stat foo

  File: foo
  Size: 1               Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 34247168    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2022-04-06 16:07:03.338504742 +0800
Modify: 2022-04-06 16:07:03.338504742 +0800
Change: 2022-04-06 16:07:03.338504742 +0800
 Birth: -

```

事实表明，每个文件系统通常将文件的原数据保存在一个名为 `inode` 的结构中。

### 删除文件

删除文件可以使用 `rm` 命令，我们用 `strace` 跟踪了 `rm` 的系统调用，如

```
strace rm foo

...
unlink("foo")     = 0
...
```

可以发现删除文件使用的系统调用为 `unlink`。

### 创建目录

要创建目录，可以用系统调用 `mkdir`。同名的 `mkdir` 程序可以用来创建这样一个目录。让我们看一下，当我们运行 `mkdir` 程序来创建一个名为 foo 的简单目录时，会发生什么：

```
strace mkdir foo

...
mkdir("foo", 0777)   = 0
...
```

### 硬链接

我们现在回到为什么删除文件是通过 `unlink` 的问题。

首先我们要理解在文件系统树中创建条目的新方法，即通过 `link` 系统调用。

`link` 系统调用有两个参数：一个旧路径名和一个新路径名。当你将一个新的文件名“链接”到一个旧的文件名时，你实际上创建了一种引用同一个文件的方法。命令行程序 `ln` 用于执行此操作，如下面的例子所示：

```bash
echo hello > file
ln file file2
cat file
hello
cat file2
hello
```

在这里，我们创建了一个文件，其中包含单词 hello，文件名为 file。然后，我们用 `ln` 程序创建了该文件的一个硬链接。在此之后，我们可以通过打开 file 或 file2 来查看文件的内容。

`link` 只是在要创建链接的目录中创建了另一个名称，并将其指向原有文件的相同 `inode` 号。通过下面命令我们可以看出这一点：

```bash
ls -i file file2
34247168 file  34247168 file2
```

创建一个文件时，实际上做了两件事。首先，要构建一个结构（inode），它将跟踪几乎所有关于文件的信息，包括其大小、文件块在磁盘上的位置等等。其次，将人类可读的名称链接到该文件，并将该链接放入目录中。因此，为了从文件系统中删除一个文件，我们调用 `unlink`，表示取消这个链接。

比如这时候，我们指向下面命令删除 file 文件：

```bash
rm file
cat file2
hello
```

可以看出，在删除了文件 file 后，我们依然可以使用 file2 作为文件的名字访问文件，这样的结果是因为当文件系统取消链接文件时，它检查 `inode` 号中的引用计数（reference count）。该引用计数记录了有多个少个不同的文件名链接到了这个文件。调用 `unlink` 时，会删除可读的名称与给定 `inode` 号之间的链接，并减少引用计数。只有当引用计数达到零时，文件系统才会释放 `inode` 和相关数据块，从而真正删除该文件。

### 符号链接

还有一种非常有用的链接类型，称为符号链接（symbolic link），有时称为软链接（soft link）。

事实表明，硬链接有点局限：你不能创建目录的硬链接（因为担心会在目录树中创建一个环）。你不能硬链接到其他磁盘分区中的文件（因为 inode 号在特定文件系统中是唯一的，而不能跨文件系统），等等。因此，人们创建了一种称为符号链接的新型链接。

要创建这样的链接，可以使用相同的程序 `ln`，但使用 -`s` 标志，如：

```bash
echo hello > file
ln -s file file2
cat file
hello
cat file2
hello
```

但是，除了表面相似之外，符号链接实际上与硬链接完全不同。

但是，除了表面相似之外，符号链接实际上与硬链接完全不同。第一个区别是符号链接本身实际上是一个不同类型的文件。我们已经讨论过常规文件和目录。符号链接是文件系统知道的第三种类型。

若此时我们删除 file，file2 也将变得不可使用，如：

```bash
rm -f file
cat file2
cat: file2: No such file or directory
```

## 创建并挂载文件系统

我们应该如何从许多底层文件系统组建完整的目录。这项任务的实现是先制作文件系统，然后挂载它们，使其内容可以访问。

为了创建一个文件系统，大多数文件系统提供了一个工具，通常名为 `mkfs`（make fs）。思路如下：作为输入，为该工具提供一个设备（例如磁盘分区，例如 `/dev/sda1`），一种文件系统类型（例如 ext3），它就在该磁盘分区上写入一个空文件系统，从根目录开始。

创建好了文件系统后，接下来我们需要在统一的文件系统树中访问，这个任务是通过 `mount` 程序实现的。`mount` 的作用很简单：以现有目录作为目标挂载点（mount point），本质上是将新的文件系统粘贴到目录树的这个点上。

比如，我们有一个未挂载的 `ext3` 文件系统，存储在设备分区 `/dev/sda1` 中，它的内容包括：一个根目录，其中包含两个子目录 a 和 b，每个子目录依次包含一个名为 foo 的文件。假设希望在挂载点 `/home/users` 上挂载此文件系统。我们会输入以下命令：

```bash
mount -t ext3 /dev/sda1 /home/users
```

如果成功，`mount` 就让这个新的文件系统可用了，我们可以在整个文件目录树中访问到挂载的文件系统。

```bash
ls /home/users
a b
```

要查看系统上挂载的内容，以及在哪些位置挂载，只要运行 `mount` 程序，如：

```bash
mount

/dev/sda1 on / type ext3 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
/dev/sda5 on /tmp type ext3 (rw)
/dev/sda7 on /var/vice/cache type ext3 (rw)
tmpfs on /dev/shm type tmpfs (rw)
AFS on /afs type afs (rw)
```

运行 `mount` 命令后，会展示出不同的文件系统，包括 `ext3`（标准的基于磁盘的文件系统）、`proc` 文件系统（用于访问当前进程信息的文件系统）、`tmpfs`（用于临时文件的文件系统）和 AFS（分布式文件系统），它们都“粘贴”在这台机器的文件系统树上。



## 总结

是《[操作系统导论](https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180)》（英文名：《Operating Systems: three easy pieces》）第 39 章学习笔记。









