# 基于事件并发

到目前为止我们熟知的并发都是基于多线程实现的，实际上有其他的方式来实现并发。

具体来说，一些基于图形用户界面（GUI）的应用，或某些类型的网络服务器，常常采用另一种并发方式。这种方式称为基于事件的并发（event-based concurrency），在一些现代系统中较为流行，比如 node.js，但它源自于 C/UNIX 系统，我们下面将讨论。



基于事件的并发主要针对两个方面的问题，一个是在多线程应用中，正确的处理并发很有难度，正如我们讨论的会存在各种各样的并发编程 Bug，忘记加锁、死锁的问题经发生；另一方面线程的调度最终都会由操作系统来完成，开发者无法控制。程序员只是创建了线程，然后就依赖操作系统能够合理地调度线程。要实现一个在各种不同负载下，都能够良好运行的通用调度程序，是极有难度的。因此，某些时候操作系统的调度并不是最优的。



那么不用线程，同时保证对并发的控制，避免多线程应用中出现的问题，我们应该如何构建一个并发服务器？

## 事件循环

我们使用的基本方法就是基于事件的并发（event-based concurrency）。该方法很简单：我们等待某事发生；当它发生时，检查事件类型，然后做少量的相应工作（可能是 I/O 请求，或者调度其他事件准备后续处理）。

在深入细节之前，我们先看一个典型的基于事件的服务器。这种应用都是基于一个简单的结构，称为事件循环（event loop）。事件循环的伪代码如下：

```c
while (1) {
    events = getEvents();
    for (e in events)
        processEvent(e);
}
```

它确实很简单。主循环等待某些事件发生，然后依次处理这些发生的事件。处理事件的代码叫作**事件处理程序**（event handler）。重要的是，处理程序在处理一个事件时，它是系统中发生的唯一活动。因此，调度就是决定接下来处理哪个事件。这种对调度的显式控制，是基于事件方法的一个重要优点。

但这也带来一个更大的问题：基于事件的服务器如何决定哪个事件发生，尤其是对于网络和磁盘 I/O？具体来说，事件服务器如何确定是否有它的消息已经到达？

## 重要的 API

道了基本的事件循环，我们接下来必须解决如何接收事件的问题。大多数系统提供了基本的 API，即通过 `select` 或 `poll` 系统调用。

这些接口对程序的支持很简单：检查是否有任何应该处理的传入 I/O。例如，假定网络应用程序（如 Web 服务器）希望检查是否有网络数据包已到达，以便为它们提供服务。这些系统调用就让你做到这一点。

下面以 `select` 为例，其规格（macOS X）如下所示：

```c
int select(int nfds,
           fd_set *restrict readfds,
           fd_set *restrict writefds,
           fd_set *restrict errorfds,
           struct timeval *restrict timeout);
```

`select` 会检查 I/O 描述符集合（`readfds`、`writefds`、`errorfds`），在每个集合中检查前 `nfds` 个描述符，返回时，`select` 用准备好的描述符组成的子集替换给定的描述符集合，并返回所有集合中就绪描述符的总数。

关于 `select` 有几点要注意。

首先，请注意，它可以让你检查描述符是否可以读取和写入。前者让服务器确定新数据包已到达并且需要处理，而后者则让服务知道何时可以回复（即出站队列未满）。

其次，请注意超时参数。这里的一个常见用法是将超时设置为 NULL，这会导致 `select` 无限期地阻塞，直到某个描述符准备就绪。但是，更健壮的服务器通常会指定某种超时。一种常见的技术是将超时设置为零，因此让调用 `select` 立即返回。

下面通过一个例子来说明 select 的使用：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int main(void) {
    // open and set up a bunch of sockets (not shown)
    // main loop
    while (1) {
        // initialize the fd_set to all zero
        fd_set readFDs;
        FD_ZERO(&readFDs);

        // now set the bits for the descriptors
        // this server is interested in
        // (for simplicity, all of them from min to max)
        int fd;
        for (fd = minFD; fd < maxFD; fd++)
            FD_SET(fd, &readFDs);

        // do the select
        int rc = select(maxFD+1, &readFDs, NULL, NULL, NULL);

        // check which actually have data using FD_ISSET()
        int fd;
        for (fd = minFD; fd < maxFD; fd++)
            if (FD_ISSET(fd, &readFDs))
                processFD(fd);
    }
}
```

这段代码实际上很容易理解。初始化完成后，服务器进入无限循环。在循环内部，它使用 `FD_ZERO` 宏首先清除文件描述符集合，然后使用 `FD_SET` 将所有从`minFD` 到 `maxFD` 的文件描述符包含到集合中。最后，服务器调用 `select` 来查看哪些连接有可用的数据。然后，通过在循环中使用 `FD_ISSET`，事件服务器可以查看哪些描述符已准备好数据并处理传入的数据。



为什么说基于事件实现并发更简单？

使用单个 CPU 和基于事件的应用程序，并发程序中发现的问题不再存在。具体来说，因为一次只处理一个事件，所以不需要获取或释放锁。基于事件的服务器不能被另一个线程中断，因为它确实是单线程的（只有一个一直在循环的主线程）。因此，线程化程序中常见的并发性错误并没有出现在基本的基于事件的方法中。

所以，在主线程里处理事件时注意不要有阻塞主线程运行的调用。因为一个事件处理调用的阻塞会导致其他事件调用处理跟着一起阻塞，因此是潜在的巨大资源浪费。



为了克服在基于事件的并发中不允许阻塞调用这一限制，许多现代操作系统已经引入了新的方法来向磁盘系统发出 I/O 请求，一般称为异步 I/O（asynchronous I/O）。

这些接口使应用程序能够发出 I/O 请求，并在 I/O 完成之前立即将控制权返回给调用者，并通过另外的接口让应用程序能够确定各种 I/O 是否已完成。



比如我们来看看 masOS X 提供的异步 API：

```c
struct aiocb {
    int aio_fildes; // File descriptor
    off_t aio_offset; // File offset
    volatile void *aio_buf; // Location of buffer
    size_t aio_nbytes; // Length of transfer
};

int aio_read(struct aiocb *aiocbp);

int aio_error(const struct aiocb *aiocbp);
```

关于 macOS X 的异步 API 主要是围绕着一个结构体和两个接口进行的（其他系统也类似）。

要向文件发出异步读取，应用程序应首先用相关信息填充此结构：要读取文件的文件描述符（`aio_fildes`），文件内的偏移量（`ai_offset`）以及长度的请求（`aio_nbytes`），最后是应该复制读取结果的目标内存位置（`aio_buf`）。

然后应用程序发起异步调用，即上述的 `aio_read` 来读取文件。该调用尝试发出 I/O。如果成功，它会立即返回并且应用程序可以继续其工作。

那么应用程序该怎么知道 I/O 操作是否完成呢？

所以这里还需要一个 API，即上述的 `aio_error`。该系统调用检查 `aiocbp` 引用的请求是否已完成。如果有，则函数返回成功（用零表示）。如果不是，则返回`EINPROGRESS`。因此，对于每个未完成的异步 I/O，应用程序可以通过周期性调用 `aio_error` 来轮询（poll）系统，以确定所述 I/O 是否尚未完成。



你可能注意到轮询地去检查一个 I/O 是否完成是十分痛苦的。因为轮询的周期很难以确定，过于频繁会导致 CPU 调度的压力，周期过短会导致响应不够及时，有时候我们也许会动态的去调整轮询周期，以达到效率和延迟上的平衡。

为了解决这个问题，一些系统提供了基于中断（interrupt）的方法。此方法使用 UNIX 信号（signal）在异步 I/O 完成时通知应用程序，从而消除了重复询问系统的需要。

> UNIX 信号
>
> 所有现代 UNIX 变体都有一个称为信号（signal）的巨大而迷人的基础设施。最简单的信号提供了一种与进程进行通信的方式。
>
> 最简单的信号提供了一种与进程进行通信的方式。具体来说，可以将信号传递给应用程序。这样做会让应用程序停止当前的任何工作，开始运行信号处理程序，完成后，该进程就恢复其先前的行为。



基于事件的方法的另一个问题是，这种代码通常比传统的基于线程的代码更复杂。原因如下：当事件处理程序发出异步 I/O 时，**它必须打包一些程序状态，放到某个数据结构中，以便下一个事件处理程序在 I/O 最终完成时使用**。这个额外的工作在基于线程的程序中是不需要的，因为程序需要的状态在线程栈中。



基于事件的方法还有其他一些困难，我们应该指出。例如，当系统从单个 CPU 转向多个 CPU 时，基于事件的方法的一些简单性就消失了。具体来说，为了利用多个 CPU，事件服务器必须并行运行多个事件处理程序。发生这种情况时，就会出现常见的同步问题（例如临界区），并且必须采用通常的解决方案（例如锁定）。因此，在现代多核系统上，无锁的简单事件处理已不再可能。

基于事件的方法的另一个问题是，它不能很好地与某些类型的系统活动集成，如分页（paging）。例如，如果事件处理程序发生页错误，它将被阻塞，并且因此服务器在页错误完成之前不会有进展。尽管服务器的结构可以避免显式阻塞，但由于页错误导致的这种隐式阻塞很难避免，因此在频繁发生时可能会导致较大的性能问题。

## 总结

我们已经介绍了不同风格的基于事件的并发。基于事件的服务器为应用程序本身提供了调度控制，但是这样做的代价是复杂性以及与现代系统其他方面（例如分页）的集成难度。

是《[操作系统导论](https://weread.qq.com/web/reader/db8329d071cc7f70db8a479kc81322c012c81e728d9d180)》（英文名：《Operating Systems: three easy pieces》）第 33 章学习笔记。