# 主动调度

所谓进程调度，其实就是进程 A 正在运行，在某时刻被切换到去执行进程 B 了，发生这种情况，主要有两种方式：

- 主动调度：进程在运行期间，发现有一条 sleep 指令或者在等待某个 I/O 事件，这时候主动让出 CPU 让其他进程执行；
- 抢占式调度：进程在运行期间，被强制停下去执行别的进程了。

## 主动调度例子

下面有两个主动调度的例子：

第一个例子是 `Btrfs`，在将数据写入块设备时，因为写入块设备需要一段时间，这段时间不用 CPU，就主动让给其他进程使用。代码如下：

```c
static void btrfs_wait_for_no_snapshoting_writes(struct btrfs_root *root)
{
......
  do {
    prepare_to_wait(&root->subv_writers->wait, &wait,
        TASK_UNINTERRUPTIBLE);
    writers = percpu_counter_sum(&root->subv_writers->counter);
    if (writers)
      schedule();
    finish_wait(&root->subv_writers->wait, &wait);
  } while (writers);
}
```

第二个例子是从 Tap 网络设备等待一个读取，Tap 网络设备是虚拟机使用的网络设备，当没有数据到来的时候，它也需要等待，所以也会选择把 CPU 让给其他进程。代码如下：

```c
static ssize_t tap_do_read(struct tap_queue *q,
         struct iov_iter *to,
         int noblock, struct sk_buff *skb)
{
......
  while (1) {
    if (!noblock)
      prepare_to_wait(sk_sleep(&q->sk), &wait,
          TASK_INTERRUPTIBLE);
......
    /* Nothing to read, let's sleep */
    schedule();
  }
......
}
```

## 主动调度过程

计算机主要处理计算、网络、存储三个方面。计算主要是 CPU 和内存的合作；网络和存储则多是和外部设备的合作；在操作外部设备的时候，往往需要让出 CPU，就像上面两段代码一样，选择调用 `schedule()` 函数。

`schedule()` 函数如下：

```c
asmlinkage __visible void __sched schedule(void)
{
  struct task_struct *tsk = current;


  sched_submit_work(tsk);
  do {
    preempt_disable();
    __schedule(false);
    sched_preempt_enable_no_resched();
  } while (need_resched());
}
```

这段代码的主要逻辑是在 `__schedule` 函数中实现的，代码如下：

```c
static void __sched notrace __schedule(bool preempt)
{
  struct task_struct *prev, *next;
  unsigned long *switch_count;
  struct rq_flags rf;
  struct rq *rq;
  int cpu;

  cpu = smp_processor_id();
  rq = cpu_rq(cpu);
  prev = rq->curr;
......
  next = pick_next_task(rq, prev, &rf);
  clear_tsk_need_resched(prev);
  clear_preempt_need_resched();
......
  if (likely(prev != next)) {
    rq->nr_switches++;
    rq->curr = next;
    ++*switch_count;
......
    rq = context_switch(rq, prev, next, &rf);
......
```

上述代码执行的逻辑如下：

- 首先，在当前 CPU 取出任务队列 `rq`；
- 将 `prev` 指向当前进程；

- 获取下一个要执行的任务；
- 获取到任务后判断后继任务和当前进程是否相等，如果不相等就开始进程上下文切换，继任者进程正式进入运行。

### 进程上下文切换

上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存，二是切换寄存器和 CPU 上下文。



