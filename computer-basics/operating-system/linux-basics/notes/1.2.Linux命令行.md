# Linux 命令行

本文介绍了和 Shell 相关的一些基本概念和一些常用的命令。

## Shell

我们可以通过一个命令行程序和 Linux 内核进行交互（接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户），这个命令行工具就是 Shell。Shell 单词的原意是外壳的意思，和 kernal（内核）相对应，比喻内核的外一层，是用户和内核交互的对话界面。

用户还可以使用变量、条件判断、循环操作等语法编写复杂的命令，将这些命令写入一个文件中，交给 Shell 解释执行，这个文件就是 Shell 脚本。

### Shell 的种类

Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell，历史上，主要的 Shell 有下面这些：

- Bourne Shell（sh）
- Bourne Again shell（bash）
- C Shell（csh）
- TENEX C Shell（tcsh）
- Korn shell（ksh）
- Z Shell（zsh）
- Friendly Interactive Shell（fish）

Bash 是目前最常用 Shell，一般也是系统默认的 Shell，可以使用下面命令查看系统正在使用的 Shell 程序：

```bash
echo $SHELL
```

也可以使用下面命令查看当前 Linux 安装的所有 Shell：

```bash
cat /etc/shells
```

## 模式扩展

Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token），然后 Shell 会扩展词源里面的特殊字符，这种特殊字符的扩展，称为模式扩展（globbing）。

### 波浪线扩展

波浪线 `~` 会自动扩展成当前用户的家目录，如：

```bash
# 显示当前用户家目录
echo ~
# 进入当前用户的家目录
cd ~
# 进入 foo 用户的家目录
cd ~foo
# `~+`  会扩展成当前所在的目录，等同于 `pwd` 命令
echo ~+
```

### 问号扩展

`?` 字符代表文件路径里面的任意单个字符，不包括空字符。比如，`data???`  匹配所有 data 后面仅跟着三个字符的文件名，如：

文件夹下有 `a.txt` 和 `aa.txt`，执行以下命令：

```bash
ls ?.txt  # 输出 a.txt

ls ??.txt # 输出 aa.txt
```

### 星号扩展

`*` 字符代表文件路径里面任意数量的任意字符，如：

```bash
# 显示所有 txt 文件
ls *.txt
```

### 方括号扩展

`[..]` 表示匹配在方括号里面的字符。如：

```bash
# 显示 a.txt 和 b.txt
ls [ab].txt
# 显示除了 a.txt 和 b.txt 以外的文件，且该文件名只有一个字符
ls [!ab].txt
# 显示不是以字母 a 或 b 开头文件
ls [!ab]*.txt
```

### 范围匹配扩展

方括号扩展有一个简写形式 `[start-end]`，表示匹配一个连续的范围。比如，`[a-c]` 等同于 `[abc]`，`[0-9]` 匹配 `[0123456789]`。如：

```bash
# 显示 a.txt、b.txt 和 c.txt
ls [a-c].txt
```

还有一些其他常用例子：

- `[a-z]`：所有小写字母；
- `[a-zA-Z]`：所有小写字母与大写字母；
- `[a-zA-Z0-9]`：所有小写字母、大写字母与数字；
- `[abc]*`：所有以 `a`、`b`、`c` 字符之一开头的文件名；
- `program.[co]`：文件 `program.c` 与文件 `program.o`；
- `BACKUP.[0-9][0-9][0-9]`：所有以 `BACKUP.` 开头，后面是三个数字的文件名。

### 大括号扩展

大括号扩展 `{...}` 表示分别扩展成大括号里面的所有值，大括号里的值用逗号分隔（逗号附近不能有空格）。比如，`{1,2,3}` 扩展成 1 2 3。如：

```bash
# 输出 1 2 3
echo {1,2,3}

# 显示 a.txt、b.txt 和 c.txt
ls {a,b,c}.txt
```

逗号前面可以没有值，表示扩展的第一项为空，如：

```bash
# 复制 a.txt 到 a.txt.bak
cp a.txt{,.bak}
```

大括号可以嵌套，如：

```bash
# 输出 aA1b aA2b aB3b aB4b
echo a{A{1,2},B{3,4}}b
```

### 范围输出扩展

大括号扩展有一个简写形式`{start..end}`，表示扩展成一个连续序列。如：

```bash
# 输出 26 个小写字母
echo {a..z}
# 逆序输出 26 个小写字母
echo {z..a}
```

大括号扩展的常见用途为新建一系列目录：

```bash
mkdir {2007..2009}-{01..12}
```

### 变量扩展

Bash 将美元符号 `$` 开头的词元视为变量，将其扩展成变量值，如：

```bash
# 输出当前系统使用的 SHELL 程序
echo $SHELL
```

变量名除了放在美元符号后面，也可以放在 `${}` 里面，如：

```bash
echo ${SHELL}
```

`${!string*}` 或 `${!string@}` 返回所有匹配给定字符串 `string` 的变量名，如：

```bash
# 输出所有以 S 开头的变量的值
echo ${!S*}
```

### 子命令扩展

`$(...)` 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值，如：

```bash
# 输出当前时间
echo ${date}
```

还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果，如：

```bash
# 输出当前时间
echo `date`
```

## 转义和引号

### 转义

某些字符在 Bash 里面有特殊含义（比如 `$`、`&`、`*`），如：

```bash
echo $date
```

上面例子中，输出 `$date` 不会有任何结果，因为 `$` 是一个特殊字符，如果需要输出 `$date` 字符串，需要对 `$` 进行转义，如：

```bash
echo \$date
```

如果想要原样输出这些特殊字符，就必须在它们前面加上**反斜杠**，使其变成普通字符，这就叫做转义（escape）。

反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（`\\`），如：

```bash
# 输出反斜杠
echo \\
```

反斜杠除了用于转义，还可以表示一些不可打印的字符：

- `\a`：响铃；
- `\b`：退格；
- `\n`：换行；
- `\r`：回车；
- `\t`：制表符；

如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用 `echo` 命令的 `-e` 参数，如：

```bash
# 输出 atb
echo a\tb

# 输出 a       b
echo "a\tb"
```

### 单引号

Bash 允许字符串放在单引号或双引号之中，加以引用。单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符。如：

```bash
# 输出 *
echo '*'
# 输出 \
echo '\'
```

### 双引号

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。如：

```bash
# 输出 *
echo "*"
```

> 但是，三个特殊字符除外：美元符号（`$`）、反引号和反斜杠（`\`）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。如：
>
> ```bash
> # 输出 SHELL 变量值
> echo "$SHELL"
> 
> # 输出当前时间
> echo "`date`"
> ```

如果一个文本中包含单引号，则需要将其包裹在双引号中输出：

```bash
# 不正确
echo it's

# 输出 it's
echo "it's"

# 转义双引号
echo "I'd say: \"hello!\""
```

双引号的另一个常见的使用场景是，文件名包含空格。这时就必须使用双引号（或单引号），将文件名放在里面，如：

```bash
# 显示带有空格的文件
ls "two words.txt"
```

### Here 文档

Here 文档（here document）是一种输入多行字符串的方法，格式如下。

```bash
<< token
text
token
```

`<< token` 表示开始标记，token 表示结束标记，token 可以定义成其他任意字符串，如：

```bash
# 输出 HTML 文档
$ cat << _EOF_
<html>
<head>
    <title>
    The title of your page
    </title>
</head>

<body>
    Your page content goes here.
</body>
</html>
_EOF_
```

### Here 字符串

Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（`<<<`）表示。它的作用是将字符串通过标准输入，传递给命令。如：

```bash
cat <<< 'hi there'
# 等同于
echo 'hi there' | cat
```

## 重定向和管道

**标准流**是当一个计算机程序执行时，在它和它的环境间（典型为终端），默认连接的输入和输出频道，标准流分别为：

| 文件描述符 |  名称  |              描述              |
| :--------: | :----: | :----------------------------: |
|     0      | stdin  |   标准输入，默认连接的是键盘   |
|     1      | stdout |   标准输出，默认连接的是终端   |
|     2      | stderr | 标准错误输出，默认连接的是终端 |

重定向可以改变标准流的默认连接，重定向操作符有：

- `>` ：输出重定向；
- `>>`：追加输出重定向；
- `<` ：输入重定向；
- `<<`：Here 文档，指定特定的分界符作为多行命令输入的结束标志，而不使用 `Ctrl+D` 键；
- `<<<`：Here 字符串，将字符串通过标准输入，传递给命令。

### 输入重定向

| 命令                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `command > file`           | 以覆盖的方式，将 command 程序的正确的输出重定向到 file 文件中 |
| `command >> file`          | 以追加的方式，将 command 程序的正确输出重定向到 file 文件中  |
| `command 2> file`          | 以覆盖的方式，将 command 程序的错误输出重定向到 file 文件中  |
| `command 2>> file`         | 以追加的方式，将 command 程序的错误输出重定向到 file 文件中  |
| `command > file 2>&1`      | 以覆盖的方式，将 command 程序的正确和错误输出重定向到 file 文件中 |
| `command >> file 2>&1`     | 以覆盖的方式，将 command 程序的正确和错误输出重定向到 file 文件中 |
| `command > file1 2> file2` | 以追加的方式，将 command 程序的正确输出重定向到 file1 文件中，将错误输出重定向到 file2 文件中 |

> 注：不能写成 `command > file 2> file` 这两种写法会导致 file 被打开两次，引起资源竞争，所以 stdout 和 stderr 会互相覆盖。

### 输出重定向

| 命令                      | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `command < file`          | 将 file 文件中的内容作为程序 command 的输入                  |
| `command < file1 > file2` | 将 file1 文件中的内容作为 command 的输入，并将 command 的处理结果输出到 file2 |
| `command <<token`         | Here 文档，从标准输入（键盘）中读取数据，直到遇见分界符 token 才停止（token 可以是任意的字符串） |
| `command <<< "string"`    | Here 字符串，将字符串通过标准输入，传递给命令                |

`command <<token` 举例：

`wc` 命令用来统计文本数目，`-c` 选项用来统计字节数，`-w` 选项用来统计单词数，`-l` 选项用来统计行数，如，我们可以统计用户在终端输入的文本的单词数：

```bash
wc -w <<END
> Hello Simon
> Hello Alice
> END
4
```

### 管道

管道是一系列将标准输入输出连接起来的进程，其中前一个进程的输出被直接作为下一个进程的输入，重定向和管道符可以联合使用，这样可以组合出更加复杂的命令，比如：

```bash
ls -l | less
```

命令 `ls -l` 将当前文件夹下的文件和目录以列表形式展示，`less` 命令用来分页展示结果，上述命令用管道连接起来就表示分页展示当前文件夹下的文件或目录。

## 常用命令

这里记录了一些常用的 Linux 命令。

### 手册

`man` 命令是 Linux 最核心的命令的之一，它是单词 manual 的缩写，即手册的意思，你可以使用 `man`  命令来查看一些命令的使用方法。

Linux 的 man 手册共有以下几个章节：

| 代号 | 描述                                            |
| ---- | ----------------------------------------------- |
| 1    | 标准命令                                        |
| 2    | 系统调用                                        |
| 3    | 库函数                                          |
| 4    | 设备说明                                        |
| 5    | 文件格式                                        |
| 6    | 游戏和娱乐                                      |
| 7    | 杂项                                            |
| 8    | 管理员命令                                      |
| 9    | 其他（Linux 特定）， 用来存放内核例行程序的文档 |

如 `man 1 ls`、`man 2 socket`。

> 注：最小化的 CentOS 安装后一些 man 手册不全，可使用 `yum install man-pages` 命令进行安装。

### 用户管理

- 创建用户

  ```bash
  # 创建用户 foo
  useradd foo
  ```

- 设置密码

  ```bash
  # 设置 foo 用户的密码
  passwd foo
  ```

- 删除用户

  ```bash
  # 删除用户，保留家目录
  userdel foo
  
  # 删除用户，删除家目录
  userdel -r foo
  ```

- 查看用户信息

  ```bash
  # 查看用户 foo 的信息
  id foo
  # 输出如：uid=1000(foo) gid=1000(foo) 组=1000(foo)
  ```

### 文件管理

- 切换目录

  ```bash
  cd /home           # 切换到 /home 目录
  cd /               # 切换到根目录
  cd ~               # 切换的当前用户的家目录
  cd ../             # 切换到上级目录
  cd ../../          # 切换到上上级目录
  cd foo             # 切换到当前目录下的 foo 子目录
  ```

- 查看目录下的文件

  ```bash
  # 以列表形式展示文件
  ls -l
  ```

  ```
  drwxr-xr-x 6 root root     4096 Oct 20  2017 apt
  -rw-r--r-- 1 root root     211 Oct 20  2017 hosts
  ```

  上述输出具体含义为：

  - 第一个字段的第一个字符是文件类型，如果是 `-`，表示普通文件，如果是 d，就表示目录（还有其它文件类型，这里不作展开）；

  - 第一个字段剩下的 9 个字符表示权限位（access permission bits）；

    > 权限位由 9  个字符组成，每三个一组，一共三组；
    >
    > 每一组 `rwx` 分别表示读（read）、写（write）、执行（execute），如果对应位置是字母，就说明有这个权限，如果是横线，就是没有这个权限；
    >
    > 三组分别表示文件所属的**用户权限**、**组权限**以及**其他用户的权限**；
    >
    > 如：`-rw-r–r--` 就表示这是一个普通文件，对于所属用户可读可写不能执行，对于所属的组仅仅可读，对于其他用户也是仅仅可读。
    >
    > 文件的权限可以使用 `chmod 775 file` 命令进行修改，数字 `775` 就代表要修改的权限，数字和权限的对应规则如下：
    >
    > - 每个数字代表一个组的权限；
    > - 将数用二进制的形式表示，如上数的 5 就为 `101`，从左往右分别表示可读（1）、不可写（0）、可执行（1）。

  - 第二个字段是硬链接（hard link）数目，这里不作展开；
  - 第三个字段是所属用户；
  - 第四个字段是所属组；
  - 第五个字段是文件的大小；
  - 第六个字段是文件被修改的日期；
  - 最后一个字段是文件名。

- 改变文件所属用户

  ```bash
  # 将 file 的所属用户设置为 foo
  chown foo file 
  ```

  > 注：当设置的用户被删除后，文件的所属用户会被替换为用户的 ID。

- 改变文件所属组

  ```bash
  # 将 file 的所属组设置为 foo
  chgrp foo file
  ```

  > 注：当设置的组被删除后，文件的所属组会被替换为用户组的 ID。

- 创建文件夹

  ```bash
  # 创建 test 目录
  mkdir test     
  # 创建 test 目录和其下的子目录
  mkdir test/test1  
  ```

- 创建文件

  ```bash
  # 编辑文件 a.txt 若不存在，在文件被保存后则会创建
  vim a.txt
  # 修改 a.txt 的档案时间为当前时间，文件不存在则会创建
  touch a.txt      
  ```

- 编辑文件 Vim

  ```bash
  # 在当前目录下打开 hello.txt，没有则会创建一个文件
  vim hello.txt
  ```

  >Vim 有三个模式：
  >
  >- **一般模式**：使用 Vim 打开一个文档后就进入了一般模式，在一般模式下可以使用上下左右来移动光标，可以使用一些快捷键来管理文档内容，常用的快捷键有：
  >  - 拷贝当前行：`yy + p`；
  >  - 拷贝当前行下的 5 行：`5yy + p`；
  >  - 删除当前行：`dd`；
  >  - 删除当前行下的 5 行：`5dd`;
  >  - 撤销上次修改：`u`；
  >  - 将光标定位到文档尾行：G；
  >  - 将光标定位到文档首行：gg；
  >  - 将光标定位到第 5 行：`5 + Shift + g`。
  >- **编辑模式**：在一般模式下输入 `i` 就可以进入编辑模式，编辑模式下可以使用键盘上的按钮来对文档内容进行编辑，编辑模式下按下 `ESC` 可以退回到一般模式；
  >- **命令行模式**：在一般模式下按下 `Shift + :（英文冒号）` 就可以进入命令行模式，在命令行中可以输入命令来控制文档行为，常用的命令有：
  >  - `set nu`：开启文档行号显示；
  >  - `set nonu`：关闭文档行号显示；
  >  - `q`：退出编辑，如果此时文档内容有修改，则会退出失败；
  >  - `!q`：强制退出编辑，文档修改的内容不会保存；
  >  - `wq`：保存文档内容并退出编辑。

- 查看文件内容

  ```bash
  cat file
  ```

- 下载文件

  ```bash
  wget http://tel.mirrors.163.com/centos/6.4/isos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso
  curl -O http://tel.mirrors.163.com/centos/6.4/isos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso
  ```

- 搜索文件内容

  ```bash
  # 查看文件 a.txt 包含 a 的行
  grep a a.txt
  ```

- 部分显示

  ```bash
  # 分页查看文件条目，按 Enter 键查向下滚动一条，空格键向下滚动一页，按 q 键退出
  ls -l | more
  # 分页查看文件条目，按 Enter 键查向下滚动一条，空格键向下滚动一页，按 q 键退出
  ls -l | less
  ```

### 安装软件

- 手动安装

  ```bash
  # CentOS
  rpm -ivh xxx.rpm                                   # 安装包并显示详细进度
  rpm -qa | grep jdk                                 # 按名称查找已安装的包
  rpm -qa | more                                     # 列表查看已安装的包
  rpm -qf /usr/bin/who                               # 查找一个文件属于哪个 RPM 包
  rpm -qpi xxx.rpm                                   # 列出一个 RPM 包的描述信息
  rpm -q httpd                                       # 查看 httpd 的安装包
  rpm -d httpd                                       # 移除安装包
  rpm -qi httpd                                      # 查看 httpd 安装包的信息
  ```

  ```bash
  # Ubuntu
  # 安装
  dpkg -i xxx.deb
  # 按名称查找已安装的包
  dpkg -l | grep jdk
  # 列表查看已安装的包
  dpkg -l | more
  ```

- 在线安装（包管理工具安装）

  ```bash
  # CentOS
  # 安装 zip unzip
  yum install zip unzip
  # 移除 zip unzip
  yum remove zip unzip
  
  # Ubuntu
  apt-get install zip unzip
  ```

- 解压安装

  ```bash
  # 下载离线安装包，解压到指定目录下
  tar xvzf jdk-XXX_linux-x64_bin.tar.gz
  ```

  配置环境变量

  ```bash
  export JAVA_HOME=/root/jdk-XXX_linux-x64
  export PATH=$JAVA_HOME/bin:$PATH
  ```

  `export` 命令仅在当前命令行的会话中管用，一旦退出重新登录进来，就不管用了，可以在用户家目录的 `.bashrc` 文件中添加环境变量配置，每次登录的时候，这个文件都会运行，因而把它放在这里，这样登录进来就会自动执行，环境变量就会生效，也可以通过 `source .bashrc` 手动执行，使得环境变量配置立即生效。

### 运行程序

- 命令行运行

  ```bash
  ./filename
  ```

  在 Windwos 上我们可以双击运行一个 `.exe` 文件，Linux 不是根据后缀名来执行的。它的执行条件是这样的：只要文件有可执行（x）权限，都能到文件所在的目录下，通过 `./filename` 运行这个程序。当然，如果放在 PATH 里设置的路径下面，就不用 `./` 了，直接输入文件名就可以运行了，Linux 会帮你找。

  通过 shell 在交互命令行里面运行，是 Linux 执行应用程序最常用的一种方式。这样执行的程序可能需要和用户进行交互，例如允许让用户输入，然后输出结果也打印到交互命令行上。这种模式的缺点是，一旦当前的交互命令行退出，程序就停止运行了。

- 后台运行

  ```bash
  # 后台运行程序，将日志输出到 out.file 中
  nohup command > out.file 2>&1 &
  
  # 后台运行程序，不记录日志
  nohup command >/dev/null 2>&1 &
  
  # 找到并关闭后台进程
  ps -ef | grep java | awk '{print $2}' | xargs kill -9
  ```

  使用 `nohup` 可以将一个程序后台运行，这一在执行命令的会话关闭后，程序依然可以运行。

  使用 `nohup` 启动的程序，可以通过 `ps`  查找到运行程序进程的 PID，再使用 `kill` 命令关闭它。

- 服务方式运行

  Linux 上的服务也可以以服务的方式运行，如下所示：

  ```bash
  # 设置开机启动 docker
  systemctl enable docker
  # 启动 docker 服务
  systemctl start docker
  # 关闭 docker 服务
  systemctl stop docker
  ```

### 开机关机

- 关机

  ```bash
  shutdown -h now
  ```

- 重启

  ```bash
  reboot
  ```

## 总结

这里介绍可 Linux 命令行相关的一些基础知识，如 Shell、模式扩展、转义和引号、重定向和管道：

- Shell 就是用户和 Linux 用来交互的命令行程序，多数都为 bash；
- 模式扩展是指 Shell 会将输入命令中的特殊字符扩展为对应的指令执行，这里有多种模式扩展；
- 转义则是我们键入命令时想让特殊字符保持原意，使用反斜线（`\`）表示转义，引号则是为了将引号中的内容以无格式字符的形式输出，但也有特殊情况；
- 重定向可以改变标准流的默认连接，管道则是一系列将标准输入输出连接起来的进程，其中前一个进程的输出被直接作为下一个进程的输入；

接下来记录了一些常用命令，方便后续查阅。

### 参考链接

- [快速上手几个Linux命令：每家公司都有自己的黑话 (geekbang.org)](https://time.geekbang.org/column/article/88761)

- [Bash 简介 - Bash 脚本教程 - 网道 (wangdoc.com)](https://wangdoc.com/bash/intro.html)

- [Bash 的模式扩展 - Bash 脚本教程 - 网道 (wangdoc.com)](https://wangdoc.com/bash/expansion.html)

- [引号和转义 - Bash 脚本教程 - 网道 (wangdoc.com)](https://wangdoc.com/bash/quotation.html)

- [the-art-of-command-line (github.com)](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md)

