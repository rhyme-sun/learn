# Socket 编程实现 HttpServer

Socket 编程实现 HttpServer。

## 简单实现

使用一个线程不断地 accpet 连接请求，当获取到连接请求时在当前线程中处理请求并返回，代码如下所示：

```java
public class HttpServer1 {

    public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8081, 100);

        while (true) {
            // 线程会被阻塞在 accept 方法
            Socket client = server.accept();
            log.info("Client's port: {}", client.getPort());
            // 省略处理代码
            service(client);
        }
    }
    
    private static void service(final Socket socket) {
        try {
            Thread.sleep(10);
            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            StringBuilder builder = new StringBuilder();
            String line;
            while (true) {
                line = reader.readLine();
                if (Objects.isNull(line) || line.isBlank()) {
                    break;
                }
                builder.append(line + "\n");
            }
            log.info("Data from client: {}", builder);

            PrintWriter printWriter = new PrintWriter(socket.getOutputStream(), true);
            printWriter.println("HTTP/1.1 200 OK");
            printWriter.println("Content-Type:text/html;charset=utf-8");
            String body = "hello";
            printWriter.println("Content-Length:" + body.getBytes().length);
            printWriter.println();
            printWriter.write(body);
            printWriter.close();
            reader.close();
            socket.close();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

启动后使用 [SuperBenchmarker](https://community.chocolatey.org/packages/SuperBenchmarker) 进行简单的测试，测试命令如下：

```powershell
sb -u http://127.0.0.1:8081 -c 10 -n 1000 -B
```

结果如下所示：

```
RPS: 57.9 (requests/second)
Max: 207ms
Min: 66ms
Avg: 160.4ms
```

这个 `HttpServer` 有个明显的弊端就是，用来接收连接请求的线程（派发线程）和处理任务的线程（工作线程）是同一个线程，串行的去处理每个连接请求，服务支持的并发数比较低。

## 多线程优化

在主线程里处理连接，对于每一个连接创建一个线程去处理，代码如下所示：

```java
@Slf4j
public class HttpServer2 {

    public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8082, 10);

        while (true) {
            // 线程会被阻塞在 accept 方法
            Socket client = server.accept();
            log.info("Client's port: {}", client.getPort());
            new Thread(() -> {
                // 省略处理代码
                service(client);
            }).start();
        }
    }
    
    private static void service(final Socket socket) {
        try {
            Thread.sleep(10);
            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            StringBuilder builder = new StringBuilder();
            String line;
            while (true) {
                line = reader.readLine();
                if (Objects.isNull(line) || line.isBlank()) {
                    break;
                }
                builder.append(line + "\n");
            }
            log.info("Data from client: {}", builder);

            PrintWriter printWriter = new PrintWriter(socket.getOutputStream(), true);
            printWriter.println("HTTP/1.1 200 OK");
            printWriter.println("Content-Type:text/html;charset=utf-8");
            String body = "hello";
            printWriter.println("Content-Length:" + body.getBytes().length);
            printWriter.println();
            printWriter.write(body);
            printWriter.close();
            reader.close();
            socket.close();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

这时候使用 SuperBenchmarker 测试，测试命令：

```powershell
sb -u http://127.0.0.1:8082 -c 10 -n 1000 -B
```

测试结果：

```
RPS: 372.5 (requests/second)
Max: 76ms
Min: 6ms
Avg: 13.7ms
```

Thread 是比较重量级的资源，过多的线程意味着会消耗更多的系统资源、更多的上下文切换和更多的锁互斥。所以当并发量很高时不适合每个请求都重新创建线程，可以使用线程池进行优化，代码如下所示：

```java
@Slf4j
public class HttpServer3 {

    public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8083, 10);
        final ExecutorService service = Executors.newFixedThreadPool(10);
        while (true) {
            // 线程会被阻塞在 accept 方法
            Socket client = server.accept();
            log.info("Client's port: {}", client.getPort());
            // 省略处理代码
            service.execute(() -> service(client));
        }
    }
}
```

同样地进行简单的测试，测试命令：

```powershell
sb -u http://127.0.0.1:8083 -c 10 -n 1000 -B
```

测试结果：

```
RPS: 346.4 (requests/second)
Max: 81ms
Min: 5ms
Avg: 14.2ms
```

## NIO 实现

```java
@Slf4j
public class ReactorServer {

    public static void main(String[] args) throws IOException {
        server();
    }

    public static void server() throws IOException {
        final ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.bind(new InetSocketAddress(8084));

        final Selector selector = Selector.open();
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        ByteBuffer byteBuffer = ByteBuffer.allocate(1024 * 16);

        // selector.select()：阻塞到至少有一个管道处于就绪状态
        while (selector.select() > 0) {
            final Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();
            while (selectedKeys.hasNext()) {
                final SelectionKey selectedKey = selectedKeys.next();
                selectedKeys.remove();
                if (selectedKey.isAcceptable()) {
                    SocketChannel socketChannel = serverSocketChannel.accept();
                    socketChannel.configureBlocking(false);
                    socketChannel.register(selector, SelectionKey.OP_READ);
                } else if (selectedKey.isReadable()) {
                    read(byteBuffer, selectedKey);
                } else if (selectedKey.isWritable()) {
                    SocketChannel socketChannel = write(byteBuffer, selectedKey);
                    socketChannel.close();
                }
            }
        }
    }

    private static void read(ByteBuffer byteBuffer, SelectionKey selectedKey) throws IOException {
        SocketChannel socketChannel = (SocketChannel) selectedKey.channel();

        byteBuffer.clear();
        StringBuilder request = new StringBuilder();
        int length;
        while ((length = socketChannel.read(byteBuffer)) > 0) {
            request.append(new String(byteBuffer.array(), 0, length));
            byteBuffer.clear();
        }
        log.info("Data from client: {}", request);
        selectedKey.interestOps(SelectionKey.OP_WRITE);
    }

    private static SocketChannel write(ByteBuffer byteBuffer, SelectionKey selectedKey) throws IOException {
        SocketChannel socketChannel = (SocketChannel) selectedKey.channel();
        byteBuffer.clear();
        byteBuffer.put(("HTTP/1.1 200 OK" + System.lineSeparator()).getBytes());
        byteBuffer.put(("Content-Type:text/html;charset=utf-8" + System.lineSeparator()).getBytes());
        String body = "hello";
        byteBuffer.put(("Content-Length:" + body.getBytes().length + System.lineSeparator()).getBytes());
        byteBuffer.put((System.lineSeparator()).getBytes());

        byteBuffer.flip();
        while (byteBuffer.hasRemaining()) {
            socketChannel.write(byteBuffer);
        }
        return socketChannel;
    }
}
```

这时候使用 SuperBenchmarker 测试，测试命令：

```powershell
sb -u http://127.0.0.1:8084 -c 10 -n 1000 -B
```

测试结果：

```
RPS: 705.6 (requests/second)
Max: 54ms
Min: 0ms
Avg: 2.9ms
```

## 总结

### 参考链接

- [Java NIO Tutorial (jenkov.com)](http://tutorials.jenkov.com/java-nio/index.html)

- [《Scalable IO in Java》译文 - bigfan - 博客园 (cnblogs.com)](https://www.cnblogs.com/dafanjoy/p/11217708.html)