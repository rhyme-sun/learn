# 分布式事务

## 总览

## 分布式事务基础

什么叫做分布式事务?

分布式条件下，多个节点操作事务的整体一致性。单机情况下，我们通过事务来保证数据的事务一致性，将这种数据事务一致性的保证扩充到分布式条件下就产生了分布式事务。

实现分布式事务的主要两个思路：

- 和使用单机数据库事务一样，通过多个数据库通过某个机制协调，实现跨数据节点的一致性。这个协调机制叫做强分布式事务，如 XA。
- 若可以容忍一段时间的数据不一致，通过一些其它方式实现数据补偿冲正，保证数据的最终一致。这种机制叫做柔性事务。

### CAP 理论

CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。

- 一致性（C）：对于在分布式系统中的所有数据备份，所有节点访问到一致的最新的数据副本。

- 可用性（A）：非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应），但是不保证获取的数据为最新数据。

- 分区容错性（P）：分布式系统出现分区（网络分区）的时候，仍然能够对外提供服务。

  ```
  Note:
  网络分区？
  网络分区：分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。
  
  三种一致性策略？
  强一致性：对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。
  弱一致性：如果能容忍后续的部分或者全部访问不到，则是弱一致性。
  最终一致性：如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。
  CAP 中的一致性是指强一致性。
  
  实际我们只能选择 AP 和 CP?
  实际上我们无法保证网络不出现分区，或者说我们无法保证在网络连通的情况下同时保证多点系统的可用性和一致性。所以 P 是一定满足的，即一定会出现网络分区，在此条件下强一致性和可用性只能 2 选 1。
  
  CAP 的简单证明？
  假设服务的两个节点分别处不同网络分区中，即满足 P，若系统对其中一个节点进行了写操作，为了保证一致性，必须禁止掉其它节点的读写操作，其它节点不可用了，违背了可用性原则；如果要保证可用性，则某个节点获取到数据不是最新的副本，一致性又没法保障；除非两个节点可以互通，此时不满足分区容错性。
  ```

## XA 分布式协议

### XA 协议涉及到的角色

XA 是处理分布式事务的一套解决方案，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口。一个 TM 通过这些接口协调多个 RM 之间的一致性动作，完成分布式事务的统一提交和回滚。

- 应用程序（AP）：用于定义事务的边界（事务开始和结束的地方），并且在事务边界对边界内资源进行操作。
- 资源管理器（RM）：参与者，管理资源，并提供访问资源的入口，如数据库，文件系统等。
- 事务管理器（TM）：协调者，负责分配事务的唯一标识，监控事务的执行进度，并负责事务的提交，回滚等。

```
XA 并不是 Java 的标准，而是一套和编程语言无关的通用规范，基于 XA，Java 定义了 JTA 来实现分布式事务，主要有两个接口：

1. 事务管理器的接口：javax.transaction.TransactionManager。这套接口是给Java EE服务器提供容器事务（由容器自动负责事务管理）使用的，还提供了另外一套javax.transaction.UserTransaction接口，用于通过程序代码手动开启、提交和回滚事务。
2. 满足XA规范的资源定义接口：javax.transaction.xa.XAResource，任何资源（JDBC、JMS等等）如果想要支持JTA，只要实现XAResource接口中的方法即可。
```

### 两阶段提交（2 Phase Commit,2PC）

XA 事务将事务的提交分为两个阶段，大致流程如下：

- 准备阶段（prepare）：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；
- 执行阶段（commit/rollback）：事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。

前提：

- 必须保证在提交阶段网络通信是可靠的，即所有的 RM 均正确收到提交或回滚的消息，并成功执行。准备阶段失败了可以补救，即在执行阶段执行回滚操作即可，但执行阶段执行失败了，无法控制，所以尽量保证执行阶段能够快速完成，降低失败的概率。
- 必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。

存在的问题：

- 单点问题：允许参与者宕机，不允许协调者宕机，协调者宕机所有的参与者都会收到影响。
- 性能问题：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，整个过程持续到参与者集群中最慢的那一个处理操作结束为止。
- 一致性风险：两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。

为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了三阶段提交（3 Phase Commit，3PC）协议。三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 `CanCommit`、`PreCommit`，把提交阶段改称为 `DoCommit` 阶段。将准备阶段分成两个阶段的理由是：这个阶段是重负载的操作，分成两个阶段便于快速的发现提交的可行性，降低提交失败的风险，避免做无用功。

### XA 接口

- `xa_start`：负责开启或者恢复一个事务分支。
- `xa_end`：负责取消当前线程与事务分支的关联。
- `xa_prepare`：询问 RM 是否准备好提交事务分支。
- `xa_commit`：通知 RM 提交事务分支。
- `xa_rollback`：通知 RM 回滚事务分支。
- `xa_recover`： 需要恢复的 XA 事务。

### MySQL XA 事务状态

![](../images/MySQL下XA事务的状态.png)

### 完整的 XA 事务处理流程

![](../images/XA事务处理流程.png)

### 单个 MySQL 内 XA 的操作过程

![](../images/单个MySQL的XA流程.png)

// TODO ... XA 协议的理解

## BASE 柔性事务

### BASE 理论

如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称为柔性事务。BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。 

- 基本可用（Basically Available-BA）保证分布式事务参与方不一定同时在线。

- 柔性状态（Soft state-S）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。 

- 最终一致性（Eventually consistent-E）通常是通过消息传递的方式保证系统的最终一致性。 

在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 **柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面，通过放宽对强一致性要求，来换取系统吞吐量的提升。**

### BASE 柔性事务下的 ACID

- 原子性（Atomicity）：正常情况下保证。 
- 一致性（Consistency），在某个时间点，会出现A库和B库的数据违反一致性要求的情况，但是最终是一致的。 
- 隔离性（Isolation），在某个时间点，A 事务能够读到 B 事务部分提交的结果。 
- 持久性（Durability），和本地事务一样，只要 commit 则数据被持久化。

### 幂等操作

一个操作成功执行多次的结果和成功执行一次的结果是相同的，则这个操作就叫做幂等操作。

## TCC/AT以及相关框架

### TCC 

TCC 模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据第一阶段的状态执行确认和释放资源的操作，它是一种业务侵入式较强的事务方案。

TCC 使用要求就是业务接口都必须实现三段逻辑： 

1. Try 准备阶段：完成所有业务可执行性的检查（一致性保障），并且预留好全部需用到的业务资源（保障隔离性）。 
2. Confirm 确认阶段：不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，尽最大努力提交，因此需要满足幂等性。
3. Cancel 取消阶段：释放 Try 阶段预留的业务资源。Cancel阶段可能会重复执行，尽最大努力取消，也需要满足幂等性。

TCC 需要注意的问题？

1. 允许空回滚。
2. 防止悬挂控制。
3. 幂等设计。

```
TCC 和 2PC 的区别？
根据流程来讲，TCC 和 2PC 有点类似，但 TCC 在应用层面，体现在用户代码上，而不是在基础设施层面，体现在数据库上。这一特性为 TCC 的具体执行带来较高的灵活性，可以根据需要设计“资源”粒度。
```

### SAGA

SAGA 事务由两方面组成：

- 大事务拆分若干个小事务，将整个分布式事务T分解为n个子事务，命名为T1，T2，... 。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交等价。
- 为每一个子事务设计对应的补偿动作，命名为C1，C2，... 必须满足以下条件：
  - T 与 C 都具备幂等性。
  - T 与 C 满足交换律（Commutative），即先执行 T 还是先执行 C，其效果都是一样的。
  - C 必须能成功提交，即不考虑 C 本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。

如果 T 全部提交成功，那事务完成，否则要采取以下两种恢复方式：

- 正向恢复：对所有的 T 执行新一轮的提交。
- 反向恢复：执行所有的补偿操作。

### AT

AT 模式就是两阶段提交，自动生成反向SQL。

## `ShardingSphere`



## 总结

### 参考链接

[[1] 小米技术团队.分布式事务](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)

[[2] JavaGuide.CAP理论](https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/CAP%E7%90%86%E8%AE%BA.md)

[[3] 周志明.The Fenix Project](https://icyfenix.cn/architect-perspective/general-architecture/api-style/rpc.html)