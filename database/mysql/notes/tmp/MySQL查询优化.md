# MySQL 查询优化

##  总览

记录一些查询优化的案例，和一些特定查询需要注意的点。

什么时候需要进行查询优化？

从数据库查询数据的速度不能满足业务的要求时，需要针对具体的场景进行查询优化。优化可以从提高 MySQL 查询效率入手，也可以考虑采用其他技术或者业务手段，达到预期的结果。除此之外，在使用一些手段使得查询效率得到提升外，还需注意这些手段可能带来的其他影响，比如，我们可以利用缓存来提升数据的查询效率，但缓存冗余了数据，就不得不考虑数据一致性问题。

MySQL 查询优化的出发点？

- 减少数据量：每次查询查询自己需要的数据。

- 减少 IO 次数：了解 MySQL 索引原理，使用索引，利用索引覆盖，索引下推特性减少回表次数。

## 数量查询

`COUNT(*)`，`COUNT(1)`，`COUNT(列名)` 都可以用来统计数量，其中 `COUNT(*)` 和 `COUNT(1)` 表示查询表的行数，`COUNT(列名)` 用来查询指定列不为 NULL 的条数。对于 `COUNT(1)` 和 `COUNT(*)`，`MySQL` 的优化是完全一样的，查询效率相同， `COUNT(列名)` 则需要全表扫描，判断指定字段的值是否为 NULL，性能要比前两者慢。

- MyISAM 对 `COUNT(*)` 的优化 

  MyISAM 做了一个简单的优化，把表的总行数单独记录下来，如果执行 `COUNT(*)` 时可以直接返回，**前提是不能有 WHERE 条件**。MyISAM  之所以能够做到这个优化，是因为 MyISAM 是表级锁，不会有并发的行操作，所以每次查到的结果是准确的。

- InnoDB 对  COUNT(*) 的优化 

  从 MySQL 8.0.13 开始，如果没有额外的子句（如 WHERE 或 GROUP BY），**MySQL 会优先选择最小的非聚簇索引来扫表。**

## 排序分组

我们知道 MySQL 的索引是有序的，如果在排序或分组时若能够用到索引，相比于直接使用排序算法，能够显著的提高查询效率。我们可以利用执行计划来判断是否使用到了索引，详细来讲，如果 explain 出来的 type 列的值为 index，则说明 MySQL 使用了索引扫描来做排序。

利用索引排序的前提条件

> 只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL 才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。也需要满足索引的最左前缀要求（例外：前导列为常量的时候）。——《高性能 MySQL》

## 关联查询

### 关联算法

// TODO ... 重新画图

// TODO ... 案例

- Simple Nested-Loop Join 简单嵌套循环连接

  R 为驱动表，S 为匹配表，从 R 表依次取出数据，和 S 表中的数据依次比较，留下满足条件的结果集合。

  ![](../images/SimpleNestedLoopJoin.png)

- Index Nested-Loop Join 索引嵌套循环连接

  要求非驱动表上有索引，使用索引来直接定位到满足匹配条件的数据，减少了对匹配表的访问次数。匹配到索引后，若不是主键索引，再回表查询 S 表的所有数据，构建出结果集合。

  ![](../images/IndexedNestedLoopJoin.png)

- Block Nested-Loop Join  块索引嵌套连接

  使用 join buffer 将驱动表 R 的数据加载到缓冲区，然后批量和匹配表匹配，减少了对匹配表的访问次数。默认情况下 join buffer 的大小为 256K ，一个 join 对应有一个 join buffer。

  ​	![](../images/BlockNestedLoopJoin.png)

### 内连接和外连接

- 内连接，返回的结果集只包含和符合连接条件的数据行；
- 外连接，返回的结果集合中的不仅包含符合连接条件的数据行，而且还包括驱动表所有的数据行，匹配表匹配不上用 NULL 连接。外连接分为左外连接（左连接）和右外连接（右连接）。

### ON 和 WHERE

ON 后的条件和 WHERE 后的过滤条件作用并不相同，以左连接为例，ON 后的条件仅仅作为驱动表和匹配表数据连接条件，若匹配，连接上匹配表对应数据，若匹配不上，连接 NULL；WHERE  后的条件是的对连接的后的结果进行过滤。总的来说，ON 后的条件作用于连接过程中，判断连接条件是否匹配，WHERE 则是在连接结束后，对整个结果集进行过滤。

## 分页查询

在很多应用场景中我们需要将数据进行分页，一般会使用 limit 加上偏移量的方法实现，同时加上合适的 order by 的子句，如果这种方式有索引的帮助，效率通常不错，否则的化需要进行大量的文件排序操作。此外，当偏移量非常大的时候，前面的大部分数据都会被抛弃，这样的代价太高。要优化这种查询的话，要么是在页面中限制分页的数量，要么优化大偏移量的性能，比如使用尽可能地使用覆盖索引，而不是查询所有的列。如：

```sql
explain select * from user order by age limit 50,5;
explain select user.id,user.age,user.namae from user inner join (select id from user order by age limit 50,5) as lim using(id);
```

```
Note:
为什么 offset 偏大之后 limit 查找会变慢？
MySQL 的 limit m,n 工作原理就是先读取前面 m+n 条记录，然后抛弃前 m 条，读后面 n 条想要的，所以 m 越大，偏移量越大，读取的无效的数据就越多，性能就越差。
```

## 其他优化

- 当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层。如：

  ```sql
  select * from user where id=4;
  select * from user where id+1=5;
  ```

- 尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表查询，所以表应该尽量建立主键。

- 强制类型转换会全表扫描，如使用字符类型当作数字类型列的过滤条件。如：

  ```sql
  explain select * from user where id=1; 
  explain select * from user where id='1';
  ```

- 当一个字符类型的字段数据较长时，可以使用前缀索引减少索引的存储空间。

- EXIST 和 IN

  - IN 使用内表驱动，先查内表的结果，再和外表做笛卡尔乘积，然后按照条件筛选。

  - EXIST 使用外表驱动，先查外表，再循环查询内表，根据筛选条件留下满足的记录。

  总的来说，内表较小适合用 IN，外表较小适合用 EXIST。

## 总结



