# MySQL 基础知识

## 总览

## 数据库基础知识

### 正确性

从直觉上来讲，数据库使用了存储数据的，并且提供了修改和读取数据的能力。更进一步说，从使用的角度去看，数据库需要提供符合我们预期的“正确”操作存储数据的能力，但从数据库角度去看，这种正确性又意味着什么？你可能会发现，要实现这种所谓的“正确性”并不容易。

### 数据库模型

一个数据库系统由不可再分的、互不重叠的数据对象集合组成，每个对象集合都有一个取值范围。数据库系统的一个存储状态就是范围确定得到的对象集合。数据库操作可分为读操作和写操作。

### 数据库事务

数据库事务是对数据库系统读写操作的更高一层抽象，代表了一个单位的数据库操作。事务将对多个数据对象的多个读写操作视为一个整体，一个操作单位，对外具有 ACID 四个特性。

- Atomicity：原子性，一次事务中的操作要么全部成功，要么全部失败。 

- Consistency：一致性，跨表、跨行、跨事务，数据库始终保持一致状态。 

- Isolation:：隔离性，可见性，保护事务不会互相干扰，包含 4 种隔离级别。 

- Durability：持久性，事务提交成功后，不会丢数据，如电源故障, 系统崩溃。

事务这个概念在数据库系统和用户之间提供了一层抽象，用户仅通过事务这一概念就可以享受 ACID 四个特性，而不需要自己去处理复杂的正确性需求。总的来说，要满足正确性这一需求时十分复杂的，数据库系统封装了这种复杂性，并对外提供事务这一种抽象来使得用户不用独自面都这种复杂性，用户只要选择相信和熟悉并使用这层抽象变可以做到正确性。

```
Note:
从工程学出发，如果把正确性作为最顶层的抽象或者作为最终目标，那么事务可作为正确性和正确性具体实现的中间一层抽象，它比正确性更加具体，同时也容易实现。

偏序？
// TODO ...
```

## 关系型数据库

关系型数据库：采用了关系模型来组织数据，以行和列来存储数据的数据库。

关系模型中的概念：

- 关系：一张二维表就是一个关系，每个关系具有一个关系名称，在数据库里被称为表名。
- 元组：二维表中的一行，在数据库里被称为记录。
- 属性：二维表中的一列，在数据库里被称为字段。
- 域：属性的取值范围，在数据里某一列的取值限制。
- 关键字：一组可以唯一标识元组的属性，数据库中的主键，有一列或多列组成。
- 关系模式：指对关系的描述，其格式为：关系名(属性1，属性2， ... ... ，属性N)，在数据库里被称为表结构。

关系型数据库的优点：

- 容易理解：关系模型非常贴近逻辑世界的概念。

- 使用方便：得益于 SQL（结构化查询语言），通用的 SQL 使用户操作关系型数据库非常方便。

- 数据事务一致性：保证了数据事务一致性，使得系统在数据变化前后都处于有效的运行状态。

  ```
  Note:
  什么叫作数据事务一致性？
  事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用；如果在事务中出现错误，那么系统中的所有变化将自动地回滚。这种数据前后变化的一致性保证了系统始终处于有效的运行状态。
  ```

关系型数据库的缺点：

- 无法适应非结构化的数据存储。
- 数据对象需要通过 SQL 解析，大量数据，高并发下性能不足。

- 为了维护数据的事务一致性，降低了数据库的读写性能。

### 结构化查询语言（SQL）

1. 数据查询语言（DQL: Data Query Language）：也称为“数据检索语句” ，用以从表中获得数据，确定数据怎样在应用程序给出。保留字有 SELECT，WHERE，ORDER BY，GROUP BY 和 HAVING。
2.  数据操作语言（DML: Data Manipulation Language）：其语句包括动词 INSERT、 UPDATE 和 DELETE。它们分别用于添加、修改和删除。
3.  事务控制语言（TCL）：它的语句能确保被 DML 语句影响的表的所有行及时得以更新。包括 COMMIT（提交）、SAVEPOINT（保存点）、ROLLBACK（回滚）。 
4. 数据控制语言（DCL）：它的语句通过 GRANT 或 REVOKE 实现权限控制，控制用户或用户组对数据库对象的访问。某些 RDBMS 可用 GRANT 或 REVOKE 控制对表单个列的访问。
5.  数据定义语言（DDL）：其语句包括动词 CREATE，ALTER 和 DROP。在数据库中创建表、修改表、删除表、为表加入索引等。 
6. 指针控制语言（CCL）：它的语句，像 DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。

### 关系型数据库范式

范式是符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度，拿关系型数据库来说，可以理解为一张表的结构所符合某种设计标准的级别。数据库范式是层层递进的，如符合第二范式的必定符合第一范式。

- 第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。拆列。
- 第二范式（2NF）：在第一范式的基础上，消除部分依赖，确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。和主键没有关系的列拆出去，拆表。
- 第三范式（3NF）：在第二范式的基础上，消除传递依赖，确保数据表中的每一列数据都和主键直接相关，而不能间接相关。和主键没有直接关系的拆除去，拆表。
- 巴斯-科德范式（BCNF）：在第三范式的基础上，消除主属性对码的部分和传递依赖。将组成主键的属性组单独当作一组关系，其需要满足第二和第三范式。指导主键的设计，主键是由一个字段组成的，其必定符合 BC 范式。
- 第四范式（4NF）：消除非平凡值的依赖。// TODO ...
- 第五范式（5NF）：消除一些不合适的连接依赖。// TODO ...

```
Note:
函数依赖？
假设 X，Y 是关系 R 的两个属性集合，X 集合确定时有唯一的 Y 集合与之对应，则称 X 函数决定 Y，或 Y 函数依赖于 X，记作 X-> Y。
完全函数依赖：
如果存在 X 属性集决定唯一的 Y，但 X 中的任一子集都不能决定唯一的 Y，则 Y 完全依赖于 X。
部分函数依赖：
如果存在 X 属性集决定唯一的 Y，并且 X 中的任一子集都能决定唯一的 Y，则 Y 部分依赖于 X。
传递函数依赖：
设 R 为任一给定关系， X，Y，Z 为其不同的属性子集，若 Y 依赖 X，Z 依赖 Y，称为 Z 传递函数依赖于 X。

码是什么？
设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K，那么我们称 K 为候选码，简称为码。换句话说，假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码，但实际应用中为了方便，通常选择其中的一个码作为主码。
包含在任何一个码中的属性称为主属性。
```

### 常见的数据库

- 关系型数据库：
  - 开源：`MySQL`，`PostgreSQL`
  - 商业：`Oracle`，`DB2`，`SQL Server`

- 内存数据库：`Redis`，`VoltB`

- 图数据库：`Neo4j`，`Nebula`

  存储图数据结构。

- 时序数据库：`InfluxDB`，`openTSDB`

  存储有周期的打点数据。

- 其它关系型数据库：`Access`，`Sqlite`，`H2`，`Derby`，`Sybase`，`Infomix`

- NoSQL 数据库：`MongoDB`，`Hbase`，`Cassandra`，`CouchDB`
- NewSQL/分布式数据库：`TiDB`，`CockroachDB`，`NuoDB`，`OpenGauss`，`OB`，`TDSQL`

### SQL 语法解析

- 手动实现： `druid`，`mycat` 
- `antlr4`：`shardingsphere`
- `yacc`：`MySQL`，`TiDB`

## MySQL 基本原理

### MySQL 架构

MySQL 架构图

![](../images/MySQL架构图.png)

### MySQL 执行流程

MySQL 简单执行流图

![](../images/MySQL简单执行流程.png)

- 一个查询语句大概的执行流程

  ```sql
  select * from T where ID=10;
  ```

1. 连接器：管理连接，权限验证

   一般通过以下命令建立连接

   ```shell
   mysql -h 127.0.0.1 -P3306 -uroot -p
   ```

   连接建立过程中，连接器会获取用户相关权限，以后这个连接里的权限处理都依赖此时读取到的权限，这意味着再连接建立完毕后用户的权限有修改，不会再建立好的连接上立即生效，只有重新建立连接才会使用新的权限设置。

   连接建立完毕后，若没有后续动作，连接会处于空闲状态，客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

   ```
   Note:
   使用 show processlist 可以查看连接状态。
   
   长连接和短链接？
   在数据库里，长连接指客户端持续的请求都可以一直使用同一个连接，长连接默认在空闲 8 小时后会自动断开，这个时间可由 wait_timeout 来控制，短链接是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。
   数据库连接是一种高消耗的资源，所以实际使用过程中尽量使用长连接。但是一个连接存活期间，MySQL 执行过程中临时使用的内存是管理在连接对象里面的，这些内存在连接断开的情况下才会释放，所以长连接积累下来，会导致内存越来越大。
   
   如何解决长连接带来的内存占用过大的问题？
   1. 断开连接：定期断开长连接，或者程序里面控制，在每次执行一个较大的操作后，程序里主动断开连接。
   2. 重置连接：MySQL5.7 以后，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。
   ```

2. 查询缓存：

   MySQL 获取到一个查询请求后会先去缓存中查询，看看本次的查询是否已经被缓存过，缓存以 key-value 结构存在，其中 key 为查询的语句，value 为上次查询的结果，如果存在直接返回。

   ```
   Note:
   要不要使用 MySQL 的查询缓存，为什么？
   将查询的结果缓存起来，可以减少 MySQL 查询执行的步骤，提高查询效率。但需要考虑缓存的数据和实际数据一致性的问题，即缓存刷新。MySQL 将一次的查询结果缓存其它，当和这次查询任意相关的表有变更都会将查询缓存清空，查询缓存的命中率很低。
   
   MySQL8.0 版本以后不再支持查询缓存。
   ```

   按需使用：将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，如下：

   ```
   select SQL_CACHE * from T where ID=10;
   ```

3. 分析器：

   分析器主要负责对 SQL 的词法分析和语法分析。

   词法分析：解析 SQL 语句，明确 SQL 语句的意图。

   语法分析：判断 SQL 语句的语法是否正确。

4. 优化器

   对将要执行的 SQL 进行优化处理，比如优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

5. 执行器

   - 权限判断：执行前需要先进行权限。
   - 扫描表：执行引擎扫描表，获取满足条件的数据。

- 一个更新语句大概的执行流程

  ```sql
  update T set c=c+1 where ID=2;
  ```

1. 连接器
2. 查询缓存：和查询时不同，这里时将相关表的查询缓存清空。
3. 分析器
4. 优化器
5. 执行器

### MySQL 存储文件

独占模式 

1. 日志组文件：`ib_logfile0` 和 `ib_logfile1`，默认均为 5M。

2. 表结构文件：`*.frm `

3. 独占表空间文件：`*.ibd `

4. 字符集和排序规则文件：`db.opt `

5. `binlog` 二进制日志文件：记录主数据库服务器的 DDL 和 DML 操作 。

6. 二进制日志索引文件：`master-bin.index `。

共享模式 `innodb_file_per_table=1 `

1. 数据都在 `ibdata1`。

### MySQL 存储引擎和状态

存储引擎

| 存储引擎 | `MyISAM` | `InnoDB` | `Memory` | `Archive` |
| -------- | -------- | -------- | -------- | --------- |
| 存储限制 | 256TB    | 64TB     | 有限制   | 无限制    |
| 事务     | 不支持   | 支持     | 不支持   | 不支持    |
| 索引     | 支持     | 支持     | 支持     | 不支持    |
| 锁的粒度 | 表锁     | 行锁     | 表锁     | 行锁      |
| 数据压缩 | 支持     | 不支持   | 不支持   | 支持      |
| 外键     | 不支持   | 支持     | 不支持   | 不支持    |

状态

| 状态                    | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| sleep                   | 线程正在等待客户端发送新的请求。                             |
| query                   | 线程正在执行查询语句或将查询结果发送给客户端。               |
| locked                  | 线程正在等待表锁。                                           |
| analysis and statistics | 线程正在收集存储引擎的统计信息，并生成查询的执行计划。       |
| copying to temp table   | 线程正在执行查询，并将查询结果复制到临时表中，一般是 group by、文件排序、union 操作。 |
| on disk                 | 线程正在将内存中的临时表放到磁盘上。                         |
| sorting result          | 线程正在对查询结果按指定条件排序。                           |
| sending data            | 线程在多个状态间传递数据或生成结果集或向客户端返回数据。     |

## MySQL 索引原理

索引的出现是为了提高数据的查询效率，类似于书的目录。

### 常见的索引模型

用于提高数据读取效率的数据结构有很多，常见的有：哈希表，有序数组，搜索树。

- 哈希表：一种 key-value 的存储结构，通过哈希函数将 key 转换成一个数值，作为 value 的存储和检索位置。

  哈希冲突：即不同的 key 计算出的数值相同，解决哈希冲突的方式有很多，比如将冲突的值放到一个链表中，读取时找到链表，再遍历取值。

  等值查询：哈希表的存储时无序的，所以不适合做区间查询，哈希表适合用于等值查询（即用是不是等于某个值作为检索条件）场景。

- 有序数组：有序数组将数据按照一定的顺序存放，这种顺序的保证提高了检索的效率，比如使用二分法检索有序数组的时间复杂度是

  `O(logN)`，而且有序数组适合做区间查询，但为了维护数组的有序性，可能再插入和删除数据时需要挪动数据。所以有序数组适合静态数据存储引擎。

- 搜索树：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值，检索时间复杂度时 `O(logN)`，但为了维护这种平衡性（左小右大），每次更新的时间复杂度也是 `O(logN)`。

  减少访问磁盘块的个数：树的结构若存储到磁盘上，深度增加会增加占用磁盘块的个数，增加访问时间。为了让一次查询尽量少的读写磁盘，就必须让查询过程访问尽量少的数据块，所以降低树的深度（2 叉树 -> n 叉树）。

  ```
  Note：存储设备区间划分。
  磁盘分块：磁盘最小读取单位是扇区（512B）,磁盘块（windows 中称为。）一般以 2^n 个扇区为大小。
  内存分页（4KB）：内存相对于磁盘来说是个高性能存储设备，物理上是按字节寻址的。分页这个概念出现在虚拟内存中，虚拟内存对应用进程来说是一块固定大小的连续内存空间，但在这种连续性是逻辑上的概念，从物理上去看应用进程使用的内存空间往往是离散分布的。为了实现这种逻辑上连续物理上离散的内存分配方式，操作系统维护了内存页这样的概念。
  缓存 cacheline（64字节）：高速缓存比内存效率更高，缓存的目的是为了平衡不同设备间的性能差异。cacheline 的设置利用了[空间局部性原理]，即当前访问的位置，在未来不远的时间内再次访问其相邻位置的可能较大，这也是为了增加 cache 命中的手段。
  
  局部性原理？
  程序访问的局部性原理包括时间局部性和空间局部性。
  空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的；
  时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息。
  ```

### InnoDB 索引模型

#### 索引组织表

在 `InnoDB` 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，表的整行数据存放在主键索引 B+ 树的叶子节点中。有以下几个特征：

1. 在 `InnoDB` 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树。主键索引又叫做聚簇索引，非主键索引又叫做二级索引。
2.  执行查询的效率，使用主键索引 > 使用非主键索引 > 不使用索引。 
3. 如果不使用索引进行查询，则从主索引 B+ 树的叶子节点进行遍历。

```
Note：
主键索引和非主键索引有什么区别？
使用主键索引效率查询效率更高：使用主键索引，只需要搜索主键索引这棵 B+ 树，如果使用非主键索引，去非主键索引搜索到主键，再通过主键索引找到数据，再通过主键索引查询这就这一过程被称为回表。也就是说使用普通索引会多一次回表操作，所以再应用中尽量使用主键索引。
叶子节点存储数据不同：主键 B+ 树叶子节点存储一行数据，非主键索引 B+ 树的叶子节存储对应的主键值。从 B+ 树占用空间来说，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
```

#### 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。

页分裂：新增数时，新增数据所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂。页分裂若产生，申请数据页并且挪动数据，必定会降低数据的写入效率，除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。

页合并：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并，合并的过程，可以认为是分裂过程的逆过程。页合并若产生，会也会影响数据的写入效率。

```
Note:
哪些场景下要使用自增主键，哪些情况下不适合？
自增主键列，在建表时指定列为 NOT NULL PRIMARY KEY AUTO_INCREMENT，插入数据时可以不指定主键的值，数据库会使用当前表中最大的主键值加一作为新的主键。
自增主键适合那种不断往后追加数据的场景，不涉及数据的挪动，不会产生页分裂，这样的主键往往是没有业务含义的。当一个主键具有业务逻辑，则往往不容易保证有序插入，这样写入数据成本相对较高。并且使用自增数字作为主键，非主键索引的 B+ 树的叶子节点占用空间也会相对较少。
但对于那些只需一个索引，并且业务字段值是唯一的，则也可以将业务字段当作主键。
```

#### 索引重建

重建普通索引

```
alter table T drop index k;
alter table T add index(k);
```

重建主键索引

```
alter table T drop primary key;
alter table T add primary key(id);
```

重建索引的原因：

索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

上述重新普通索引的语句合理，重建主键索引语句不合理。不论是删除主键还是创建主键，都会将整个表的所有重建。建议使用以下语句重建索引：

```
alter table T engine=InnoDB;
```

#### 覆盖索引

使用普通索引检索数据，最终需要回到主键索引拿去完整数据，这一过程叫做**回表**。我们知道不同索引的 B+ 树叶子节点存储的是主键的值，若我们通过普通索引查询的数据只包含主键和索引本身字段，则通过普通索引就能拿到需要的字段信息，也就无序回表，这一现象被称为覆盖索引。

我们可以使用联合索引来覆盖更多的字段来减少回表的次数，但联合索引维护的代价更大，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

#### 最左前缀原则

联合索引先根据第一个字段排序，如果第一个字段有相同的，就按照第二个字段排序，注意，这里仅仅有相同的第一个字段情况下，才会根据第二个字段排序。最左前缀原则是指，最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符，可以使用过最左端原则来定位记录，换句话说满足最左端原则的查询条件是可以走索引的，如模糊查询 `like 'K%'` 。

利用最左端原则可以指导我们设计联合索引的顺序：

- 第一原则是，如果通过调整联合索引字段顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
- 第二个原则考虑空间，使用联合索引无法满足需求，需要将为联合缩影中的字段单独创建索引，那么选择占用空间小的字段。

#### 索引下推

当我们使用索引作为过滤条件，同时也使用了一般列作为过滤条件，那么整个检索的顺序应该是这样的：

- 先通过索引过滤出满足条件的数据。
- 再将满足索引条件的一个一个回表，拿到全部数据和另外一个条件做对比和过滤。

索引下推是指，在以上描述的过程中，若索引为联合索引，普通的列是组合联合索引中的某个字段，但不满足最左端原则，所以不会走联合索引，那么可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数（即不满足普通列条件的不会回表，只对满足条件的进行回表操作），这一过程叫做索引下推。

```
Note:
MySQL 5.6 之前没有索引下推机制。
```

```
Note:
为什么要求单表数据一般不要超过 2000 万？
超两千万会使得索引 B+ 树的深度变深，影响检索效率。
```

## MySQL 事务与锁

### MySQL 实现事务的一致性和原子性

#### 日志模块

和查询不同的是，更新流程涉及到了两个重要的日志模块：

1. 重做日志（`redo log`）

   redo log 是引擎层面的日志文件，是 `InnoDB` 引擎独有的。

   **WAL(Write-Ahead Logging)**：数据写入时，先写日志，再**合适的时机**将日志内容写入磁盘，这样极大的提高了数据更新效率。具体来讲，当有一条记录需要更新的时候，`InnoDB` 引擎就会先把记录写到 `redo log` 里面，并更新内存，这个时候更新就算完成了。同时，`InnoDB` 引擎会在适当的时候，将这个操作记录更新到磁盘里面，比如 `redo log` 文件写满后就会将 `redo log` 一部分数据写入磁盘，腾出空间。

   **redo log 文件结构**：`redo log` 文件总体结构类似于一个循环链表，`write pos` 记录了数据写入位置，`check point` 记录了数据擦除的位置，`write pos` 和 `check point` 之间部分就代表剩余可用的空间，当 `write pos` 追上 `check point` 就表示没有多余空间了，此时会触发 `redo log`  写入磁盘操作，腾出空间 。

   **`crash-safe`**：有了 `redo log`，`InnoDB` 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 `crash-safe`。

2. 归档日志（`binlog`）

   `binlog` 是 Server 层面的日志，用来记录语句的原始逻辑，其没有 `crash-safe` 的能力。

3. `redo log` 和 `binlog` 的异同

   - `redo log` 是 `InnoDB` 引擎特有的，`binlog` 是 MySQL Server 层实现，所有的引擎都可以使用。
   - `redo log` 是物理日志，记录的是”在某个数据页上做了什么修改“，`binlog` 记录的是逻辑日志，记录语句的原始逻辑，比如“给 ID=10 这一行的 c 字段加 1 ”。
   - `redo log` 是循环写的，空间会用完，`binlog` 是追加写入的，写满一个文件后换另一个文件，并不会覆盖以前的日志。

4. 执行更新语句执行器和 `InnoDB` 引擎交互流程

   - 执行器从调用引擎接口，获取 ID = 2 这一行数据，若这一行所在的数据页在内存中，就直接返回给执行器，否则需要从磁盘读入内存，再返回给执行器。

   - 执行器拿行数据，改变要更新的值，调用引擎接口写入更新后的数据。

   - 引擎将执行器给的数据写入内存，同时将这个更新操作记录到 `redo log` 里面，此时 `redo log` 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
   - 执行器生成这个操作的 `binlog`，并把 `binlog` 写入磁盘。

   - 执行器调用引擎的提交事务接口，引擎把刚刚写入的 `redo log` 改成 commit 状态，更新完成。

   // TODO ... 流程图

#### 两阶段提交

两阶段提交是指 `redo log` 提交分为 prepare 和 commit 两个阶段来执行。`redo log` 和 `binlog` 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。具体怎么保证的呢？

`redo log` 和 `binlog` 具有关联行，在恢复数据时，`redo log` 用于恢复主机故障时的未更新的物理数据，`binlog` 用于备份操作。每个阶段的 `log` 操作都是记录在磁盘的，在恢复数据时，`redo log` 状态为 commit 则说明 `binlog` 也成功，直接恢复数据；如果 `redo log` 是 prepare，则需要查询对应的 `binlog` 事务是否成功，决定是回滚还是执行。

**两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案**。

```
Note
redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。
```

// TODO ...

## 总结

### 参考链接

[[1] 极客时间.MySQL实战45讲](https://time.geekbang.org/column/intro/139)

