# 关键问题

记录 MySQL 一些问题，包括原理上、使用上的。

[15 | 答疑文章（一）：日志和索引相关问题 (geekbang.org)](https://time.geekbang.org/column/article/73161)

## 日志相关问题

redo log 和 binlog 两阶段提交怎么保证数据一致性？

前面已经说过为什么要使用两阶段提交，或者说不使用两阶段提交会有什么问题。

这里再说明一下两阶段提交具体是怎么保证崩溃恢复后保证数据的完整性的。



先说下两阶段提交的过程，比如执行下面 SQL：

```sql
update T set c=c+1 where ID=2;
```

那么在执行更新 `SQL` 时，结合日志模块，执行器在执行流程如下：

- 执行器找 ID=2 这一行数据；通过数据引擎，如果数据页不在内存中则要从磁盘中读入；
- 执行器拿到这行数据后，给 c 字段加 1，并调用引擎将新行数据写到内存；
- 引擎在写入数据时记录 redo log 日志，此时处于 prepare 阶段，然后通知执行器可以提交事务了；
- 执行器记录 `binlog` 日志；
- 执行器调用引擎的接口提交事务，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

和日志相关的为后面三步，redo log(prepare) --时刻 A--> binlog ----时刻 B--> redo log(commit)，假设数据库分别在时刻 A 和时刻 B 发生崩溃，那么数据库恢复后会进行怎样的操作来保证数据的一致性呢？



时刻 A：如果在时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。



时刻 B：binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？

我们先来看一下崩溃恢复时的判断规则。

- 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；
- 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：
  - 如果是，则提交事务；
  - 否则，回滚事务。





正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？

实际上，**redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况**。

- 如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。
- 在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。

总之要记住，刷盘是指将内存中的脏页放入磁盘，而不是直接有 redo log 到磁盘。



redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？

在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：

```sql
begin;
insert into t1 ...
insert into t2 ...
commit;
```

这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。

所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。



但是，真正把日志写到 redo log 文件（文件名是 ib_logfile + 数字），是在执行 commit 语句的时候做的。

总的来说，事务中，每个更新操作都会记录 redo log，且是放在 redo log buffer 中（内存中），在事务提交后再顺序写入日志文件（磁盘）。





用相同的值更新相同的值？

> 问题详细解答在 [16 | “order by”是怎么工作的？ (geekbang.org)](https://time.geekbang.org/column/article/73479) 结尾处。



```sql
CREATE TABLE `t` (
    `id` int(11) NOT NULL primary key auto_increment,
    `a` int(11) DEFAULT NULL
) ENGINE=InnoDB;
insert into t values(1,2);
```

比如对于上述表，下面 SQL 执行中发生了什么？

```sql
update t set a=2 where id=1;
```

仅从现象上看，MySQL 内部在处理这个命令的时候，可以有以下三种选择：

- 更新都是先读后写的，MySQL 读出数据，发现 a 的值本来就是 2，不更新，直接返回，执行结束；
- MySQL 调用了 InnoDB 引擎提供的“修改为 (1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；
- InnoDB 认真执行了“把这个值修改成 (1,2)"这个操作，该加锁的加锁，该更新的更新。

对于上述三种情况，MySQL 选择的是哪一种？为什么？

选择第三种，老老实实去更新。

如果使用前两中方案，在单个事务，没有冲突的情况下可以达到预期。但在并发条件下，因为在可重复度的隔离级别下，读需要满足一致性读原则，其读到的是当前事务一致性视图可见的数据版本。但更新操作需要继续当前数据的最新版本进行，如果仅通过读来判断相等就返回，会错过本应该执行的更新操作。

比如：

| 事务 A                             | 事务 B                       |
| ---------------------------------- | ---------------------------- |
| begin;                             |                              |
| select * from t where id=1;（a=2） |                              |
|                                    | update t set a=3 where id=1; |
| update t set a=3 where id=1;       |                              |
| select * from t where id=1;（a=3） |                              |

事务 A 最终能够看到最新版本 (1,3)，但这个版本只能是事务 A 自己的 update 语句做更新的时候生成，而不是事务 B 对应的那个版本。

实质上 MySQL 是有判断相等后就不执行更新操作的逻辑的，只不过必须要通过更新语句就能判断出来当前更新是对重复值的更新，比如下面这个例子：

| 事务 A                               | 事务 B                       |
| ------------------------------------ | ---------------------------- |
| begin;                               |                              |
| select * from t where id=1;（a=2）   |                              |
|                                      | update t set a=3 where id=1; |
| update t set a=3 where id=1 and a=3; |                              |
| select * from t where id=1;（a=2）   |                              |

这个例子和上述例子唯一不同在于这里更新条件用了 id=1 and a=3，而上述例子值用了 id=1。

仅通过 id=1 这个条件是不能判断出是不是不需要修改的，所以进行当前读，然后执行更新操作。加上 a=3 后，不需要修改在这个更新语句上语义就完备了，也就可以不用更新，不会产生新的数据版本，所以事务 A 最后查询的值还是 a=2。



> 当前读：更新数据都是先读后写的，而这个读，只能读当前版本的值，称为“当前读”（current read）。
>
> [08 | 事务到底是隔离的还是不隔离的？ (geekbang.org)](https://time.geekbang.org/column/article/70562)

