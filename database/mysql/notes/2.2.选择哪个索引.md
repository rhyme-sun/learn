# 选择哪个索引

[10 | MySQL为什么有时候会选错索引？ (geekbang.org)](https://time.geekbang.org/column/article/71173)

MySQL 在执行时怎么选择索引？

问题引出？

在新增和删除历史数据的时候，MySQL 会选择错索引。 

原因：

delete 语句删掉了所有的数据，然后再通过 call idata() 插入了 10 万行数据，看上去是覆盖了原来的 10 万行。

但是，session A 开启了事务并没有提交，所以之前插入的 10 万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是 delete 之前的数据，新版本是标记为 deleted 的数据。这样，索引 a 上的数据其实就有两份。

## 优化器的逻辑

优化器的目标就是找到一个最优方案，并以最小的执行代价去执行语句，比如选择索引。

在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。



那么优化器在 SQL 未执行前怎么判断 SQL 的扫描行数呢？

MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。

这个统计信息就是**索引的“区分度”**。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。



可以使用 `show index from t` 来查询表索引的基数，但这个基数是一个估计值。



那么，**MySQL 是怎样得到索引的基数的呢**？这里，我给你简单介绍一下 MySQL 采样统计的方法。

采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据超过行数的 1/M 的时候，会自动触发重新做一次索引统计。

在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：

- 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。
- 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。



`analyze table t` 来修正索引统计信息。

所以在实践中，如果你发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可以采用这个方法来处理。



## 总结

在索引历史数据增删处理中，可能会导致优化器选择索引不准确。造成的原因和解决办法如下：

对于由于索引统计信息不准确导致的问题，你可以用 analyze table 来解决。

而对于其他优化器误判的情况，你可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。



